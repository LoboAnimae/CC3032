/*! For license information please see index.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={"./src/Implementations/Components/BasicInformation.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.extractBasicInformation = void 0;\nconst Composition_1 = __importDefault(__webpack_require__(/*! ./Composition */ "./src/Implementations/Components/Composition.ts"));\nfunction extractBasicInformation(inComponent) {\n    if (!inComponent)\n        return null;\n    return inComponent.getComponent({ componentType: BasicInfoComponent.Type });\n}\nexports.extractBasicInformation = extractBasicInformation;\nclass BasicInfoComponent extends Composition_1.default {\n    static Name = \'BasicInformation\';\n    static Type = \'BasicInformation\';\n    name;\n    constructor(options) {\n        super();\n        this.componentName = BasicInfoComponent.Name;\n        this.componentType = BasicInfoComponent.Type;\n        this.name = options?.name;\n    }\n    getName = () => this.name;\n    setName = (newName) => {\n        this.name = newName;\n    };\n    clone = () => {\n        return new BasicInfoComponent({ name: this.name });\n    };\n}\nexports["default"] = BasicInfoComponent;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/BasicInformation.ts?')},"./src/Implementations/Components/Composition.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.CompositionErrors = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ "uuid");\nvar CompositionErrors;\n(function (CompositionErrors) {\n    CompositionErrors["DUPLICATE_COMPONENT"] = "Duplicate component";\n})(CompositionErrors = exports.CompositionErrors || (exports.CompositionErrors = {}));\nclass CompositionComponent {\n    static Name = \'CompositionComponent\';\n    static Type = \'CompositionComponent\';\n    id;\n    unique;\n    /** Managed by members */\n    componentName;\n    /** Managed by primitives*/\n    componentType;\n    /**\n     * The children of a component. They are managed by the component and (should not) have duplicates.\n     */\n    children;\n    constructor() {\n        this.id = (0, uuid_1.v4)();\n        this.componentName = CompositionComponent.Name;\n        this.componentType = CompositionComponent.Type;\n        this.unique = true;\n        this.children = [];\n    }\n    addComponent(...newComponents) {\n        for (const newComponent of newComponents) {\n            if (!newComponent)\n                continue;\n            if (newComponent.unique) {\n                const duplicateElement = this.getComponent({ componentName: newComponent.componentName, componentType: newComponent.componentType }, { currentScope: true });\n                if (duplicateElement) {\n                    throw new Error(CompositionErrors.DUPLICATE_COMPONENT);\n                }\n            }\n            this.children.push(newComponent);\n        }\n        return this;\n    }\n    getComponent(params, options) {\n        return this.getComponents(params, options)[0];\n    }\n    replaceComponent(component) {\n        if (!component)\n            return false;\n        this.removeComponent({ name: component.componentName, type: component.componentType });\n        this.addComponent(component);\n        return true;\n    }\n    getComponents(params, options) {\n        const byPropertyRaw = Object.keys(params).map((key) => ({ key, value: params[key] }));\n        const filters = byPropertyRaw.filter((filtering) => !!filtering.value);\n        const allFound = [];\n        const allComponents = [this, ...this.children];\n        for (const filter of filters) {\n            // @ts-ignore\n            const found = allComponents.filter((component) => component[filter.key] === filter.value);\n            allFound.push(...found);\n        }\n        if (options?.currentScope) {\n            return allFound;\n        }\n        for (const child of this.children) {\n            const found = child.getComponents(params, { currentScope: false });\n            if (!found)\n                continue;\n            allFound.push(...found);\n        }\n        return allFound;\n    }\n    removeComponent(options) {\n        const previousLength = this.children.length;\n        if (options?.id) {\n            this.children = this.children.filter((component) => component.id !== options.id);\n        }\n        if (options?.name) {\n            this.children = this.children.filter((component) => component.componentName !== options.name);\n        }\n        if (options?.type) {\n            this.children = this.children.filter((component) => component.componentType !== options.type);\n        }\n        const newLength = this.children.length;\n        return newLength < previousLength;\n    }\n    /**\n     * Converts a component into a T type. Careful, this does not protect against type errors.\n     * @param asType\n     * @returns\n     */\n    as(asType) {\n        return this;\n    }\n    copy() {\n        const returnValue = this.clone();\n        for (const component of this.children) {\n            const elementExists = !!returnValue.getComponent({ componentType: component.componentType });\n            if (elementExists)\n                continue;\n            returnValue.addComponent(component.copy());\n        }\n        return returnValue;\n    }\n    toString() {\n        return `<Component> ${this.componentName}`;\n    }\n}\nexports["default"] = CompositionComponent;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/Composition.ts?')},"./src/Implementations/Components/ContextHolder.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.extractContext = void 0;\nconst Composition_1 = __importDefault(__webpack_require__(/*! ./Composition */ "./src/Implementations/Components/Composition.ts"));\nfunction extractContext(inComponent) {\n    if (!inComponent)\n        return null;\n    return inComponent.getComponent({ componentType: ContextHolder.Type });\n}\nexports.extractContext = extractContext;\nclass ContextHolder extends Composition_1.default {\n    context;\n    static Name = \'ContextHolder\';\n    static Type = \'ContextHolder\';\n    constructor(context) {\n        super();\n        this.context = context ?? null;\n        this.componentName = ContextHolder.Name;\n        this.componentType = ContextHolder.Type;\n    }\n    clone() {\n        return new ContextHolder(this.context);\n    }\n    getContext = () => this.context;\n    setContext = (context) => {\n        this.context = context;\n    };\n}\nexports["default"] = ContextHolder;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/ContextHolder.ts?')},"./src/Implementations/Components/EmptyComponent.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.isEmptyComponent = void 0;\nconst index_1 = __webpack_require__(/*! ./index */ "./src/Implementations/Components/index.ts");\nfunction isEmptyComponent(inComponent) {\n    return !!inComponent?.children.length;\n}\nexports.isEmptyComponent = isEmptyComponent;\nclass EmptyComponent extends index_1.CompositionComponent {\n    static Name = \'EmptyComponent\';\n    static Type = index_1.CompositionComponent.Type;\n    constructor() {\n        super();\n        this.componentName = EmptyComponent.Name;\n        this.componentType = EmptyComponent.Type;\n    }\n    clone() {\n        return new EmptyComponent();\n    }\n}\nexports["default"] = EmptyComponent;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/EmptyComponent.ts?')},"./src/Implementations/Components/Positioning.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.extractPositioning = void 0;\nconst Composition_1 = __importDefault(__webpack_require__(/*! ./Composition */ "./src/Implementations/Components/Composition.ts"));\nfunction extractPositioning(inComponent) {\n    if (!inComponent)\n        return null;\n    return inComponent.getComponent({ componentType: PositioningComponent.Type });\n}\nexports.extractPositioning = extractPositioning;\n//#region Interfaces\n/**\n * If something implements this, then positions can be stored\n */\nclass PositioningComponent extends Composition_1.default {\n    static Name = "Positioning";\n    static Type = "Positioning";\n    line;\n    column;\n    constructor(options) {\n        super();\n        this.componentName = PositioningComponent.Name;\n        this.componentType = PositioningComponent.Type;\n        this.line = options?.line;\n        this.column = options?.column;\n    }\n    getLine = () => this.line;\n    getColumn = () => this.column;\n    setLine = (line) => {\n        this.line = line;\n    };\n    setColumn = (column) => {\n        this.column = column;\n    };\n    clone() {\n        return new PositioningComponent({ line: this.line, column: this.column });\n    }\n}\nexports["default"] = PositioningComponent;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/Positioning.ts?')},"./src/Implementations/Components/Quadruple/MultOperation.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst SimpleOperation_1 = __importDefault(__webpack_require__(/*! ./SimpleOperation */ "./src/Implementations/Components/Quadruple/SimpleOperation.ts"));\nclass MultOperation extends SimpleOperation_1.default {\n    constructor() {\n        super();\n        this.operator = \'*\';\n    }\n    clone() {\n        const newAddOperationInstance = new MultOperation();\n        newAddOperationInstance.assigningTo = this.assigningTo;\n        newAddOperationInstance.elements[0] = this.OPERAND1;\n        newAddOperationInstance.elements[1] = this.OPERAND2;\n        return newAddOperationInstance;\n    }\n}\nexports["default"] = MultOperation;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/Quadruple/MultOperation.ts?')},"./src/Implementations/Components/Quadruple/Quadruple.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuadrupletElement = exports.extractQuadruplet = void 0;\nconst Composition_1 = __importDefault(__webpack_require__(/*! ../Composition */ \"./src/Implementations/Components/Composition.ts\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"uuid\");\nconst TemporalComponent_1 = __importDefault(__webpack_require__(/*! ../TemporalComponent */ \"./src/Implementations/Components/TemporalComponent.ts\"));\nfunction extractQuadruplet(inComponent) {\n    if (!inComponent)\n        return null;\n    return inComponent.getComponent({ componentType: QuadrupletElement.Type });\n}\nexports.extractQuadruplet = extractQuadruplet;\nclass QuadrupletElement extends Composition_1.default {\n    static Name = 'QuadrupletElement';\n    static Type = 'QuadrupletElement';\n    id;\n    operator;\n    temporal;\n    elements;\n    constructor() {\n        super();\n        this.componentType = QuadrupletElement.Type;\n        this.id = (0, uuid_1.v4)();\n        this.operator = null;\n        this.elements = [null, null];\n        this.temporal = new TemporalComponent_1.default();\n    }\n    ID = () => this.id;\n    toString() {\n        return `<${this.id}> = ${this.elements[0]} ${this.operator ?? ''} ${this.elements[1] ?? ''}`.trim() + ';';\n    }\n    getTemporal = () => this.temporal;\n}\nexports.QuadrupletElement = QuadrupletElement;\nclass Quadruplet extends Composition_1.default {\n    static Name = 'Quadruplet';\n    static Type = 'QuadrupletComponent';\n    _elements;\n    constructor() {\n        super();\n        this._elements = [];\n        this.componentName = Quadruplet.Name;\n        this.componentType = Quadruplet.Type;\n    }\n    copyElements() {\n        return this._elements.map((el) => el.copy());\n    }\n    add(...quadruples) {\n        this._elements.push(...quadruples);\n    }\n    merge(...components) {\n        for (const component of components) {\n            const tripletComponent = extractQuadruplet(component);\n            if (!tripletComponent)\n                continue;\n            this._elements.push(tripletComponent);\n        }\n    }\n    toString() {\n        const stringResults = [];\n        for (const triple of this._elements) {\n            stringResults.push(triple.toString());\n        }\n        return stringResults.join('\\n');\n    }\n    printTable() {\n        const stringResults = [];\n        for (const triple of this._elements) {\n            const [operator, Operand1, Operand2] = triple.getTuple();\n            stringResults.push({ operator, Operand1: Operand1?.toString(), Operand2: Operand2?.toString() });\n        }\n        console.table(stringResults);\n    }\n    clone() {\n        throw new Error(\"Can't clone a triplet\");\n    }\n}\nexports[\"default\"] = Quadruplet;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/Quadruple/Quadruple.ts?")},"./src/Implementations/Components/Quadruple/SimpleAssignment.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Quadruple_1 = __webpack_require__(/*! ./Quadruple */ "./src/Implementations/Components/Quadruple/Quadruple.ts");\nclass SimpleAssignment extends Quadruple_1.QuadrupletElement {\n    constructor() {\n        super();\n        this.operator = \'=\';\n    }\n    getValue() {\n        return this.elements[1];\n    }\n    setValue(newVal) {\n        this.elements[1] = newVal;\n    }\n    getAssigningTo() {\n        return this.elements[0] ?? this.getTemporal();\n    }\n    setAssigningTo(assigningTo) {\n        this.elements[0] = assigningTo;\n    }\n    getTuple() {\n        return [this.operator, this.getTemporal(), this.getValue()];\n    }\n    toString() {\n        return `SimpleAssignment{ ${this.getValue()} }`;\n    }\n    clone() {\n        const newSimpleAssigment = new SimpleAssignment();\n        const [assigned, _operator, value] = this.getTuple();\n        newSimpleAssigment.elements = [assigned, value];\n        return newSimpleAssigment;\n    }\n    toCode() {\n        if (process.env.DEBUG) {\n            return `AddOperation{ OPERAND1{ ${this.getAssigningTo().toString()} }, OPERAND2{ ${this.getValue().toString()} } }`;\n        }\n        const val = this.getValue();\n        const value = val.getTemporal?.() ?? val.toCode?.() ?? val.toString?.();\n        return `${this.getAssigningTo().toCode()} ${this.operator} ${value}`;\n    }\n}\nexports["default"] = SimpleAssignment;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/Quadruple/SimpleAssignment.ts?')},"./src/Implementations/Components/Quadruple/SimpleHolder.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Quadruple_1 = __webpack_require__(/*! ./Quadruple */ "./src/Implementations/Components/Quadruple/Quadruple.ts");\nclass SimpleHolder extends Quadruple_1.QuadrupletElement {\n    constructor() {\n        super();\n        this.operator = \'=\';\n    }\n    getTuple() {\n        return [this.operator, this.elements[0], undefined, this.getTemporal()];\n    }\n    clone() {\n        const newSimpleHolder = new SimpleHolder();\n        newSimpleHolder.elements = [...this.elements];\n        return newSimpleHolder;\n    }\n    setValue(newValue) {\n        this.elements[0] = newValue;\n    }\n    toString() {\n        return `SimpleHolder{ ${this.elements[0].memoryAddress?.() ?? this.elements[0].toString()} }`;\n    }\n    toCode() {\n        return `${this.getTemporal()} ${this.operator} ${this.elements[0]}`;\n    }\n}\nexports["default"] = SimpleHolder;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/Quadruple/SimpleHolder.ts?')},"./src/Implementations/Components/Quadruple/SimpleOperation.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst index_1 = __webpack_require__(/*! ../index */ "./src/Implementations/Components/index.ts");\nclass SimpleOperation extends index_1.QuadrupletElement {\n    assigningTo;\n    constructor() {\n        super();\n    }\n    OPERAND1 = () => this.elements[0];\n    OPERAND2 = () => this.elements[1];\n    getTuple() {\n        return [this.operator, this.OPERAND1(), this.OPERAND2];\n    }\n    toCode() {\n        const operand1 = this.OPERAND1();\n        const operand2 = this.OPERAND2();\n        const operand1Val = operand1?.getTemporal?.() ?? operand1?.toCode?.() ?? operand1?.toString?.();\n        const operand2Val = operand2?.getTemporal?.() ?? operand2?.toCode?.() ?? operand2?.toString?.();\n        return `${this.getTemporal()} = ${operand1Val} ${this.operator} ${operand2Val}`;\n    }\n}\nexports["default"] = SimpleOperation;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/Quadruple/SimpleOperation.ts?')},"./src/Implementations/Components/Quadruple/SubOperation.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst SimpleOperation_1 = __importDefault(__webpack_require__(/*! ./SimpleOperation */ "./src/Implementations/Components/Quadruple/SimpleOperation.ts"));\nclass SubOperation extends SimpleOperation_1.default {\n    constructor() {\n        super();\n        this.operator = \'-\';\n    }\n    clone() {\n        const newAddOperationInstance = new SubOperation();\n        newAddOperationInstance.assigningTo = this.assigningTo;\n        newAddOperationInstance.elements[0] = this.OPERAND1;\n        newAddOperationInstance.elements[1] = this.OPERAND2;\n        return newAddOperationInstance;\n    }\n}\nexports["default"] = SubOperation;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/Quadruple/SubOperation.ts?')},"./src/Implementations/Components/Table.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.replaceTableComponent = exports.extractTableComponent = void 0;\nconst BasicInformation_1 = __importStar(__webpack_require__(/*! ./BasicInformation */ "./src/Implementations/Components/BasicInformation.ts"));\nconst Composition_1 = __importDefault(__webpack_require__(/*! ./Composition */ "./src/Implementations/Components/Composition.ts"));\nfunction extractTableComponent(inComponent) {\n    if (!inComponent)\n        return null;\n    return inComponent.getComponent({ componentType: TableComponent.Type });\n}\nexports.extractTableComponent = extractTableComponent;\nfunction replaceTableComponent(inComponent) {\n    if (!inComponent)\n        return null;\n    return inComponent.replaceComponent(inComponent);\n}\nexports.replaceTableComponent = replaceTableComponent;\nclass TableComponent extends Composition_1.default {\n    static Name = \'Table\';\n    static Type = \'Table\';\n    parent;\n    elements;\n    constructor(options) {\n        super();\n        this.componentName = TableComponent.Name;\n        this.componentType = TableComponent.Type;\n        this.elements = [];\n        this.parent = options?.parent ?? null;\n    }\n    /**\n     * Looks up a value in the table\n     * @param key The name of the value in the symbols table\n     * @param options\n     * @returns The symbol or null\n     */\n    get(p_key, options) {\n        const key = p_key.toString();\n        const foundComponent = this.elements.find((element) => {\n            const basicInfo = element.getComponent({\n                componentType: BasicInformation_1.default.Type,\n            });\n            return basicInfo?.getName() === key;\n        });\n        if (options?.inCurrentScope) {\n            return foundComponent ?? null;\n        }\n        return (foundComponent ?? this.parent?.get(key) ?? null);\n    }\n    getAll(inScope = true) {\n        if (inScope)\n            return [...this.elements];\n        const parentElements = this.parent?.getAll(inScope) ?? [];\n        const thisElements = [...this.elements];\n        const elements = [...thisElements];\n        for (const element of parentElements) {\n            const basicInfo = (0, BasicInformation_1.extractBasicInformation)(element);\n            if (elements.find((element) => (0, BasicInformation_1.extractBasicInformation)(element).getName() === basicInfo.getName())) {\n                continue;\n            }\n            elements.push(element);\n        }\n        return elements;\n    }\n    filter(by) {\n        return this.getAll(false).filter((t) => t.componentName === by);\n    }\n    /**\n     * Adds new values to the table\n     * @param values\n     */\n    add(...values) {\n        for (const value of values) {\n            this.elements.push(value);\n        }\n    }\n    clone() {\n        const newTable = new TableComponent({ parent: this.parent });\n        for (const element of this.elements) {\n            newTable.add(element.copy());\n        }\n        return newTable;\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.elements.length) {\n                    return {\n                        value: this.elements[index++],\n                        done: false,\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true,\n                };\n            },\n        };\n    }\n}\nexports["default"] = TableComponent;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/Table.ts?')},"./src/Implementations/Components/TemporalComponent.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.isTemporalComponent = void 0;\nconst Composition_1 = __importDefault(__webpack_require__(/*! ./Composition */ "./src/Implementations/Components/Composition.ts"));\nfunction isTemporalComponent(component) {\n    return component?.componentType === \'TemporalComponent\';\n}\nexports.isTemporalComponent = isTemporalComponent;\nclass TemporalComponent extends Composition_1.default {\n    referencedElement;\n    constructor(references) {\n        super();\n        this.referencedElement = references;\n        this.componentType = \'TemporalComponent\';\n    }\n    clone() {\n        return new TemporalComponent(this.referencedElement);\n    }\n    toString() {\n        return `TemporalComponent{${this.referencedElement ?? this.id.substring(0, 8)}}`;\n    }\n}\nexports["default"] = TemporalComponent;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/TemporalComponent.ts?')},"./src/Implementations/Components/Type.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TypeComponent = exports.extractTypeComponent = void 0;\nconst Composition_1 = __importDefault(__webpack_require__(/*! ./Composition */ "./src/Implementations/Components/Composition.ts"));\nfunction extractTypeComponent(inComponent) {\n    if (!inComponent)\n        return null;\n    return inComponent.getComponent({ componentType: TypeComponent.Type });\n}\nexports.extractTypeComponent = extractTypeComponent;\n/**\n * A type component is a component that describes a type. It is the main component of a type system.\n */\nclass TypeComponent extends Composition_1.default {\n    static Name = \'Type\';\n    static Type = \'Type\';\n    componentType = TypeComponent.Type;\n    isGeneric;\n    sizeInBytes;\n    parent;\n    allowsNegation;\n    defaultValue;\n    constructor(options) {\n        super();\n        this.componentName = TypeComponent.Name;\n        this.isGeneric = options?.isGeneric ?? false;\n        this.sizeInBytes = options?.sizeInBytes;\n        this.parent = options?.parent ?? null;\n        this.allowsNegation = false;\n        this.defaultValue = null;\n    }\n    getHierarchy = () => {\n        return [...(this.parent?.getHierarchy() ?? []), this];\n    };\n    isAncestorOf = (incomingType) => {\n        const typeComponent = incomingType?.getComponent({ componentType: incomingType?.componentType }, { currentScope: true });\n        if (!typeComponent)\n            return false;\n        return typeComponent.inheritsFrom(this);\n    };\n    inheritsFrom = (incomingType) => {\n        const hierarchyChainNames = this.getHierarchy()\n            .map((t) => t.componentName)\n            .filter((t) => t !== this.componentName);\n        // Don\'t grab only in the current scope because inherited types are allowed\n        const incomingTypeComponent = incomingType?.getComponent({\n            componentType: TypeComponent.Type,\n        })?.componentName;\n        return hierarchyChainNames.includes(incomingTypeComponent ?? \'\');\n    };\n}\nexports.TypeComponent = TypeComponent;\nexports["default"] = TypeComponent;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/Type.ts?')},"./src/Implementations/Components/ValueHolder.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.extractValueComponent = void 0;\nconst Composition_1 = __importDefault(__webpack_require__(/*! ./Composition */ "./src/Implementations/Components/Composition.ts"));\nfunction extractValueComponent(inComponent) {\n    if (!inComponent)\n        return null;\n    return inComponent.getComponent({ componentType: ValueComponent.Type });\n}\nexports.extractValueComponent = extractValueComponent;\nclass ValueComponent extends Composition_1.default {\n    value;\n    static Name = \'ValueHolder\';\n    static Type = \'ValueHolder\';\n    constructor(options) {\n        super();\n        this.componentName = ValueComponent.Name;\n        this.componentType = ValueComponent.Type;\n        this.value = options?.value ?? null;\n    }\n    getValue = () => this.value;\n    setValue = (value) => {\n        this.value = value;\n    };\n    clone() {\n        return new ValueComponent({ value: this.value });\n    }\n}\nexports["default"] = ValueComponent;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/ValueHolder.ts?')},"./src/Implementations/Components/index.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.QuadrupletComponent = exports.EmptyComponent = exports.CompositionComponent = exports.TableComponent = exports.TypeComponent = exports.ValueComponent = exports.PositioningComponent = exports.BasicInfoComponent = void 0;\nvar BasicInformation_1 = __webpack_require__(/*! ./BasicInformation */ "./src/Implementations/Components/BasicInformation.ts");\nObject.defineProperty(exports, "BasicInfoComponent", ({ enumerable: true, get: function () { return __importDefault(BasicInformation_1).default; } }));\nvar Positioning_1 = __webpack_require__(/*! ./Positioning */ "./src/Implementations/Components/Positioning.ts");\nObject.defineProperty(exports, "PositioningComponent", ({ enumerable: true, get: function () { return __importDefault(Positioning_1).default; } }));\nvar ValueHolder_1 = __webpack_require__(/*! ./ValueHolder */ "./src/Implementations/Components/ValueHolder.ts");\nObject.defineProperty(exports, "ValueComponent", ({ enumerable: true, get: function () { return __importDefault(ValueHolder_1).default; } }));\nvar Type_1 = __webpack_require__(/*! ./Type */ "./src/Implementations/Components/Type.ts");\nObject.defineProperty(exports, "TypeComponent", ({ enumerable: true, get: function () { return __importDefault(Type_1).default; } }));\nvar Table_1 = __webpack_require__(/*! ./Table */ "./src/Implementations/Components/Table.ts");\nObject.defineProperty(exports, "TableComponent", ({ enumerable: true, get: function () { return __importDefault(Table_1).default; } }));\nvar Composition_1 = __webpack_require__(/*! ./Composition */ "./src/Implementations/Components/Composition.ts");\nObject.defineProperty(exports, "CompositionComponent", ({ enumerable: true, get: function () { return __importDefault(Composition_1).default; } }));\nvar EmptyComponent_1 = __webpack_require__(/*! ./EmptyComponent */ "./src/Implementations/Components/EmptyComponent.ts");\nObject.defineProperty(exports, "EmptyComponent", ({ enumerable: true, get: function () { return __importDefault(EmptyComponent_1).default; } }));\nvar Quadruple_1 = __webpack_require__(/*! ./Quadruple/Quadruple */ "./src/Implementations/Components/Quadruple/Quadruple.ts");\nObject.defineProperty(exports, "QuadrupletComponent", ({ enumerable: true, get: function () { return __importDefault(Quadruple_1).default; } }));\n__exportStar(__webpack_require__(/*! ./BasicInformation */ "./src/Implementations/Components/BasicInformation.ts"), exports);\n__exportStar(__webpack_require__(/*! ./Positioning */ "./src/Implementations/Components/Positioning.ts"), exports);\n__exportStar(__webpack_require__(/*! ./ValueHolder */ "./src/Implementations/Components/ValueHolder.ts"), exports);\n__exportStar(__webpack_require__(/*! ./Type */ "./src/Implementations/Components/Type.ts"), exports);\n__exportStar(__webpack_require__(/*! ./Table */ "./src/Implementations/Components/Table.ts"), exports);\n__exportStar(__webpack_require__(/*! ./Composition */ "./src/Implementations/Components/Composition.ts"), exports);\n__exportStar(__webpack_require__(/*! ./Quadruple/Quadruple */ "./src/Implementations/Components/Quadruple/Quadruple.ts"), exports);\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Components/index.ts?')},"./src/Implementations/DataStructures/Error.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.lineAndColumn = void 0;\nconst Errors_1 = __webpack_require__(/*! ../Errors/Errors */ "./src/Implementations/Errors/Errors.ts");\nconst lineAndColumn = (ctx) => ({\n    line: ctx.start?.line ?? 0,\n    column: ctx.start?.charPositionInLine ?? 0,\n});\nexports.lineAndColumn = lineAndColumn;\nclass ErrorComponent extends Errors_1.BasicStorage {\n    constructor() {\n        super();\n    }\n    addError(ctx, ...errorMessage) {\n        for (const message of errorMessage) {\n            const line = ctx.start?.line ?? 0;\n            const column = ctx.start?.charPositionInLine ?? 0;\n            this.elements.push({ line, column, message });\n        }\n    }\n}\nexports["default"] = ErrorComponent;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/Error.ts?')},"./src/Implementations/DataStructures/Memory.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MemoryVisitor = void 0;\nconst AbstractParseTreeVisitor_1 = __webpack_require__(/*! antlr4ts/tree/AbstractParseTreeVisitor */ \"antlr4ts/tree/AbstractParseTreeVisitor\");\nconst Table_1 = __importStar(__webpack_require__(/*! ../Components/Table */ \"./src/Implementations/Components/Table.ts\"));\nconst MemoryVisitors_1 = __webpack_require__(/*! ./MemoryVisitors */ \"./src/Implementations/DataStructures/MemoryVisitors/index.ts\");\nconst add_1 = __importDefault(__webpack_require__(/*! ./MemoryVisitors/add */ \"./src/Implementations/DataStructures/MemoryVisitors/add.ts\"));\nconst Jumps_1 = __webpack_require__(/*! ./MemoryVisitors/Instructions/Jumps */ \"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Jumps.ts\");\nconst MemoryManagement_1 = __webpack_require__(/*! ./MemoryVisitors/Instructions/MemoryManagement */ \"./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts\");\nconst Misc_1 = __webpack_require__(/*! ./MemoryVisitors/Instructions/Misc */ \"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Misc.ts\");\nconst Operation_1 = __webpack_require__(/*! ./MemoryVisitors/Instructions/Operation */ \"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Operation.ts\");\nconst TemporaryValues_1 = __webpack_require__(/*! ./MemoryVisitors/TemporaryValues */ \"./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts\");\nclass MemoryVisitor extends AbstractParseTreeVisitor_1.AbstractParseTreeVisitor {\n    static Name = 'MemoryComponent';\n    static Type = 'MemoryComponent';\n    symbolsTable;\n    mainMethodBranch;\n    mainClassSymbolsTable;\n    memorySymbolsTable;\n    memoryOffset = 0;\n    memoryStack = [];\n    classStack = [];\n    // TODO: Add a table scope\n    /** Holds the memory elements */\n    constructor(symbolsTable, mainMethodBranch) {\n        super();\n        this.symbolsTable = symbolsTable;\n        this.mainClassSymbolsTable = (0, Table_1.extractTableComponent)(this.symbolsTable.get('Main'));\n        this.mainMethodBranch = mainMethodBranch;\n        this.memorySymbolsTable = new Table_1.default();\n        this.classStack.push(this.symbolsTable.get('Main'));\n    }\n    currentClass = (offset = 0) => this.classStack.at(offset - 1);\n    currentClassTable = (offset = 0) => (0, Table_1.extractTableComponent)(this.currentClass(offset));\n    findInStack(value) {\n        const stack = [...this.classStack].reverse();\n        for (const element of stack) {\n            const table = (0, Table_1.extractTableComponent)(element);\n            if (table) {\n                const symbol = table.get(value);\n                if (symbol) {\n                    return symbol;\n                }\n            }\n        }\n        return null;\n    }\n    register = (id, size) => {\n        const toPush = [id, this.memoryOffset, size];\n        this.memoryStack.push(toPush);\n        this.memoryOffset += size;\n        return toPush;\n    };\n    defaultResult() {\n        return [];\n    }\n    writeReturn(value) {\n        this.addQuadruple(new MemoryManagement_1.Move({ dataMovesFrom: value, dataMovesInto: new TemporaryValues_1.V0() }));\n        this.addQuadruple(new Misc_1.Return());\n    }\n    saveToStack(size) {\n        if (size <= 0)\n            return;\n        this.addQuadruple(new Operation_1.Sub({\n            saveIn: new TemporaryValues_1.STACK_POINTER(),\n            operand1: new TemporaryValues_1.STACK_POINTER(),\n            operand2: size,\n            comment: 'Add to stack',\n        }));\n        this.stackMemoryOffset -= size;\n    }\n    removeFromStack(size) {\n        if (size <= 0)\n            return;\n        this.stackMemoryOffset += size;\n        this.addQuadruple(new Operation_1.Add({\n            saveIn: new TemporaryValues_1.STACK_POINTER(),\n            operand1: new TemporaryValues_1.STACK_POINTER(),\n            operand2: size.toString(16),\n            comment: 'Remove from stack',\n        }));\n    }\n    aggregateResult(aggregate, nextResult) {\n        if (Array.isArray(nextResult)) {\n            return [...(aggregate ?? []), ...(nextResult ?? [])];\n        }\n        return [...aggregate, nextResult];\n    }\n    startCall() {\n        [\n            new Operation_1.Sub({\n                saveIn: new TemporaryValues_1.STACK_POINTER(),\n                operand1: new TemporaryValues_1.STACK_POINTER(),\n                operand2: 4,\n                comment: 'Add to stack to save values',\n            }),\n            new MemoryManagement_1.StoreWord({\n                dataMovesFrom: new TemporaryValues_1.JUMP_LINK_REGISTER(),\n                dataMovesInto: new TemporaryValues_1.STACK_POINTER(),\n                offset: -4,\n                comment: 'Save the return address',\n            }),\n        ].forEach((instruction) => this.addQuadruple(instruction));\n    }\n    endCall() {\n        [\n            new MemoryManagement_1.LoadWord({\n                dataMovesInto: new TemporaryValues_1.JUMP_LINK_REGISTER(),\n                dataMovesFrom: new TemporaryValues_1.STACK_POINTER(),\n                offset: -4,\n                comment: 'Load the return address back from the stack',\n            }),\n            new Operation_1.Add({\n                saveIn: new TemporaryValues_1.STACK_POINTER(),\n                operand1: new TemporaryValues_1.STACK_POINTER(),\n                operand2: '4',\n                comment: 'Restore the stack pointer',\n            }),\n        ].forEach((instruction) => this.addQuadruple(instruction));\n    }\n    AskForHeapMemory(size) {\n        [\n            new MemoryManagement_1.Move({\n                dataMovesInto: new TemporaryValues_1.V0(),\n                dataMovesFrom: new TemporaryValues_1.ALLOCATE(),\n                comment: `The value of ${new TemporaryValues_1.ALLOCATE()} calls for memory allocation in the heap`,\n            }),\n            new MemoryManagement_1.Move({\n                dataMovesInto: new TemporaryValues_1.FUNCTION_PARAMETER_1(),\n                dataMovesFrom: size.toString(10),\n                comment: `Ask for ${size} bytes of memory`,\n            }),\n            new Misc_1.SysCall(),\n        ].forEach((instruction) => this.addQuadruple(instruction));\n    }\n    AskForStackMemory(size) {\n        if (size <= 0)\n            return;\n        [\n            new Operation_1.Sub({\n                saveIn: new TemporaryValues_1.STACK_POINTER(),\n                operand1: new TemporaryValues_1.STACK_POINTER(),\n                operand2: size,\n                comment: `Ask for ${size} bytes of memory from the stack`,\n            }),\n        ].forEach((instruction) => this.addQuadruple(instruction));\n        this.stackMemoryOffset -= size;\n    }\n    LiberateStackMemory(size) {\n        if (size <= 0)\n            return;\n        [\n            new Operation_1.Add({\n                saveIn: new TemporaryValues_1.STACK_POINTER(),\n                operand1: new TemporaryValues_1.STACK_POINTER(),\n                operand2: size,\n                comment: `Liberate ${size} bytes of memory from the stack`,\n            }),\n        ].forEach((instruction) => this.addQuadruple(instruction));\n        this.stackMemoryOffset += size;\n    }\n    end = () => {\n        const end = 'end';\n        [\n            new Jumps_1.UnconditionalJump(end),\n            new Misc_1.MethodDeclaration(end),\n            new MemoryManagement_1.LoadWord({\n                dataMovesInto: new TemporaryValues_1.V0(),\n                dataMovesFrom: new TemporaryValues_1.EXIT(),\n                comment: 'Exit the program',\n            }),\n            new Misc_1.SysCall(),\n        ].forEach((quadruple) => this.addQuadruple(quadruple));\n    };\n    getQuadruples() {\n        let output = '';\n        for (const key of Object.keys(this.methods)) {\n            output +=\n                this.methods[key]\n                    .map((t) => t.toString())\n                    .join('\\n')\n                    .toString() + '\\n';\n        }\n        return output;\n    }\n    getTuples(asString = false) {\n        let output = [];\n        for (const key of Object.keys(this.methods)) {\n            output.push(...this.methods[key].map((t) => t.toTuple(asString)));\n        }\n        return output;\n    }\n    instantiate(ctx = this.mainMethodBranch) {\n        this.addQuadruple(new Misc_1.TextHolder('.data'), new Misc_1.TextHolder('.program_start:\\t\\t.word\\t\\t0'), new Misc_1.TextHolder('.text'), new Misc_1.TextHolder('main:\\t\\t#\\tEntry point of the program'));\n        const result = this.visit(ctx).at(-1);\n        // const returnValue = result?.getTemporal();\n        this.scopes = ['main'];\n        this.startCall();\n        this.addQuadruple(new Jumps_1.LinkedJump('Main::main()'));\n        this.endCall();\n        // console.log(this.getQuadruples());\n        // console.log('done');\n    }\n    visitAssignmentExpr = (ctx) => {\n        return (0, MemoryVisitors_1.visitAssignmentExpr)(this, ctx);\n    };\n    visitBlock = (ctx) => {\n        return (0, MemoryVisitors_1.visitBlock)(this, ctx);\n    };\n    visitDivision = (ctx) => {\n        return (0, MemoryVisitors_1.visitDivision)(this, ctx);\n    };\n    visitEqual = (ctx) => {\n        return (0, MemoryVisitors_1.visitEqual)(this, ctx);\n    };\n    visitLessEqual = (ctx) => {\n        return (0, MemoryVisitors_1.visitLessEqual)(this, ctx);\n    };\n    visitLessThan = (ctx) => {\n        return (0, MemoryVisitors_1.visitLessThan)(this, ctx);\n    };\n    visitFalse = (ctx) => {\n        return (0, MemoryVisitors_1.visitFalse)(this, ctx);\n    };\n    visitId = (ctx) => {\n        return (0, MemoryVisitors_1.visitId)(this, ctx);\n    };\n    visitString = (ctx) => {\n        return (0, MemoryVisitors_1.visitString)(this, ctx);\n    };\n    visitIf = (ctx) => {\n        return (0, MemoryVisitors_1.visitIf)(this, ctx);\n    };\n    scopes = ['main'];\n    addQuadruple = (...quadruple) => {\n        const name = this.scopes.at(-1);\n        if (!this.methods[name]) {\n            this.methods[name] = [];\n        }\n        this.methods[name].push(...quadruple);\n    };\n    pushScope = (scope) => {\n        this.scopes.push(scope);\n    };\n    popScope = () => {\n        this.scopes.pop();\n    };\n    methods = {};\n    stackMemoryOffset = 0;\n    visitFormal = (ctx) => {\n        return (0, MemoryVisitors_1.visitFormal)(this, ctx);\n    };\n    visitProperty = (ctx) => {\n        return (0, MemoryVisitors_1.visitProperty)(this, ctx);\n    };\n    visitAdd = (ctx) => {\n        return (0, add_1.default)(this, ctx);\n    };\n    visitAssignment = (ctx) => {\n        return (0, MemoryVisitors_1.visitAssignment)(this, ctx);\n    };\n    visitMethodCall = (ctx) => {\n        return (0, MemoryVisitors_1.visitMethodCall)(this, ctx);\n    };\n    visitMinus = (ctx) => {\n        return (0, MemoryVisitors_1.visitMinus)(this, ctx);\n    };\n    visitNegative = (ctx) => {\n        return (0, MemoryVisitors_1.visitNegative)(this, ctx);\n    };\n    visitOwnMethodCall = (ctx) => {\n        return (0, MemoryVisitors_1.visitOwnMethodCall)(this, ctx);\n    };\n    visitWhile = (ctx) => {\n        return (0, MemoryVisitors_1.visitWhile)(this, ctx);\n    };\n    visitMultiply = (ctx) => {\n        return (0, MemoryVisitors_1.visitMultiply)(this, ctx);\n    };\n    visitInt = (ctx) => {\n        return (0, MemoryVisitors_1.visitInt)(this, ctx);\n    };\n    visitLetIn = (ctx) => {\n        return (0, MemoryVisitors_1.visitLetIn)(this, ctx);\n    };\n    visitTrue = (ctx) => {\n        return (0, MemoryVisitors_1.visitTrue)(this, ctx);\n    };\n    visitNew = (ctx) => {\n        return (0, MemoryVisitors_1.visitNew)(this, ctx);\n    };\n    visitMethod = (ctx) => {\n        return (0, MemoryVisitors_1.visitMethod)(this, ctx);\n    };\n}\nexports.MemoryVisitor = MemoryVisitor;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/Memory.ts?")},"./src/Implementations/DataStructures/MemoryVisitors/Instructions/BasicOperation.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst TemporaryValues_1 = __webpack_require__(/*! ../TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction basicOperation(visitor, ctx) {\n    const [leftChild, rightChild] = ctx.expression();\n    const [leftChildResult] = visitor.visit(leftChild);\n    const [rightChildResult] = visitor.visit(rightChild);\n    const leftChildTemporal = leftChildResult.getTemporal();\n    const rightChildTemporal = rightChildResult.getTemporal();\n    const temporal = new TemporaryValues_1.TemporalValue();\n    return [leftChildTemporal, rightChildTemporal, temporal];\n}\nexports["default"] = basicOperation;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/Instructions/BasicOperation.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Bitwise.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NOT = void 0;\nconst Quadruple_1 = __importDefault(__webpack_require__(/*! ./Quadruple */ \"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Quadruple.ts\"));\nclass NOT extends Quadruple_1.default {\n    operator = '~';\n    operatorVerbose = 'NOT';\n    constructor(options) {\n        const { saveIn: dest, toNegate: src1, comment } = options;\n        super({ dest, src1, comment });\n    }\n    toMIPS() {\n        return `\\t\\t${this.operatorVerbose} ${this.DESTINATION()}, ${this.OPERAND1()}`;\n    }\n    toString() {\n        return `\\t\\t${this.DESTINATION()} = ${this.operator}${this.OPERAND1()}`;\n    }\n    calculateComment() {\n        return '';\n    }\n}\nexports.NOT = NOT;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/Instructions/Bitwise.ts?")},"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Comparison.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LESSTHAN = exports.LESSEQUAL = exports.EQUAL = void 0;\nconst Quadruple_1 = __importDefault(__webpack_require__(/*! ./Quadruple */ \"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Quadruple.ts\"));\nclass COMPARISON extends Quadruple_1.default {\n    constructor(options) {\n        const { fistOperand: src1, secondOperand: src2, comment, goTo: dest } = options;\n        super({ src1, src2, dest, comment });\n    }\n    toMIPS() {\n        return `\\t\\t${this.operatorVerbose}, ${this.OPERAND1()}, ${this.OPERAND2()}, ${this.DESTINATION()}`;\n    }\n    toString() {\n        return `\\t\\tif (${this.OPERAND1()} ${this.OPERAND()} ${this.OPERAND2()}) goto ${this.DESTINATION()}`;\n    }\n}\nclass EQUAL extends COMPARISON {\n    operator = '==';\n    operatorVerbose = 'beq';\n    calculateComment() {\n        return '';\n    }\n}\nexports.EQUAL = EQUAL;\nclass LESSEQUAL extends COMPARISON {\n    operator = '<=';\n    operatorVerbose = 'ble';\n    calculateComment() {\n        return '';\n    }\n}\nexports.LESSEQUAL = LESSEQUAL;\nclass LESSTHAN extends COMPARISON {\n    operator = '<';\n    operatorVerbose = 'blt';\n    calculateComment() {\n        return '';\n    }\n}\nexports.LESSTHAN = LESSTHAN;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/Instructions/Comparison.ts?")},"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Jumps.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LinkedJump = exports.UnconditionalJump = void 0;\nconst Quadruple_1 = __importDefault(__webpack_require__(/*! ./Quadruple */ \"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Quadruple.ts\"));\nclass UnconditionalJump extends Quadruple_1.default {\n    operator = '';\n    operatorVerbose = 'j';\n    constructor(towards) {\n        super({ src1: towards });\n    }\n    calculateComment() {\n        this.comment = 'Inconditional jump';\n        return this.comment;\n    }\n    toMIPS() {\n        return this.withComment(`\\t\\t${this.operatorVerbose}\\t${this.OPERAND1()}`);\n    }\n    toString() {\n        return this.withComment(`\\t\\t${this.operatorVerbose}\\t${this.OPERAND1()}`);\n    }\n    toTuple(asString = false) {\n        if (asString) {\n            return ['', `${this.operatorVerbose} ${this.OPERAND1()?.toString()}`, null, null];\n        }\n        return ['', `${this.operatorVerbose} ${this.OPERAND1()}`, null, null];\n    }\n}\nexports.UnconditionalJump = UnconditionalJump;\nclass LinkedJump extends Quadruple_1.default {\n    operator = '';\n    operatorVerbose = 'jal';\n    constructor(towards, comment) {\n        super({ src1: towards, comment });\n    }\n    calculateComment() {\n        this.comment = 'Jump with link';\n        return this.comment;\n    }\n    toMIPS() {\n        return this.withComment(`\\t\\t${this.operatorVerbose}\\t${this.OPERAND1()}`);\n    }\n    toString() {\n        return this.withComment(`\\t\\t${this.operatorVerbose}\\t${this.OPERAND1()}`);\n    }\n    toTuple(asString = false) {\n        return ['', `${this.operatorVerbose} ${this.OPERAND1()}`, null, null];\n    }\n}\nexports.LinkedJump = LinkedJump;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/Instructions/Jumps.ts?")},"./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Move = exports.LoadWord = exports.StoreWord = exports.MemoryManagement = exports.MemoryAddress = void 0;\nconst Composition_1 = __importDefault(__webpack_require__(/*! ../../../Components/Composition */ \"./src/Implementations/Components/Composition.ts\"));\nconst Quadruple_1 = __importDefault(__webpack_require__(/*! ./Quadruple */ \"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Quadruple.ts\"));\nclass MemoryAddress extends Composition_1.default {\n    static Name = 'Memory';\n    static Type = 'Memory';\n    address;\n    prepender = '';\n    constructor(address) {\n        super();\n        this.componentName = MemoryAddress.Name;\n        this.componentType = MemoryAddress.Type;\n        if (typeof address === 'number' || (typeof address === 'string' && !isNaN(parseInt(address)))) {\n            this.address = address.toString(16);\n            this.prepender = '0x';\n        }\n        else if (typeof address === 'string') {\n            this.address = address;\n        }\n        else {\n            this.address = address.toString();\n        }\n    }\n    clone() {\n        return new MemoryAddress(this.address);\n    }\n    toString = () => {\n        // if (offset) {\n        // return `${this.componentName}[${this.prepender}${this.address} + ${offset.toString(16)}]`;\n        // }\n        return `${this.componentName}[${this.prepender}${this.address}]`;\n    };\n}\nexports.MemoryAddress = MemoryAddress;\n/**\n * Basic memory management class\n */\nclass MemoryManagement extends Quadruple_1.default {\n    operator = '<-';\n    operatorVerbose = 'move';\n    offset;\n    constructor(options) {\n        const { dataMovesInto: dest, dataMovesFrom: src1, comment } = options;\n        super({ dest, src1, comment });\n        this.offset = options.offset ?? 0;\n    }\n    toMIPS() {\n        throw new Error('Method not implemented.');\n    }\n    toString() {\n        throw new Error('Method not implemented.');\n    }\n    calculateComment() {\n        throw new Error('Method not implemented.');\n    }\n}\nexports.MemoryManagement = MemoryManagement;\n/**\n * Copy from register to memory\n * @example\n * sw $1, 100($2) // Memory[$2 + 100] = $1\n */\nclass StoreWord extends MemoryManagement {\n    operator = '=';\n    operatorVerbose = 'sw';\n    getOffsetString = () => (this.offset ? `(${this.offset})` : '');\n    calculateComment() {\n        const first = this.OPERAND1();\n        const temporal = this.DESTINATION();\n        this.comment = `Saving value ${first} to memory address in ${temporal}${this.getOffsetString?.() || 0}`;\n        return this.comment;\n    }\n    toMIPS() {\n        const offset = this.offset ? `${this.offset}` : '';\n        return this.withComment(`\\t\\t${this.operatorVerbose}\\t${this.OPERAND1()}, ${offset}(${this.DESTINATION()})`);\n    }\n    toString() {\n        const operand = this.OPERAND1();\n        const immediate = this.isImmediate(operand);\n        const offset = this.offset ? ` + ${this.offset}` : '';\n        if (immediate) {\n            return this.withComment(`\\t\\tMemory[${this.DESTINATION()}${offset}] = ${operand}`);\n        }\n        return this.withComment(`\\t\\tMemory[${this.DESTINATION()}${offset}] = ${operand}`);\n    }\n    toTuple(asString = false) {\n        if (asString) {\n            return ['=', this.OPERAND1().toString(), null, `Memory[${this.DESTINATION()?.toString()}]`];\n        }\n        return ['=', this.OPERAND1(), null, `Memory[${this.DESTINATION()}]`];\n    }\n}\nexports.StoreWord = StoreWord;\n/**\n * Copy from memory to register\n * @example\n * lw $1, 100($2) // $1 = Memory[$2 + 100]\n */\nclass LoadWord extends MemoryManagement {\n    operator = '=';\n    operatorVerbose = 'lw';\n    setOperatorVerbose() {\n        this.operatorVerbose = this.immediateAppend(this.src1, this.operatorVerbose);\n    }\n    calculateComment() {\n        const first = this.OPERAND1();\n        const temporal = this.DESTINATION();\n        const immediate = this.immediateAppend(first, '', true);\n        this.comment = `Loading ${immediate}value ${first} into ${temporal}`;\n        return this.comment;\n    }\n    toMIPS() {\n        const immediate = this.immediateAppend(this.src1, '') ? 'li' : 'lw';\n        const offset = this.offset ? `${this.offset}` : '';\n        const operand = immediate ? this.OPERAND1() : `(${this.OPERAND1()})`;\n        return this.withComment(`\\t\\t${immediate}\\t${this.DESTINATION()}, ${offset}${operand}`);\n    }\n    toString() {\n        const offset = this.offset ? ` + ${this.offset}` : '';\n        const operand = this.OPERAND1();\n        const immediate = this.immediateAppend(operand, '');\n        if (immediate) {\n            return this.withComment(`\\t\\t${this.DESTINATION()} = ${operand.toString(16)}${offset}`);\n        }\n        return this.withComment(`\\t\\t${this.DESTINATION()} = Memory[${this.OPERAND1().toString(16)}${offset}]`);\n    }\n    toTuple(asString = false) {\n        if (asString) {\n            return ['=', this.DESTINATION().toString(), null, this.OPERAND1().toString()];\n        }\n        return ['=', this.DESTINATION(), null, this.OPERAND1()];\n    }\n}\nexports.LoadWord = LoadWord;\n/**\n * Moves data from one register to another\n * @example\n * move $1, $2 // $1 = $2\n *\n * @warning\n * This is a pseudo instruction given by assembly, it is not a real instruction\n */\nclass Move extends MemoryManagement {\n    operator = '=';\n    operatorVerbose = 'move';\n    calculateComment() {\n        const first = this.OPERAND1();\n        const temporal = this.DESTINATION();\n        this.comment = `Moving value from ${first} into ${temporal}`;\n        return this.comment;\n    }\n    toMIPS() {\n        return this.withComment(`\\t\\t${this.operatorVerbose}\\t${this.DESTINATION()}, ${this.OPERAND1()}`);\n    }\n    toString() {\n        const offset = this.offset ? ` + ${this.offset}` : '';\n        const operand = this.OPERAND1();\n        const immediate = this.immediateAppend(operand, '');\n        if (immediate) {\n            return this.withComment(`\\t\\t${this.DESTINATION()} = ${this.OPERAND1()}${offset}`);\n        }\n        return this.withComment(`\\t\\t${this.DESTINATION()} = ${this.OPERAND1()}${offset}`);\n    }\n    toTuple(asString = false) {\n        if (asString) {\n            return ['=', this.OPERAND1().toString(), null, this.DESTINATION().toString()];\n        }\n        return ['=', this.OPERAND1(), null, this.DESTINATION()];\n    }\n}\nexports.Move = Move;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts?")},"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Misc.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Comment = exports.TextHolder = exports.MethodDeclaration = exports.SysCall = exports.Return = void 0;\nconst TemporaryValues_1 = __webpack_require__(/*! ../TemporaryValues */ \"./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts\");\nconst Quadruple_1 = __importDefault(__webpack_require__(/*! ./Quadruple */ \"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Quadruple.ts\"));\nclass Return extends Quadruple_1.default {\n    operator = '';\n    operatorVerbose = 'return';\n    calculateComment() {\n        this.comment = 'return';\n        return this.comment;\n    }\n    toMIPS() {\n        return this.withComment(`\\t\\t${new TemporaryValues_1.JUMP_BACK()}\\t${new TemporaryValues_1.JUMP_LINK_REGISTER()}`);\n    }\n    toString() {\n        return this.withComment(`\\t\\t${this.operatorVerbose}`);\n    }\n    toTuple() {\n        return ['', this.operatorVerbose, null, null];\n    }\n}\nexports.Return = Return;\nclass SysCall extends Quadruple_1.default {\n    operator = '';\n    operatorVerbose = 'syscall';\n    constructor() {\n        super();\n    }\n    calculateComment() {\n        this.comment = 'Call for the system';\n        return this.comment;\n    }\n    toMIPS() {\n        return this.withComment('\\t\\t' + this.operatorVerbose);\n    }\n    toString() {\n        return this.withComment(`\\t\\t${this.operatorVerbose}`);\n    }\n    toTuple() {\n        return ['', this.operatorVerbose, null, null];\n    }\n}\nexports.SysCall = SysCall;\nclass MethodDeclaration extends Quadruple_1.default {\n    operator = '';\n    operatorVerbose = '';\n    constructor(name, comment) {\n        super({ src1: name, comment });\n    }\n    calculateComment() {\n        // this.comment = 'Method declaration for ' + this.OPERAND1() + '\\n';\n        this.comment = '';\n        return this.comment;\n    }\n    toMIPS() {\n        return this.withComment(`${this.OPERAND1()}:`);\n    }\n    toString() {\n        return this.withComment(`${this.OPERAND1()}:`);\n    }\n    toTuple() {\n        return ['', `${this.operatorVerbose} ${this.OPERAND1()}`, null, null];\n    }\n}\nexports.MethodDeclaration = MethodDeclaration;\nclass TextHolder extends Quadruple_1.default {\n    operator = '';\n    operatorVerbose = '';\n    constructor(contents, comment) {\n        super({ src1: contents, comment });\n    }\n    calculateComment() {\n        return '';\n    }\n    toMIPS() {\n        return this.withComment(`${this.OPERAND1()}`);\n    }\n    toString() {\n        return this.withComment(`${this.OPERAND1()}`);\n    }\n    toTuple() {\n        return ['', this.OPERAND1(), null, null];\n    }\n}\nexports.TextHolder = TextHolder;\nclass Comment extends Quadruple_1.default {\n    operator = '';\n    operatorVerbose = '';\n    constructor(contents) {\n        super({ src1: contents });\n    }\n    calculateComment() {\n        return '';\n    }\n    toMIPS() {\n        return '';\n    }\n    toString() {\n        return `#\\t${this.OPERAND1()}`;\n    }\n    toTuple() {\n        return ['', this.OPERAND1(), null, null];\n    }\n}\nexports.Comment = Comment;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/Instructions/Misc.ts?")},"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Operation.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Div = exports.Mult = exports.Sub = exports.Add = exports.Operation = void 0;\nconst Quadruple_1 = __importDefault(__webpack_require__(/*! ./Quadruple */ \"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Quadruple.ts\"));\nclass Operation extends Quadruple_1.default {\n    comment = '';\n    operator = '+';\n    operatorVerbose = 'Add';\n    constructor(options) {\n        const { saveIn: dest, operand1: src1, operand2: src2, comment } = options;\n        super({ dest, src1, src2, comment });\n    }\n    toMIPS() {\n        const operation = this.OPERAND(true);\n        const dest = this.DESTINATION();\n        const src1 = this.OPERAND1();\n        const src2 = this.OPERAND2();\n        return this.withComment(`\\t\\t${operation} ${dest}, ${src1}, ${src2}`);\n    }\n    toString() {\n        return this.withComment(`\\t\\t${this.DESTINATION()} = ${this.OPERAND1()} ${this.OPERAND()} ${this.OPERAND2()}`);\n    }\n    setOperatorVerbose() {\n        this.operatorVerbose = this.immediateAppend(this.src2, this.operatorVerbose);\n    }\n    calculateComment() {\n        return '';\n    }\n}\nexports.Operation = Operation;\n/**\n * Adds two values and stores the result in a temporal variable\n * @example\n * add $1, $2, $3 // $1 = $2 + $3\n */\nclass Add extends Operation {\n    comment = '';\n    operator = '+';\n    operatorVerbose = 'Add';\n    calculateComment() {\n        const first = this.OPERAND1();\n        const second = this.OPERAND2();\n        const temporal = this.DESTINATION();\n        this.comment = `Adding ${this.immediateAppend(second, '', true)} value ${second} to ${first} and storing it in ${temporal}`;\n        return this.comment;\n    }\n}\nexports.Add = Add;\n/**\n * Extension of the Add class, but subtracts the second operand from the first. Some documentation\n * says that MIPS uses the add operation for both, making the second operand negative.\n *\n * @example\n * sub $1, $2, $3 // $1 = $2 - $3\n */\nclass Sub extends Add {\n    operator = '-';\n    operatorVerbose = 'Sub';\n}\nexports.Sub = Sub;\n/**\n * Multiplies two values and stores the result in a temporal variable\n * @example\n * mul $1, $2, $3 // $1 = $2 * $3\n */\nclass Mult extends Operation {\n    operator = '*';\n    operatorVerbose = 'mult';\n    comment = '';\n    calculateComment() {\n        const first = this.OPERAND1();\n        const second = this.OPERAND2();\n        const temporal = this.DESTINATION();\n        this.comment = `Multiplying value ${second} to ${first} and storing it in ${temporal}`;\n        return this.comment;\n    }\n}\nexports.Mult = Mult;\n/**\n * MIPS does have a division operator that stores the remainder in mfhi and the quotient in mflo.\n */\nclass Div extends Operation {\n    operator = '/';\n    operatorVerbose = 'div';\n    comment = '';\n    calculateComment() {\n        const first = this.OPERAND1();\n        const second = this.OPERAND2();\n        const temporal = this.DESTINATION();\n        this.comment = `Dividing value ${second} to ${first} and storing it in ${temporal}`;\n        return this.comment;\n    }\n}\nexports.Div = Div;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/Instructions/Operation.ts?")},"./src/Implementations/DataStructures/MemoryVisitors/Instructions/Quadruple.ts":(__unused_webpack_module,exports)=>{eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Quadruple {\n    src1 = null;\n    src2 = null;\n    dest = null;\n    comment;\n    constructor(options) {\n        this.src1 = options?.src1 ?? null;\n        this.src2 = options?.src2 ?? null;\n        this.dest = options?.dest ?? null;\n        this.setOperatorVerbose();\n        if (options?.comment)\n            this.comment = options.comment;\n        else\n            this.comment = this.calculateComment();\n    }\n    setOperatorVerbose() { }\n    isRegistry(reg) {\n        return reg.toString().startsWith('$') || reg.toString().toLocaleLowerCase().startsWith('t');\n    }\n    immediateAppend(value, appendTo, extended = false) {\n        if (this.isRegistry(value)) {\n            return appendTo;\n        }\n        else if (extended) {\n            return 'immediate ' + appendTo;\n        }\n        return appendTo + 'i';\n    }\n    isImmediate = (value) => !this.isRegistry(value);\n    OPERAND(verbose = false) {\n        return verbose ? this.operatorVerbose : this.operator;\n    }\n    OPERAND1 = () => this.src1;\n    OPERAND2 = () => this.src2;\n    DESTINATION = () => this.dest;\n    getTemporal = () => this.DESTINATION();\n    withComment = (val) => {\n        return val;\n        return `${val}\\t\\t#\\t${this.comment || this.calculateComment?.()}`;\n    };\n    toTuple(asString = false) {\n        if (asString) {\n            return [\n                this.OPERAND()?.toString(),\n                this.OPERAND1()?.toString(),\n                this.OPERAND2()?.toString(),\n                this.DESTINATION()?.toString(),\n            ];\n        }\n        return [this.OPERAND(), this.OPERAND1(), this.OPERAND2(), this.DESTINATION()];\n    }\n}\nexports[\"default\"] = Quadruple;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/Instructions/Quadruple.ts?")},"./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EXIT = exports.ALLOCATE = exports.READ_STRING = exports.READ_INT = exports.PRINT_STRING = exports.PRINT_INT = exports.JUMP_BACK = exports.JUMP_WITH_LINK = exports.JUMP_LINK_REGISTER = exports.STACK_POINTER = exports.OBJECT_POINTER = exports.FUNCTION_PARAMETER_2 = exports.FUNCTION_PARAMETER_1 = exports.V0 = exports.Registry = exports.TemporalValue = void 0;\nconst Composition_1 = __importDefault(__webpack_require__(/*! ../../Components/Composition */ \"./src/Implementations/Components/Composition.ts\"));\nclass TemporalValue extends Composition_1.default {\n    static Name = 'TemporalValue';\n    static Type = 'TemporalValue';\n    constructor() {\n        super();\n        this.componentName = TemporalValue.Name;\n        this.componentType = TemporalValue.Type;\n    }\n    clone = () => new TemporalValue();\n    toString = () => `T{${this.id.substring(0, 3)}}`;\n}\nexports.TemporalValue = TemporalValue;\nclass Registry extends TemporalValue {\n    static Name = 'Registry';\n    static Type = 'Registry';\n    constructor() {\n        super();\n        this.componentName = Registry.Name;\n        this.componentType = Registry.Type;\n    }\n    toString = () => this.register;\n}\nexports.Registry = Registry;\nclass V0 extends Registry {\n    register = '$v0';\n    clone = () => {\n        return new V0();\n    };\n}\nexports.V0 = V0;\nclass FUNCTION_PARAMETER_1 extends Registry {\n    register = '$a0';\n    clone = () => {\n        return new FUNCTION_PARAMETER_1();\n    };\n}\nexports.FUNCTION_PARAMETER_1 = FUNCTION_PARAMETER_1;\nclass FUNCTION_PARAMETER_2 extends Registry {\n    register = '$a1';\n    clone = () => {\n        return new FUNCTION_PARAMETER_2();\n    };\n}\nexports.FUNCTION_PARAMETER_2 = FUNCTION_PARAMETER_2;\nclass OBJECT_POINTER extends Registry {\n    register = '$a2';\n    clone = () => {\n        return new OBJECT_POINTER();\n    };\n}\nexports.OBJECT_POINTER = OBJECT_POINTER;\nclass STACK_POINTER extends Registry {\n    register = '$sp';\n    offset;\n    constructor(offset = 0) {\n        super();\n        this.offset = offset;\n    }\n    clone = () => {\n        return new STACK_POINTER(this.offset);\n    };\n    toString = () => {\n        if (this.offset) {\n            return `${this.register} + ${this.offset}`;\n        }\n        return this.register;\n    };\n}\nexports.STACK_POINTER = STACK_POINTER;\nclass JUMP_LINK_REGISTER extends Registry {\n    register = '$ra';\n    clone = () => {\n        return new JUMP_LINK_REGISTER();\n    };\n}\nexports.JUMP_LINK_REGISTER = JUMP_LINK_REGISTER;\nclass JUMP_WITH_LINK extends Registry {\n    register = 'jal';\n    clone = () => {\n        return new JUMP_WITH_LINK();\n    };\n}\nexports.JUMP_WITH_LINK = JUMP_WITH_LINK;\nclass JUMP_BACK extends Registry {\n    register = 'jr';\n    clone = () => {\n        return new JUMP_BACK();\n    };\n}\nexports.JUMP_BACK = JUMP_BACK;\nclass SystemCall extends TemporalValue {\n    static Name = 'SystemCall';\n    static Type = 'SystemCall';\n    constructor() {\n        super();\n        this.componentName = SystemCall.Name;\n        this.componentType = SystemCall.Type;\n    }\n    toString = () => this.callValue.toString();\n}\nclass PRINT_INT extends SystemCall {\n    callValue = 1;\n    clone = () => {\n        return new PRINT_INT();\n    };\n}\nexports.PRINT_INT = PRINT_INT;\nclass PRINT_STRING extends SystemCall {\n    callValue = 4;\n    clone = () => {\n        return new PRINT_STRING();\n    };\n}\nexports.PRINT_STRING = PRINT_STRING;\nclass READ_INT extends SystemCall {\n    callValue = 5;\n    clone = () => {\n        return new READ_INT();\n    };\n}\nexports.READ_INT = READ_INT;\nclass READ_STRING extends SystemCall {\n    callValue = 8;\n    clone = () => {\n        return new READ_STRING();\n    };\n}\nexports.READ_STRING = READ_STRING;\nclass ALLOCATE extends SystemCall {\n    callValue = 9;\n    clone = () => {\n        return new ALLOCATE();\n    };\n}\nexports.ALLOCATE = ALLOCATE;\nclass EXIT extends SystemCall {\n    callValue = 10;\n    clone = () => {\n        return new EXIT();\n    };\n}\nexports.EXIT = EXIT;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts?")},"./src/Implementations/DataStructures/MemoryVisitors/add.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ../../Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nconst BasicOperation_1 = __importDefault(__webpack_require__(/*! ./Instructions/BasicOperation */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/BasicOperation.ts"));\nconst Operation_1 = __webpack_require__(/*! ./Instructions/Operation */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Operation.ts");\nfunction default_1(visitor, ctx) {\n    const [leftChildTemporal, rightChildTemporal, temporal] = (0, BasicOperation_1.default)(visitor, ctx);\n    visitor.addQuadruple(new Operation_1.Add({ saveIn: temporal, operand1: leftChildTemporal, operand2: rightChildTemporal }));\n    const size = Integer_type_1.default.Size;\n    const getTemporal = () => temporal;\n    return [{ size, getTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/add.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/assignment.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nfunction default_1(visitor, ctx) {\n    const name = ctx.IDENTIFIER();\n    const currentTable = visitor.currentClassTable();\n    const referencedVariable = currentTable.get(name.text);\n    const memoryValue = referencedVariable.getMemoryAddress();\n    const memory = new MemoryManagement_1.MemoryAddress(memoryValue);\n    const [expressionResult] = visitor.visit(ctx.expression());\n    const temporal = expressionResult.getTemporal();\n    visitor.addQuadruple(new MemoryManagement_1.Move({ dataMovesInto: memory, dataMovesFrom: temporal }));\n    return [{ size: 0, getTemporal: () => temporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/assignment.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/assignmentExpr.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst index_1 = __webpack_require__(/*! ../TableElements/index */ "./src/Implementations/DataStructures/TableElements/index.ts");\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction visitAssignmentExpr(visitor, ctx) {\n    const name = ctx.IDENTIFIER();\n    const type = ctx.TYPE();\n    const expression = ctx.expression();\n    const typeClass = visitor.symbolsTable.get(type.text).copy();\n    const currentClassTable = visitor.currentClassTable();\n    const newSymbol = new index_1.SymbolElement({\n        type: typeClass,\n        scopeName: \'Temporal\',\n        name: name.text,\n    });\n    const thisTemporal = new TemporaryValues_1.TemporalValue();\n    currentClassTable.add(newSymbol);\n    if (expression) {\n        const [expressionVisitor] = visitor.visit(expression);\n        const temporal = expressionVisitor.getTemporal();\n        visitor.addQuadruple(new MemoryManagement_1.Move({\n            dataMovesInto: thisTemporal,\n            dataMovesFrom: temporal,\n        }));\n    }\n    else {\n        visitor.addQuadruple(new MemoryManagement_1.Move({\n            dataMovesInto: thisTemporal,\n            dataMovesFrom: typeClass.defaultValue,\n        }));\n    }\n    const size = typeClass.getSize?.() ?? typeClass.sizeInBytes;\n    return [{ size, getTemporal: () => thisTemporal }];\n}\nexports["default"] = visitAssignmentExpr;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/assignmentExpr.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/block.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nfunction visitBlock(visitor, ctx) {\n    return visitor.visitChildren(ctx);\n}\nexports["default"] = visitBlock;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/block.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/classDefine.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nfunction visitClassDefine(visitor, ctx) {\n    return [];\n}\nexports["default"] = visitClassDefine;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/classDefine.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/division.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ../../Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nconst BasicOperation_1 = __importDefault(__webpack_require__(/*! ./Instructions/BasicOperation */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/BasicOperation.ts"));\nconst Operation_1 = __webpack_require__(/*! ./Instructions/Operation */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Operation.ts");\nfunction visitDivision(visitor, ctx) {\n    const [leftChildTemporal, rightChildTemporal, temporal] = (0, BasicOperation_1.default)(visitor, ctx);\n    visitor.addQuadruple(new Operation_1.Div({\n        saveIn: temporal,\n        operand1: leftChildTemporal,\n        operand2: rightChildTemporal\n    }));\n    const size = Integer_type_1.default.Size;\n    const getTemporal = () => temporal;\n    return [{ size, getTemporal }];\n}\nexports["default"] = visitDivision;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/division.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/equal.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ../../Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nconst Comparison_1 = __webpack_require__(/*! ./Instructions/Comparison */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Comparison.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const [leftExpression, rightExpression] = ctx.expression();\n    const [left] = visitor.visit(leftExpression);\n    const [right] = visitor.visit(rightExpression);\n    const temporal = new TemporaryValues_1.TemporalValue();\n    visitor.addQuadruple(new Comparison_1.EQUAL({\n        fistOperand: left.getTemporal(),\n        secondOperand: right.getTemporal(),\n        goTo: temporal.toString(),\n    }));\n    return [{ size: Boolean_type_1.default.Size, getTemporal: () => temporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/equal.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/false.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ../../Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, _ctx) {\n    const size = Boolean_type_1.default.Size;\n    const temporal = new TemporaryValues_1.TemporalValue();\n    visitor.addQuadruple(new MemoryManagement_1.Move({ dataMovesInto: temporal, dataMovesFrom: 0 }));\n    const getTemporal = () => temporal;\n    return [{ size, getTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/false.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/formal.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const name = ctx.IDENTIFIER();\n    const currentClassTable = visitor.currentClassTable();\n    const newTemporal = new TemporaryValues_1.TemporalValue();\n    const symbol = currentClassTable.get(name.text);\n    newTemporal.id = symbol.id;\n    visitor.addQuadruple(new MemoryManagement_1.Move({\n        dataMovesFrom: new MemoryManagement_1.MemoryAddress(new TemporaryValues_1.STACK_POINTER(visitor.stackMemoryOffset)),\n        dataMovesInto: newTemporal,\n        comment: `Parameters are passed through the stack`,\n    }));\n    visitor.stackMemoryOffset += symbol.getSize();\n    const size = symbol.getSize();\n    const getTemporal = () => newTemporal;\n    return [{ size, getTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/formal.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/id.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Table_1 = __webpack_require__(/*! ../../Components/Table */ "./src/Implementations/Components/Table.ts");\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const name = ctx.IDENTIFIER();\n    const currentTable = visitor.currentClassTable();\n    const found = currentTable.get(name.text);\n    const inTable = currentTable.getAll();\n    const thisTemporal = new TemporaryValues_1.TemporalValue();\n    const foundTemporal = inTable.find((el) => el.getName() === name.text);\n    const size = found.getSize();\n    if (foundTemporal) {\n        thisTemporal.id = foundTemporal.id;\n        visitor.addQuadruple(new MemoryManagement_1.LoadWord({\n            dataMovesFrom: new TemporaryValues_1.STACK_POINTER(foundTemporal.getMemoryAddress()),\n            dataMovesInto: thisTemporal,\n        }));\n        return [{ size, getTemporal: () => thisTemporal }];\n        // If it is in the table, use it\'s temporal\n    }\n    else if (found) {\n        const currentClass = visitor.currentClass(-1);\n        const currentClassTable = (0, Table_1.extractTableComponent)(currentClass);\n        const elementInClass = currentClassTable.get(name.text);\n        visitor.addQuadruple(new MemoryManagement_1.Move({\n            dataMovesInto: thisTemporal,\n            dataMovesFrom: new MemoryManagement_1.MemoryAddress(elementInClass.getMemoryAddress()),\n            comment: `Load value "${name}" from the method\'s memory`,\n        }));\n    }\n    const returnValue = {\n        getTemporal: () => thisTemporal,\n        size,\n    };\n    return [returnValue];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/id.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/if.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst uuid_1 = __webpack_require__(/*! uuid */ "uuid");\nconst Jumps_1 = __webpack_require__(/*! ./Instructions/Jumps */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Jumps.ts");\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst Misc_1 = __webpack_require__(/*! ./Instructions/Misc */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Misc.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const [condition, body, elses] = ctx.expression();\n    // Condition\n    const ifCondition = \'if::\' + (0, uuid_1.v4)().substring(0, 8);\n    // GOTO\n    visitor.visit(condition);\n    const lastQuadruple = visitor.methods[visitor.scopes.at(-1)].at(-1);\n    lastQuadruple.dest = ifCondition;\n    visitor.visit(elses);\n    visitor.addQuadruple(new Misc_1.MethodDeclaration(ifCondition + \'end\'));\n    // BODY\n    visitor.pushScope(ifCondition);\n    visitor.addQuadruple(new Misc_1.MethodDeclaration(ifCondition));\n    const [bodyReturn] = visitor.visit(body);\n    visitor.addQuadruple(new MemoryManagement_1.Move({\n        dataMovesInto: new TemporaryValues_1.V0(),\n        dataMovesFrom: bodyReturn.getTemporal(),\n    }));\n    visitor.addQuadruple(new Jumps_1.UnconditionalJump(ifCondition + \'end\'));\n    visitor.addQuadruple(new Misc_1.Return());\n    visitor.popScope();\n    return [{ size: 1, getTemporal: () => new TemporaryValues_1.TemporalValue() }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/if.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/index.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.visitLessThan = exports.visitLetIn = exports.visitWhile = exports.visitTrue = exports.visitString = exports.visitProperty = exports.visitParentheses = exports.visitOwnMethodCall = exports.visitNew = exports.visitNegative = exports.visitMultiply = exports.visitMinus = exports.visitMethodCall = exports.visitMethod = exports.visitForIn = exports.visitLessEqual = exports.visitIsVoid = exports.visitInt = exports.visitIf = exports.visitId = exports.visitFormal = exports.visitFalse = exports.visitEqual = exports.visitDivision = exports.visitClassDefine = exports.visitBlock = exports.visitAssignmentExpr = exports.visitAssignment = exports.visitAdd = void 0;\nvar add_1 = __webpack_require__(/*! ./add */ "./src/Implementations/DataStructures/MemoryVisitors/add.ts");\nObject.defineProperty(exports, "visitAdd", ({ enumerable: true, get: function () { return __importDefault(add_1).default; } }));\nvar assignment_1 = __webpack_require__(/*! ./assignment */ "./src/Implementations/DataStructures/MemoryVisitors/assignment.ts");\nObject.defineProperty(exports, "visitAssignment", ({ enumerable: true, get: function () { return __importDefault(assignment_1).default; } }));\nvar assignmentExpr_1 = __webpack_require__(/*! ./assignmentExpr */ "./src/Implementations/DataStructures/MemoryVisitors/assignmentExpr.ts");\nObject.defineProperty(exports, "visitAssignmentExpr", ({ enumerable: true, get: function () { return __importDefault(assignmentExpr_1).default; } }));\nvar block_1 = __webpack_require__(/*! ./block */ "./src/Implementations/DataStructures/MemoryVisitors/block.ts");\nObject.defineProperty(exports, "visitBlock", ({ enumerable: true, get: function () { return __importDefault(block_1).default; } }));\nvar classDefine_1 = __webpack_require__(/*! ./classDefine */ "./src/Implementations/DataStructures/MemoryVisitors/classDefine.ts");\nObject.defineProperty(exports, "visitClassDefine", ({ enumerable: true, get: function () { return __importDefault(classDefine_1).default; } }));\nvar division_1 = __webpack_require__(/*! ./division */ "./src/Implementations/DataStructures/MemoryVisitors/division.ts");\nObject.defineProperty(exports, "visitDivision", ({ enumerable: true, get: function () { return __importDefault(division_1).default; } }));\nvar equal_1 = __webpack_require__(/*! ./equal */ "./src/Implementations/DataStructures/MemoryVisitors/equal.ts");\nObject.defineProperty(exports, "visitEqual", ({ enumerable: true, get: function () { return __importDefault(equal_1).default; } }));\nvar false_1 = __webpack_require__(/*! ./false */ "./src/Implementations/DataStructures/MemoryVisitors/false.ts");\nObject.defineProperty(exports, "visitFalse", ({ enumerable: true, get: function () { return __importDefault(false_1).default; } }));\nvar formal_1 = __webpack_require__(/*! ./formal */ "./src/Implementations/DataStructures/MemoryVisitors/formal.ts");\nObject.defineProperty(exports, "visitFormal", ({ enumerable: true, get: function () { return __importDefault(formal_1).default; } }));\nvar id_1 = __webpack_require__(/*! ./id */ "./src/Implementations/DataStructures/MemoryVisitors/id.ts");\nObject.defineProperty(exports, "visitId", ({ enumerable: true, get: function () { return __importDefault(id_1).default; } }));\nvar if_1 = __webpack_require__(/*! ./if */ "./src/Implementations/DataStructures/MemoryVisitors/if.ts");\nObject.defineProperty(exports, "visitIf", ({ enumerable: true, get: function () { return __importDefault(if_1).default; } }));\nvar int_1 = __webpack_require__(/*! ./int */ "./src/Implementations/DataStructures/MemoryVisitors/int.ts");\nObject.defineProperty(exports, "visitInt", ({ enumerable: true, get: function () { return __importDefault(int_1).default; } }));\nvar isVoid_1 = __webpack_require__(/*! ./isVoid */ "./src/Implementations/DataStructures/MemoryVisitors/isVoid.ts");\nObject.defineProperty(exports, "visitIsVoid", ({ enumerable: true, get: function () { return __importDefault(isVoid_1).default; } }));\nvar lessEqual_1 = __webpack_require__(/*! ./lessEqual */ "./src/Implementations/DataStructures/MemoryVisitors/lessEqual.ts");\nObject.defineProperty(exports, "visitLessEqual", ({ enumerable: true, get: function () { return __importDefault(lessEqual_1).default; } }));\nvar letin_1 = __webpack_require__(/*! ./letin */ "./src/Implementations/DataStructures/MemoryVisitors/letin.ts");\nObject.defineProperty(exports, "visitForIn", ({ enumerable: true, get: function () { return __importDefault(letin_1).default; } }));\nvar method_1 = __webpack_require__(/*! ./method */ "./src/Implementations/DataStructures/MemoryVisitors/method.ts");\nObject.defineProperty(exports, "visitMethod", ({ enumerable: true, get: function () { return __importDefault(method_1).default; } }));\nvar methodCall_1 = __webpack_require__(/*! ./methodCall */ "./src/Implementations/DataStructures/MemoryVisitors/methodCall.ts");\nObject.defineProperty(exports, "visitMethodCall", ({ enumerable: true, get: function () { return __importDefault(methodCall_1).default; } }));\nvar minus_1 = __webpack_require__(/*! ./minus */ "./src/Implementations/DataStructures/MemoryVisitors/minus.ts");\nObject.defineProperty(exports, "visitMinus", ({ enumerable: true, get: function () { return __importDefault(minus_1).default; } }));\nvar multiply_1 = __webpack_require__(/*! ./multiply */ "./src/Implementations/DataStructures/MemoryVisitors/multiply.ts");\nObject.defineProperty(exports, "visitMultiply", ({ enumerable: true, get: function () { return __importDefault(multiply_1).default; } }));\nvar negative_1 = __webpack_require__(/*! ./negative */ "./src/Implementations/DataStructures/MemoryVisitors/negative.ts");\nObject.defineProperty(exports, "visitNegative", ({ enumerable: true, get: function () { return __importDefault(negative_1).default; } }));\nvar new_1 = __webpack_require__(/*! ./new */ "./src/Implementations/DataStructures/MemoryVisitors/new.ts");\nObject.defineProperty(exports, "visitNew", ({ enumerable: true, get: function () { return __importDefault(new_1).default; } }));\nvar ownMethodCall_1 = __webpack_require__(/*! ./ownMethodCall */ "./src/Implementations/DataStructures/MemoryVisitors/ownMethodCall.ts");\nObject.defineProperty(exports, "visitOwnMethodCall", ({ enumerable: true, get: function () { return __importDefault(ownMethodCall_1).default; } }));\nvar parentheses_1 = __webpack_require__(/*! ./parentheses */ "./src/Implementations/DataStructures/MemoryVisitors/parentheses.ts");\nObject.defineProperty(exports, "visitParentheses", ({ enumerable: true, get: function () { return __importDefault(parentheses_1).default; } }));\nvar property_1 = __webpack_require__(/*! ./property */ "./src/Implementations/DataStructures/MemoryVisitors/property.ts");\nObject.defineProperty(exports, "visitProperty", ({ enumerable: true, get: function () { return __importDefault(property_1).default; } }));\nvar string_1 = __webpack_require__(/*! ./string */ "./src/Implementations/DataStructures/MemoryVisitors/string.ts");\nObject.defineProperty(exports, "visitString", ({ enumerable: true, get: function () { return __importDefault(string_1).default; } }));\nvar true_1 = __webpack_require__(/*! ./true */ "./src/Implementations/DataStructures/MemoryVisitors/true.ts");\nObject.defineProperty(exports, "visitTrue", ({ enumerable: true, get: function () { return __importDefault(true_1).default; } }));\nvar while_1 = __webpack_require__(/*! ./while */ "./src/Implementations/DataStructures/MemoryVisitors/while.ts");\nObject.defineProperty(exports, "visitWhile", ({ enumerable: true, get: function () { return __importDefault(while_1).default; } }));\nvar letin_2 = __webpack_require__(/*! ./letin */ "./src/Implementations/DataStructures/MemoryVisitors/letin.ts");\nObject.defineProperty(exports, "visitLetIn", ({ enumerable: true, get: function () { return __importDefault(letin_2).default; } }));\nvar lessThan_1 = __webpack_require__(/*! ./lessThan */ "./src/Implementations/DataStructures/MemoryVisitors/lessThan.ts");\nObject.defineProperty(exports, "visitLessThan", ({ enumerable: true, get: function () { return __importDefault(lessThan_1).default; } }));\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/index.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/int.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ../../Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const temporal = new TemporaryValues_1.TemporalValue();\n    visitor.addQuadruple(new MemoryManagement_1.Move({ dataMovesInto: temporal, dataMovesFrom: parseInt(ctx.INT().text) }));\n    const size = Integer_type_1.default.Size;\n    const getTemporal = () => temporal;\n    return [{ size, getTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/int.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/isVoid.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nfunction default_1(visitor, ctx) {\n    return [];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/isVoid.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/lessEqual.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ../../Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nconst Comparison_1 = __webpack_require__(/*! ./Instructions/Comparison */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Comparison.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const [leftExpression, rightExpression] = ctx.expression();\n    const [left] = visitor.visit(leftExpression);\n    const [right] = visitor.visit(rightExpression);\n    const temporal = new TemporaryValues_1.TemporalValue();\n    visitor.addQuadruple(new Comparison_1.LESSEQUAL({\n        fistOperand: left.getTemporal(),\n        secondOperand: right.getTemporal(),\n        goTo: temporal.toString(),\n    }));\n    return [{ size: Boolean_type_1.default.Size, getTemporal: () => temporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/lessEqual.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/lessThan.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ../../Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nconst Comparison_1 = __webpack_require__(/*! ./Instructions/Comparison */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Comparison.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const [leftExpression, rightExpression] = ctx.expression();\n    const [left] = visitor.visit(leftExpression);\n    const [right] = visitor.visit(rightExpression);\n    const temporal = new TemporaryValues_1.TemporalValue();\n    visitor.addQuadruple(new Comparison_1.LESSTHAN({\n        fistOperand: left.getTemporal(),\n        secondOperand: right.getTemporal(),\n        goTo: temporal.toString(),\n    }));\n    return [{ size: Boolean_type_1.default.Size, getTemporal: () => temporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/lessThan.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/letin.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst uuid_1 = __webpack_require__(/*! uuid */ "uuid");\nconst Table_1 = __importDefault(__webpack_require__(/*! ../../Components/Table */ "./src/Implementations/Components/Table.ts"));\nconst Jumps_1 = __webpack_require__(/*! ./Instructions/Jumps */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Jumps.ts");\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst Misc_1 = __webpack_require__(/*! ./Instructions/Misc */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Misc.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const assigmentExpressions = ctx.assignmentExpr();\n    const expression = ctx.expression();\n    const containingTable = new Table_1.default();\n    // @ts-ignore\n    visitor.classStack.push(containingTable);\n    const sizes = [];\n    for (const assignmentExpr of assigmentExpressions) {\n        const [result] = visitor.visit(assignmentExpr);\n        sizes.push({ size: result.size });\n    }\n    const allSizeNeeded = sizes.reduce((a, b) => a + b.size, 0);\n    visitor.startCall();\n    const letInScope = \'letIn::\' + (0, uuid_1.v4)().substring(0, 8);\n    visitor.addQuadruple(new Jumps_1.LinkedJump(letInScope));\n    visitor.endCall();\n    visitor.pushScope(letInScope);\n    visitor.addQuadruple(new Misc_1.MethodDeclaration(letInScope));\n    visitor.AskForStackMemory(allSizeNeeded);\n    const receivingTemporal = new TemporaryValues_1.TemporalValue();\n    let currentStackPointer = visitor.stackMemoryOffset;\n    for (const variable of containingTable.getAll()) {\n        variable.setMemoryAddress(currentStackPointer);\n        currentStackPointer += variable.getSize();\n    }\n    const [result] = visitor.visit(expression);\n    const temporalResult = result.getTemporal();\n    visitor.addQuadruple(new MemoryManagement_1.Move({\n        dataMovesFrom: temporalResult,\n        dataMovesInto: new TemporaryValues_1.V0(),\n    }), new Misc_1.Return());\n    visitor.popScope();\n    visitor.classStack.pop();\n    visitor.addQuadruple(new MemoryManagement_1.Move({\n        dataMovesFrom: new TemporaryValues_1.V0(),\n        dataMovesInto: receivingTemporal,\n    }));\n    return [{ size: 1, getTemporal: () => receivingTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/letin.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/method.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst Misc_1 = __webpack_require__(/*! ./Instructions/Misc */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Misc.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const name = ctx.IDENTIFIER();\n    const currentClassName = visitor.currentClass().getName();\n    const currentClassTable = visitor.currentClassTable();\n    const expectedName = `${currentClassName}::${name.text}()`;\n    const method = currentClassTable.get(name.text);\n    // @ts-ignore\n    visitor.classStack.push(method);\n    visitor.pushScope(expectedName);\n    visitor.addQuadruple(new Misc_1.MethodDeclaration(expectedName));\n    const children = visitor.visitChildren(ctx);\n    const lastChild = children.at(-1);\n    visitor.writeReturn(lastChild.getTemporal());\n    visitor.popScope();\n    visitor.classStack.pop();\n    const temporal = new TemporaryValues_1.TemporalValue();\n    visitor.addQuadruple(new MemoryManagement_1.Move({ dataMovesInto: temporal, dataMovesFrom: new TemporaryValues_1.V0() }));\n    const size = 0;\n    const getTemporal = () => temporal;\n    return [{ size, getTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/method.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/methodCall.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst ContextHolder_1 = __webpack_require__(/*! ../../Components/ContextHolder */ "./src/Implementations/Components/ContextHolder.ts");\nconst Table_1 = __importStar(__webpack_require__(/*! ../../Components/Table */ "./src/Implementations/Components/Table.ts"));\nconst Type_1 = __webpack_require__(/*! ../../Components/Type */ "./src/Implementations/Components/Type.ts");\nconst MethodElement_1 = __importDefault(__webpack_require__(/*! ../TableElements/MethodElement */ "./src/Implementations/DataStructures/TableElements/MethodElement.ts"));\nconst SymbolElement_1 = __importDefault(__webpack_require__(/*! ../TableElements/SymbolElement */ "./src/Implementations/DataStructures/TableElements/SymbolElement.ts"));\nconst Jumps_1 = __webpack_require__(/*! ./Instructions/Jumps */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Jumps.ts");\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst Misc_1 = __webpack_require__(/*! ./Instructions/Misc */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Misc.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    visitor.startCall();\n    const name = ctx.IDENTIFIER();\n    const type = ctx.TYPE();\n    const [callingVariable, ...parameters] = ctx.expression();\n    const currentClassTable = visitor.currentClassTable(-1);\n    const callingVariableSymbol = visitor.findInStack(callingVariable.text);\n    //   const callingVariableSymbol = currentClassTable.get(callingVariable.text) as SymbolElement;\n    const variableType = type\n        ? visitor.symbolsTable.get(type).copy()\n        : (0, Type_1.extractTypeComponent)(callingVariableSymbol);\n    let variableTable;\n    if (type) {\n        const inheritedTable = (0, Table_1.extractTableComponent)(visitor.symbolsTable.get(type))\n            .copy()\n            // @ts-ignore\n            .getAll(false);\n        const currentTable = (0, Table_1.extractTableComponent)(callingVariableSymbol).getAll(false);\n        variableTable = new Table_1.default();\n        variableTable.add(...inheritedTable.filter((t) => t.componentName === MethodElement_1.default.Name));\n        variableTable.add(...currentTable.filter((t) => t.componentName === SymbolElement_1.default.Name));\n    }\n    else {\n        variableTable = (0, Table_1.extractTableComponent)(callingVariableSymbol);\n    }\n    visitor.classStack.push(callingVariableSymbol);\n    const expectedMethodName = `${variableType.getName()}::${name.text}`;\n    let totalMemory = 0;\n    const addresses = [];\n    for (const parameter of parameters) {\n        const referenced = currentClassTable.get(parameter.text);\n        totalMemory += referenced.getSize();\n        addresses.push({\n            base: callingVariableSymbol.getMemoryAddress(),\n            address: referenced.memoryAddress,\n            size: referenced.getSize(),\n        });\n    }\n    visitor.AskForStackMemory(totalMemory);\n    let nextPointer = visitor.stackMemoryOffset;\n    const temporals = [];\n    for (const address of addresses) {\n        const memoryAddress = address.base + address.address;\n        const temporal = new TemporaryValues_1.TemporalValue();\n        temporals.push(temporal);\n        const memoryTemporal = new MemoryManagement_1.MemoryAddress(memoryAddress);\n        visitor.addQuadruple(new MemoryManagement_1.LoadWord({\n            dataMovesFrom: memoryTemporal,\n            dataMovesInto: temporal,\n        }));\n        visitor.addQuadruple(new MemoryManagement_1.StoreWord({\n            dataMovesFrom: temporal,\n            dataMovesInto: new TemporaryValues_1.STACK_POINTER(nextPointer),\n        }));\n        nextPointer += address.size;\n        // visitor.addQuadruple()\n    }\n    visitor.addQuadruple(new Jumps_1.LinkedJump(expectedMethodName));\n    const method = visitor.methods[expectedMethodName];\n    if (!method) {\n        visitor.pushScope(expectedMethodName);\n        visitor.addQuadruple(new Misc_1.MethodDeclaration(expectedMethodName));\n        const stackBefore = visitor.stackMemoryOffset;\n        const foundMethod = variableTable.get(name.text);\n        const methodContext = (0, ContextHolder_1.extractContext)(foundMethod);\n        // @ts-ignore\n        visitor.classStack.push(foundMethod);\n        const newMethod = visitor.visitChildren(methodContext.context);\n        visitor.classStack.pop();\n        visitor.removeFromStack(stackBefore - visitor.stackMemoryOffset);\n        visitor.stackMemoryOffset = stackBefore;\n        let nextPointer2 = visitor.stackMemoryOffset;\n        let temporalPointer = 0;\n        visitor.writeReturn(newMethod.at(-1).getTemporal());\n        visitor.popScope();\n        for (const address of addresses) {\n            const temporal = temporals[temporalPointer++];\n            const memoryAddress = address.base + address.address;\n            visitor.addQuadruple(new MemoryManagement_1.LoadWord({\n                dataMovesFrom: new TemporaryValues_1.STACK_POINTER(nextPointer2),\n                dataMovesInto: temporal,\n            }));\n            nextPointer2 += address.size;\n            // visitor.addQuadruple()\n        }\n        visitor.LiberateStackMemory(totalMemory);\n    }\n    visitor.endCall();\n    const temporal = new TemporaryValues_1.TemporalValue();\n    visitor.addQuadruple(new MemoryManagement_1.Move({ dataMovesInto: temporal, dataMovesFrom: new TemporaryValues_1.V0() }));\n    visitor.classStack.pop();\n    // TODO: Remove the parameters from the stack\n    return [{ size: 0, getTemporal: () => temporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/methodCall.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/minus.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ../../Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nconst BasicOperation_1 = __importDefault(__webpack_require__(/*! ./Instructions/BasicOperation */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/BasicOperation.ts"));\nconst Operation_1 = __webpack_require__(/*! ./Instructions/Operation */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Operation.ts");\nfunction default_1(visitor, ctx) {\n    const [leftChildTemporal, rightChildTemporal, temporal] = (0, BasicOperation_1.default)(visitor, ctx);\n    visitor.addQuadruple(new Operation_1.Sub({\n        saveIn: temporal,\n        operand1: leftChildTemporal,\n        operand2: rightChildTemporal,\n    }));\n    const size = Integer_type_1.default.Size;\n    const getTemporal = () => temporal;\n    return [{ size, getTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/minus.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/multiply.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ../../Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nconst BasicOperation_1 = __importDefault(__webpack_require__(/*! ./Instructions/BasicOperation */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/BasicOperation.ts"));\nconst Operation_1 = __webpack_require__(/*! ./Instructions/Operation */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Operation.ts");\nfunction default_1(visitor, ctx) {\n    const [leftChildTemporal, rightChildTemporal, temporal] = (0, BasicOperation_1.default)(visitor, ctx);\n    visitor.addQuadruple(new Operation_1.Mult({\n        saveIn: temporal,\n        operand1: leftChildTemporal,\n        operand2: rightChildTemporal\n    }));\n    const size = Integer_type_1.default.Size;\n    const getTemporal = () => temporal;\n    return [{ size, getTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/multiply.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/negative.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ../../Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nconst Bitwise_1 = __webpack_require__(/*! ./Instructions/Bitwise */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Bitwise.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const expression = ctx.expression();\n    const [expressionResult] = visitor.visit(expression);\n    const expressionTemporal = expressionResult.getTemporal();\n    const temporal = new TemporaryValues_1.TemporalValue();\n    const size = Integer_type_1.default.Size;\n    const getTemporal = () => temporal;\n    visitor.addQuadruple(new Bitwise_1.NOT({\n        saveIn: temporal,\n        toNegate: expressionTemporal,\n    }));\n    return [{ size, getTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/negative.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/new.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Table_1 = __webpack_require__(/*! ../../Components/Table */ "./src/Implementations/Components/Table.ts");\nconst Type_1 = __webpack_require__(/*! ../../Components/Type */ "./src/Implementations/Components/Type.ts");\nconst ValueHolder_1 = __webpack_require__(/*! ../../Components/ValueHolder */ "./src/Implementations/Components/ValueHolder.ts");\nconst index_1 = __webpack_require__(/*! ../TableElements/index */ "./src/Implementations/DataStructures/TableElements/index.ts");\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const type = ctx.TYPE();\n    const memoryBeginning = new TemporaryValues_1.TemporalValue();\n    const currentClass = visitor.currentClass();\n    const referencedType = visitor.symbolsTable.get(type.text);\n    const size = referencedType.getSize();\n    visitor.AskForHeapMemory(size);\n    visitor.addQuadruple(new MemoryManagement_1.Move({ dataMovesInto: memoryBeginning, dataMovesFrom: new TemporaryValues_1.V0() }));\n    const referencedTypeTable = (0, Table_1.extractTableComponent)(referencedType);\n    const allElements = referencedTypeTable.filter(index_1.SymbolElement.Name);\n    for (const element of allElements) {\n        const valueHolder = (0, ValueHolder_1.extractValueComponent)(element);\n        const type = (0, Type_1.extractTypeComponent)(element);\n        const temporal = new TemporaryValues_1.TemporalValue();\n        if (valueHolder) {\n            visitor.addQuadruple(new MemoryManagement_1.Move({\n                dataMovesInto: temporal,\n                dataMovesFrom: valueHolder.getValue(),\n            }), new MemoryManagement_1.StoreWord({\n                dataMovesFrom: temporal,\n                dataMovesInto: element.toString(),\n                offset: memoryBeginning.toString(),\n            }));\n        }\n        else {\n            visitor.addQuadruple(new MemoryManagement_1.Move({\n                dataMovesInto: temporal,\n                dataMovesFrom: type.defaultValue,\n            }), new MemoryManagement_1.StoreWord({\n                dataMovesFrom: temporal,\n                dataMovesInto: element.toString(),\n                offset: memoryBeginning.toString(),\n            }));\n        }\n    }\n    return [{ size, getTemporal: () => new TemporaryValues_1.TemporalValue(), save: true }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/new.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/ownMethodCall.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    visitor.startCall();\n    const name = ctx.IDENTIFIER();\n    const parameters = ctx.expression();\n    const currentClassTable = visitor.currentClassTable(-1);\n    const currentClass = visitor.currentClass(-1);\n    const method = currentClassTable.get(name.text);\n    const expectedMethodName = `${currentClass.getName()}::${name.text}`;\n    //   let totalMemory = 0;\n    //   const addresses = [];\n    //   for (const parameter of parameters) {\n    //     const referenced = currentClassTable.get(parameter.text)! as SymbolElement;\n    //     totalMemory += referenced.getSize();\n    //     addresses.push({\n    //       base: callingVariableSymbol!.getMemoryAddress(),\n    //       address: referenced.memoryAddress,\n    //       size: referenced.getSize(),\n    //     });\n    //   }\n    //   let nextPointer = 0;\n    //   visitor.AskForStackMemory(totalMemory);\n    //   const temporals = [];\n    //   for (const address of addresses) {\n    //     const currentStackPointer = visitor.stackMemoryOffset;\n    //     const memoryAddress = address.base + address.address;\n    //     const temporal = new TemporalValue();\n    //     temporals.push(temporal);\n    //     const memoryTemporal = new MemoryAddress(memoryAddress);\n    //     visitor.addQuadruple(\n    //       new LoadWord({\n    //         dataMovesFrom: memoryTemporal,\n    //         dataMovesInto: temporal,\n    //       }),\n    //     );\n    //     visitor.addQuadruple(\n    //       new StoreWord({\n    //         dataMovesFrom: temporal,\n    //         dataMovesInto: new STACK_POINTER(currentStackPointer - nextPointer),\n    //       }),\n    //     );\n    //     nextPointer = currentStackPointer + address.size;\n    //     // visitor.addQuadruple()\n    //   }\n    //   visitor.addQuadruple(new LinkedJump(expectedMethodName));\n    //   const methodBody = visitor.methods[expectedMethodName];\n    //   if (!methodBody) {\n    //     // visitor.pushScope(expectedMethodName);\n    //     // visitor.addQuadruple(new MethodDeclaration(expectedMethodName));\n    //     visitor.pushScope(expectedMethodName);\n    //     visitor.addQuadruple(new MethodDeclaration(expectedMethodName));\n    //     const stackBefore = visitor.stackMemoryOffset;\n    //     const methodContext = extractContext(method)!;\n    //     // @ts-ignore\n    //     visitor.classStack.push(foundMethod);\n    //     const newMethod = visitor.visitChildren(methodContext.context!);\n    //     visitor.classStack.pop();\n    //     visitor.removeFromStack(stackBefore - visitor.stackMemoryOffset);\n    //     visitor.stackMemoryOffset = stackBefore;\n    //     let nextPointer2 = 0;\n    //     let temporalPointer = 0;\n    //     for (const address of addresses) {\n    //       const temporal = temporals[temporalPointer++];\n    //       const currentStackPointer = visitor.stackMemoryOffset;\n    //       const memoryAddress = address.base + address.address;\n    //       visitor.addQuadruple(\n    //         new LoadWord({\n    //           dataMovesFrom: new STACK_POINTER(currentStackPointer - nextPointer2),\n    //           dataMovesInto: temporal,\n    //         }),\n    //       );\n    //       nextPointer2 = currentStackPointer + address.size;\n    //       // visitor.addQuadruple()\n    //     }\n    //     visitor.LiberateStackMemory(totalMemory);\n    //     visitor.writeReturn(newMethod.at(-1)!.getTemporal());\n    //     visitor.popScope();\n    //   }\n    //   const callingVariableSymbol = currentClassTable.get(callingVariable.text) as SymbolElement;\n    //   const variableType = extractTypeComponent(callingVariableSymbol)! as ClassType;\n    //   let variableTable: TableComponent<MethodElement | SymbolElement>;\n    //   visitor.classStack.push(callingVariableSymbol);\n    //   const expectedMethodName = `${variableType.getName()}::${name.text}`;\n    //   let totalMemory = 0;\n    //   const addresses = [];\n    //   for (const parameter of parameters) {\n    //     const referenced = currentClassTable.get(parameter.text)! as SymbolElement;\n    //     totalMemory += referenced.getSize();\n    //     addresses.push({\n    //       base: callingVariableSymbol!.getMemoryAddress(),\n    //       address: referenced.memoryAddress,\n    //       size: referenced.getSize(),\n    //     });\n    //   }\n    //   let nextPointer = 0;\n    //   visitor.AskForStackMemory(totalMemory);\n    //   const temporals = [];\n    //   for (const address of addresses) {\n    //     const currentStackPointer = visitor.stackMemoryOffset;\n    //     const memoryAddress = address.base + address.address;\n    //     const temporal = new TemporalValue();\n    //     temporals.push(temporal);\n    //     const memoryTemporal = new MemoryAddress(memoryAddress);\n    //     visitor.addQuadruple(\n    //       new LoadWord({\n    //         dataMovesFrom: memoryTemporal,\n    //         dataMovesInto: temporal,\n    //       }),\n    //     );\n    //     visitor.addQuadruple(\n    //       new StoreWord({\n    //         dataMovesFrom: temporal,\n    //         dataMovesInto: new STACK_POINTER(currentStackPointer - nextPointer),\n    //       }),\n    //     );\n    //     nextPointer = currentStackPointer + address.size;\n    //     // visitor.addQuadruple()\n    //   }\n    //   visitor.addQuadruple(new LinkedJump(expectedMethodName));\n    //   const method = visitor.methods[expectedMethodName];\n    //   if (!method) {\n    //     visitor.pushScope(expectedMethodName);\n    //     visitor.addQuadruple(new MethodDeclaration(expectedMethodName));\n    //     const stackBefore = visitor.stackMemoryOffset;\n    //     const foundMethod = variableTable!.get(name.text)!;\n    //     const methodContext = extractContext(foundMethod)!;\n    //     // @ts-ignore\n    //     visitor.classStack.push(foundMethod);\n    //     const newMethod = visitor.visitChildren(methodContext.context!);\n    //     visitor.classStack.pop();\n    //     visitor.removeFromStack(stackBefore - visitor.stackMemoryOffset);\n    //     visitor.stackMemoryOffset = stackBefore;\n    //     let nextPointer2 = 0;\n    //     let temporalPointer = 0;\n    //     for (const address of addresses) {\n    //       const temporal = temporals[temporalPointer++];\n    //       const currentStackPointer = visitor.stackMemoryOffset;\n    //       const memoryAddress = address.base + address.address;\n    //       visitor.addQuadruple(\n    //         new LoadWord({\n    //           dataMovesFrom: new STACK_POINTER(currentStackPointer - nextPointer2),\n    //           dataMovesInto: temporal,\n    //         }),\n    //       );\n    //       nextPointer2 = currentStackPointer + address.size;\n    //       // visitor.addQuadruple()\n    //     }\n    //     visitor.LiberateStackMemory(totalMemory);\n    //     visitor.writeReturn(newMethod.at(-1)!.getTemporal());\n    //     visitor.popScope();\n    //   }\n    //   visitor.endCall();\n    //   const temporal = new TemporalValue();\n    //   visitor.addQuadruple(new Move({ dataMovesInto: temporal, dataMovesFrom: new V0() }));\n    //   visitor.classStack.pop();\n    // TODO: Remove the parameters from the stack\n    return [{ size: 0, getTemporal: () => new TemporaryValues_1.TemporalValue() }];\n    //   return [{ size: 0, getTemporal: () => temporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/ownMethodCall.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/parentheses.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nfunction default_1(visitor, ctx) {\n    return [];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/parentheses.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/property.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Table_1 = __webpack_require__(/*! ../../Components/Table */ "./src/Implementations/Components/Table.ts");\nconst MethodElement_1 = __importDefault(__webpack_require__(/*! ../TableElements/MethodElement */ "./src/Implementations/DataStructures/TableElements/MethodElement.ts"));\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst Misc_1 = __webpack_require__(/*! ./Instructions/Misc */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Misc.ts");\nfunction default_1(visitor, ctx) {\n    const name = ctx.IDENTIFIER();\n    const currentClassTable = visitor.currentClassTable();\n    const referencedVariable = currentClassTable.get(name);\n    visitor.addQuadruple(new Misc_1.Comment(`Begin Property ${name.text}\\n`));\n    visitor.classStack.push(referencedVariable);\n    const [result] = visitor.visitChildren(ctx);\n    visitor.classStack.pop();\n    const table = (0, Table_1.extractTableComponent)(referencedVariable);\n    if (table) {\n        const newTable = table.copy();\n        for (const element of newTable.getAll()) {\n            if (element.componentName === MethodElement_1.default.Name)\n                continue;\n            const currentElement = element;\n            currentElement.setMemoryAddress(currentElement.getMemoryAddress() + referencedVariable.getMemoryAddress());\n        }\n        referencedVariable.replaceComponent(newTable);\n    }\n    const temporal = result.getTemporal();\n    if (!result.save) {\n        visitor.addQuadruple(new MemoryManagement_1.StoreWord({\n            dataMovesFrom: temporal,\n            dataMovesInto: referencedVariable.toString(),\n        }));\n    }\n    referencedVariable.setMemoryAddress(visitor.memoryOffset);\n    visitor.register(referencedVariable.id, result.size);\n    visitor.addQuadruple(new Misc_1.Comment(`End Property ${name.text}\\n`));\n    const size = referencedVariable.getSize();\n    const getTemporal = () => temporal;\n    return [{ size, getTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/property.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/string.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const string = ctx.STRING().text.substring(1, ctx.STRING().text.length - 1);\n    const temporal = new TemporaryValues_1.TemporalValue();\n    const separated = [...string.split(\'\'), \'\\0\'];\n    const returnTemporal = new TemporaryValues_1.TemporalValue();\n    const size = separated.length;\n    visitor.AskForHeapMemory(size);\n    visitor.addQuadruple(new MemoryManagement_1.Move({\n        dataMovesInto: returnTemporal,\n        dataMovesFrom: new TemporaryValues_1.V0(),\n        comment: \'Save the beginning position of the string\',\n    }));\n    let index = 0;\n    for (const char of separated) {\n        visitor.addQuadruple(new MemoryManagement_1.Move({ dataMovesInto: temporal, dataMovesFrom: char.charCodeAt(0) }));\n        visitor.addQuadruple(new MemoryManagement_1.StoreWord({ dataMovesInto: new MemoryManagement_1.MemoryAddress(returnTemporal + ` + ${index++}`), dataMovesFrom: temporal }));\n    }\n    return [{ size, getTemporal: () => returnTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/string.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/true.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ../../Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nconst MemoryManagement_1 = __webpack_require__(/*! ./Instructions/MemoryManagement */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/MemoryManagement.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const size = Boolean_type_1.default.Size;\n    const temporal = new TemporaryValues_1.TemporalValue();\n    visitor.addQuadruple(new MemoryManagement_1.Move({ dataMovesInto: temporal, dataMovesFrom: 1 }));\n    const getTemporal = () => temporal;\n    return [{ size, getTemporal }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/true.ts?')},"./src/Implementations/DataStructures/MemoryVisitors/while.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst uuid_1 = __webpack_require__(/*! uuid */ "uuid");\nconst Misc_1 = __webpack_require__(/*! ./Instructions/Misc */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Misc.ts");\nconst Comparison_1 = __webpack_require__(/*! ./Instructions/Comparison */ "./src/Implementations/DataStructures/MemoryVisitors/Instructions/Comparison.ts");\nconst TemporaryValues_1 = __webpack_require__(/*! ./TemporaryValues */ "./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts");\nfunction default_1(visitor, ctx) {\n    const [condition, body] = ctx.expression();\n    const whileCondition = \'while::\' + (0, uuid_1.v4)().substring(0, 8);\n    const endWhile = whileCondition + \'end\';\n    visitor.visit(condition);\n    const conditioner = visitor.methods[visitor.scopes.at(-1)].pop();\n    const whileGuard = new Comparison_1.EQUAL({\n        fistOperand: new TemporaryValues_1.TemporalValue(),\n        secondOperand: new TemporaryValues_1.TemporalValue(),\n        goTo: endWhile,\n    });\n    visitor.addQuadruple(whileGuard);\n    visitor.addQuadruple(new Misc_1.MethodDeclaration(whileCondition));\n    visitor.visit(body);\n    visitor.addQuadruple(conditioner);\n    const lastQuadruple = visitor.methods[visitor.scopes.at(-1)].at(-1);\n    lastQuadruple.dest = whileCondition;\n    whileGuard.src1 = lastQuadruple.src2;\n    whileGuard.src2 = lastQuadruple.src1;\n    whileGuard.operator = lastQuadruple.operator;\n    whileGuard.operatorVerbose = lastQuadruple.operatorVerbose;\n    visitor.addQuadruple(new Misc_1.MethodDeclaration(endWhile));\n    return [{ size: 0, getTemporal: () => new TemporaryValues_1.TemporalValue() }];\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/MemoryVisitors/while.ts?')},"./src/Implementations/DataStructures/Stack.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Stack = void 0;\nclass Stack {\n    items = [];\n    push(...item) {\n        this.items.push(...item);\n    }\n    pop() {\n        return this.items.pop();\n    }\n    peek() {\n        return this.items[this.items.length - 1];\n    }\n    size() {\n        return this.items.length;\n    }\n    isEmpty() {\n        return this.items.length === 0;\n    }\n    getItem(index) {\n        if (index + 1 > this.size()) {\n            return this.items[this.size() - 1];\n        }\n        return this.items[index];\n    }\n}\nexports.Stack = Stack;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/Stack.ts?')},"./src/Implementations/DataStructures/TableElements/MethodElement.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Components_1 = __webpack_require__(/*! ../../Components */ "./src/Implementations/Components/index.ts");\nconst ContextHolder_1 = __importStar(__webpack_require__(/*! ../../Components/ContextHolder */ "./src/Implementations/Components/ContextHolder.ts"));\nconst Table_1 = __importDefault(__webpack_require__(/*! ../../Components/Table */ "./src/Implementations/Components/Table.ts"));\nconst Table_2 = __importStar(__webpack_require__(/*! ../../Components/Table */ "./src/Implementations/Components/Table.ts"));\nconst TableElement_1 = __importDefault(__webpack_require__(/*! ./TableElement */ "./src/Implementations/DataStructures/TableElements/TableElement.ts"));\nclass MethodElement extends TableElement_1.default {\n    static Name = \'MethodElement\';\n    constructor(options) {\n        super(options);\n        this.componentName = MethodElement.Name;\n        const newTableComponent = new Table_2.default();\n        this.addComponent(newTableComponent);\n        this.addComponent(new ContextHolder_1.default());\n    }\n    addParameters(...parameters) {\n        const tableComponent = this.getComponent({ componentType: Table_1.default.Type });\n        tableComponent.add(...parameters);\n        return this;\n    }\n    getTable() {\n        return this.getComponent({ componentType: Table_1.default.Type });\n    }\n    getParameters() {\n        const tableComponent = this.getTable();\n        return tableComponent.getAll();\n    }\n    clone() {\n        const typeComponent = (0, Components_1.extractTypeComponent)(this);\n        const positioningComponent = (0, Components_1.extractPositioning)(this);\n        const value = (0, Components_1.extractValueComponent)(this)?.getValue();\n        const contextHolder = (0, ContextHolder_1.extractContext)(this);\n        const newMethod = new MethodElement({\n            type: typeComponent,\n            scopeName: this.scopeName,\n            column: positioningComponent?.column,\n            line: positioningComponent?.line,\n            memoryAddress: this.memoryAddress,\n            name: this.getName(),\n            value,\n        });\n        const table = (0, Table_2.extractTableComponent)(this);\n        newMethod.replaceComponent(table?.copy());\n        const newContext = (0, ContextHolder_1.extractContext)(newMethod);\n        newContext.setContext(contextHolder.getContext());\n        return newMethod;\n    }\n    toString() {\n        const basicInfo = this.getComponent({ componentType: Components_1.BasicInfoComponent.Type });\n        const name = basicInfo.getName();\n        const thisTable = (0, Table_2.extractTableComponent)(this);\n        const elements = thisTable.elements\n            .filter((el) => el.componentName === \'SymbolElement\')\n            .map((el) => el.toString())\n            .join(\'\\n\\t\\t\');\n        const methods = thisTable.elements\n            .filter((el) => el.componentName === this.componentName)\n            .map((el) => el.toString())\n            .join(\'\\n\\t\\t\');\n        const elementsString = elements.length ? `\\n\\t\\t${elements}` : \'\';\n        const methodsString = methods.length ? `\\n\\t\\t${methods}` : \'\';\n        return `MethodComponent{${name}${elementsString}${methodsString}${elementsString || methodsString ? \'\\t\\n\' : \'\'}}`;\n    }\n    getSize = () => 0;\n    toCode() {\n        return `goto ${this.getName()}`;\n    }\n}\nexports["default"] = MethodElement;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/TableElements/MethodElement.ts?')},"./src/Implementations/DataStructures/TableElements/SymbolElement.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Components_1 = __webpack_require__(/*! ../../Components */ "./src/Implementations/Components/index.ts");\nconst TableElement_1 = __importDefault(__webpack_require__(/*! ./TableElement */ "./src/Implementations/DataStructures/TableElements/TableElement.ts"));\nclass SymbolElement extends TableElement_1.default {\n    static Name = \'SymbolElement\';\n    constructor(options) {\n        super(options);\n        this.componentName = SymbolElement.Name;\n        this.memoryAddress = options?.memoryAddress ?? -1;\n    }\n    clone() {\n        const typeComponent = (0, Components_1.extractTypeComponent)(this);\n        const basicInfo = (0, Components_1.extractBasicInformation)(this);\n        const positioningComponent = (0, Components_1.extractPositioning)(this);\n        const value = (0, Components_1.extractValueComponent)(this)?.getValue();\n        return new SymbolElement({\n            scopeName: this.scopeName,\n            type: typeComponent,\n            name: basicInfo.getName(),\n            column: positioningComponent?.column,\n            line: positioningComponent?.line,\n            memoryAddress: this.memoryAddress,\n            value,\n        });\n    }\n    toString() {\n        const basicInfo = (0, Components_1.extractBasicInformation)(this);\n        return `${basicInfo?.getName()}{${this.toAddress()}}`;\n        // const basicInfo = this.getComponent<BasicInfoComponent>({ componentType: BasicInfoComponent.Type })!;\n        // return `SymbolElement{ scope{ ${\n        //   this.scopeName\n        // } }, name{ ${basicInfo.getName()} } address { 0x${this.memoryAddress.toString(16)} } }`;\n    }\n    getSize = () => {\n        const typeComponent = (0, Components_1.extractTypeComponent)(this);\n        return typeComponent?.getSize?.() ?? typeComponent?.sizeInBytes;\n    };\n    toCode() {\n        const basicInfo = this.getComponent({ componentType: Components_1.BasicInfoComponent.Type });\n        const scope = this.scopeName;\n        const name = basicInfo.getName();\n        return `${scope}.${name}`;\n    }\n    setMemoryAddress = (address) => {\n        this.memoryAddress = address;\n    };\n    getMemoryAddress = () => this.memoryAddress;\n    toAddress = () => `0x${this.memoryAddress.toString(16)}`;\n}\nexports["default"] = SymbolElement;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/TableElements/SymbolElement.ts?')},"./src/Implementations/DataStructures/TableElements/TableElement.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"uuid\");\nconst Components_1 = __webpack_require__(/*! ../../Components */ \"./src/Implementations/Components/index.ts\");\nclass TableElement extends Components_1.CompositionComponent {\n    referentialID;\n    scopeName;\n    memoryAddress = -1;\n    constructor(options) {\n        super();\n        this.referentialID = (0, uuid_1.v4)();\n        this.componentType = 'TableElement';\n        this.unique = false;\n        this.scopeName = options?.scopeName ?? 'Unknown Scope';\n        this.memoryAddress = -1;\n        const basicInfo = new Components_1.BasicInfoComponent({ name: options?.name });\n        this.addComponent(basicInfo);\n        const typeComponent = options?.type?.getComponent({ componentType: Components_1.TypeComponent.Type });\n        if (!typeComponent)\n            throw new Error('Trying to instantiate with non-existent type');\n        this.addComponent(typeComponent);\n        if (options?.value) {\n            this.addComponent(new Components_1.ValueComponent({ value: options?.value }));\n        }\n        if (options?.line) {\n            this.addComponent(new Components_1.PositioningComponent({ line: options?.line, column: options?.column }));\n        }\n    }\n    getBasicInfo() {\n        return this.getComponent({ componentType: Components_1.BasicInfoComponent.Type });\n    }\n    getType() {\n        return this.getComponent({ componentType: Components_1.TypeComponent.Type });\n    }\n    getValueHolder() {\n        return this.getComponent({ componentType: Components_1.ValueComponent.Type });\n    }\n    getPositioning() {\n        return this.getComponent({ componentType: Components_1.PositioningComponent.Type });\n    }\n    getLine() {\n        const positioningComponent = this.getPositioning();\n        return positioningComponent.line ?? -1;\n    }\n    getColumn() {\n        const positioningComponent = this.getPositioning();\n        return positioningComponent.column ?? -1;\n    }\n    getName() {\n        const basicInfo = this.getBasicInfo();\n        return basicInfo.getName() ?? 'Unknown name';\n    }\n    setAddress(newAddress) {\n        this.memoryAddress = newAddress;\n    }\n    offsetAddressBy(p_offset) {\n        this.memoryAddress += p_offset;\n        return this.memoryAddress;\n    }\n}\nexports[\"default\"] = TableElement;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/TableElements/TableElement.ts?")},"./src/Implementations/DataStructures/TableElements/index.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.MethodElement = exports.SymbolElement = void 0;\nvar SymbolElement_1 = __webpack_require__(/*! ./SymbolElement */ "./src/Implementations/DataStructures/TableElements/SymbolElement.ts");\nObject.defineProperty(exports, "SymbolElement", ({ enumerable: true, get: function () { return __importDefault(SymbolElement_1).default; } }));\nvar MethodElement_1 = __webpack_require__(/*! ./MethodElement */ "./src/Implementations/DataStructures/TableElements/MethodElement.ts");\nObject.defineProperty(exports, "MethodElement", ({ enumerable: true, get: function () { return __importDefault(MethodElement_1).default; } }));\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/DataStructures/TableElements/index.ts?')},"./src/Implementations/Errors/Errors.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BasicStorage = void 0;\nclass BasicStorage {\n    elements;\n    constructor() {\n        this.elements = [];\n    }\n    add = (error) => {\n        if (this.exists(error))\n            return;\n        this.elements.push(error);\n    };\n    exists = (error) => {\n        const requiredKeys = Object.keys(error);\n        return this.elements.some((existingError) => {\n            return requiredKeys.every((key) => {\n                return existingError[key] === error[key];\n            });\n        });\n    };\n    getAll = () => this.elements;\n    flush = () => {\n        this.elements.length = 0;\n    };\n}\nexports.BasicStorage = BasicStorage;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Errors/Errors.ts?')},"./src/Implementations/Generics/Boolean.type.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Components_1 = __webpack_require__(/*! ../Components */ "./src/Implementations/Components/index.ts");\nconst index_1 = __webpack_require__(/*! ./index */ "./src/Implementations/Generics/index.ts");\nconst Primitive_type_1 = __webpack_require__(/*! ./Primitive.type */ "./src/Implementations/Generics/Primitive.type.ts");\nclass BoolType extends Primitive_type_1.Primitive {\n    static Name = \'Bool\';\n    static Type = \'Bool\';\n    static Size = 1;\n    defaultValue = 0;\n    constructor() {\n        super({ name: BoolType.Name });\n        this.componentName = BoolType.Name;\n        this.sizeInBytes = BoolType.Size;\n        this.allowsNegation = true;\n        this.addComponent(new Components_1.TableComponent());\n    }\n    clone() {\n        return new BoolType();\n    }\n    allowsAssignmentOf = function (value) {\n        const typeComponent = value?.getComponent({ componentType: Components_1.TypeComponent.Type });\n        if (!typeComponent)\n            return false;\n        return [index_1.IntegerType.Name, BoolType.Name].includes(typeComponent.componentName);\n    };\n    allowsComparisonTo = function (value) {\n        const typeComponent = value?.getComponent({ componentType: Components_1.TypeComponent.Type });\n        if (!typeComponent)\n            return false;\n        return [index_1.IntegerType.Name, BoolType.Name].includes(typeComponent.componentName);\n    };\n    coherseType = function (value) {\n        const typeComponent = value?.getComponent({ componentType: Components_1.TypeComponent.Type });\n        if (!typeComponent)\n            return null;\n        if (typeComponent.componentName === BoolType.Name) {\n            return value;\n        }\n        else if (typeComponent.componentName === index_1.IntegerType.Name) {\n            const newBool = new BoolType();\n            const foundValue = value.getComponent({ componentType: Components_1.ValueComponent.Type });\n            if (foundValue) {\n                newBool.addComponent(new Components_1.ValueComponent({ value: !!foundValue.getValue() }));\n            }\n            return newBool;\n        }\n        return null;\n    };\n}\nexports["default"] = BoolType;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Generics/Boolean.type.ts?')},"./src/Implementations/Generics/IO.type.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IOType = void 0;\nconst Components_1 = __webpack_require__(/*! ../Components */ \"./src/Implementations/Components/index.ts\");\nconst TableElements_1 = __webpack_require__(/*! ../DataStructures/TableElements */ \"./src/Implementations/DataStructures/TableElements/index.ts\");\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ./Integer.type */ \"./src/Implementations/Generics/Integer.type.ts\"));\nconst Primitive_type_1 = __webpack_require__(/*! ./Primitive.type */ \"./src/Implementations/Generics/Primitive.type.ts\");\nconst String_type_1 = __importDefault(__webpack_require__(/*! ./String.type */ \"./src/Implementations/Generics/String.type.ts\"));\nclass IOType extends Primitive_type_1.Primitive {\n    static Name = 'IO';\n    static Type = 'IO';\n    static Size = 1;\n    defaultValue = null;\n    allowsAssignmentOf = (_incomingType) => false;\n    allowsComparisonTo = (_incomingType) => false;\n    coherseType = (_incomingType, _value) => {\n        throw new Error('Cannot coherse IOType');\n    };\n    constructor() {\n        super({ name: IOType.Name });\n        this.componentName = IOType.Name;\n        this.sizeInBytes = IOType.Size;\n        const tableComponent = new Components_1.TableComponent();\n        const outStringMethod = new TableElements_1.MethodElement({\n            name: 'out_string',\n            type: this,\n            scopeName: this.componentName,\n            memoryAddress: -1,\n        });\n        outStringMethod.addParameters(new TableElements_1.SymbolElement({ name: 'x', type: new String_type_1.default(), scopeName: this.componentName, memoryAddress: -1 }));\n        const outIntMethod = new TableElements_1.MethodElement({\n            name: 'out_int',\n            type: this,\n            scopeName: this.componentName,\n            memoryAddress: -1,\n        });\n        outIntMethod.addParameters(new TableElements_1.SymbolElement({ name: 'x', type: new Integer_type_1.default(), scopeName: this.componentName, memoryAddress: -1 }));\n        const inStringMethod = new TableElements_1.MethodElement({\n            name: 'in_string',\n            type: new String_type_1.default(),\n            scopeName: this.componentName,\n            memoryAddress: -1,\n        });\n        const inIntMethod = new TableElements_1.MethodElement({\n            name: 'in_int',\n            type: new Integer_type_1.default(),\n            scopeName: this.componentName,\n            memoryAddress: -1,\n        });\n        tableComponent.add(outStringMethod, outIntMethod, inStringMethod, inIntMethod);\n        this.addComponent(tableComponent);\n    }\n    clone() {\n        return new IOType();\n    }\n}\nexports.IOType = IOType;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Generics/IO.type.ts?")},"./src/Implementations/Generics/Integer.type.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst index_1 = __webpack_require__(/*! ../Components/index */ "./src/Implementations/Components/index.ts");\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ./Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nconst Primitive_type_1 = __webpack_require__(/*! ./Primitive.type */ "./src/Implementations/Generics/Primitive.type.ts");\nclass IntType extends Primitive_type_1.Primitive {\n    static Name = \'Int\';\n    static Type = \'Int\';\n    static Size = 4;\n    defaultValue = 0;\n    constructor() {\n        super({ name: IntType.Name });\n        this.componentName = IntType.Name;\n        this.sizeInBytes = IntType.Size;\n        this.allowsNegation = true;\n        // Don\'t set the type here, so that it ends up being a type itself\n    }\n    allowsAssignmentOf = function (value) {\n        const valueType = (0, index_1.extractTypeComponent)(value);\n        if (!valueType)\n            return false;\n        return [IntType.Name, Boolean_type_1.default.Name].includes(valueType.componentName);\n    };\n    allowsComparisonTo = function (value) {\n        const valueType = value?.getComponent({ componentType: index_1.TypeComponent.Type });\n        return [IntType.Name, Boolean_type_1.default.Name].includes(valueType?.componentName ?? \'\');\n    };\n    coherseType = function (value) {\n        if (!value)\n            return null;\n        if (value.componentName === IntType.Name) {\n            return value;\n        }\n        else if (value?.componentName === Boolean_type_1.default.Name) {\n            const newInt = new IntType();\n            const foundValue = value.getComponent({\n                componentType: index_1.ValueComponent.Type,\n            });\n            if (foundValue) {\n                newInt.addComponent(new index_1.ValueComponent({ value: Number(foundValue.getValue()) }));\n            }\n            return newInt;\n        }\n        return null;\n    };\n    clone() {\n        return new IntType();\n    }\n}\nexports["default"] = IntType;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Generics/Integer.type.ts?')},"./src/Implementations/Generics/Object.type.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClassType = exports.ObjectType = void 0;\nconst TableElements_1 = __webpack_require__(/*! ../DataStructures/TableElements */ \"./src/Implementations/DataStructures/TableElements/index.ts\");\nconst Components_1 = __webpack_require__(/*! ../Components */ \"./src/Implementations/Components/index.ts\");\nconst String_type_1 = __importDefault(__webpack_require__(/*! ./String.type */ \"./src/Implementations/Generics/String.type.ts\"));\nclass ObjectType extends Components_1.TypeComponent {\n    static Name = 'Object';\n    static Type = 'Object';\n    constructor(options) {\n        super();\n        this.componentName = ObjectType.Name;\n        this.sizeInBytes = 1;\n        this.isGeneric = false;\n        this.parent = null;\n        const basicInfo = new Components_1.BasicInfoComponent({ name: ObjectType.Name });\n        this.addComponent(basicInfo);\n        const tableComponent = new Components_1.TableComponent();\n        const abortMethod = new TableElements_1.MethodElement({\n            name: 'abort',\n            type: this,\n            scopeName: this.componentName,\n            memoryAddress: -1,\n        });\n        const typeNameMethod = new TableElements_1.MethodElement({\n            name: 'type_name',\n            type: new String_type_1.default(),\n            scopeName: this.componentName,\n            memoryAddress: -1,\n        });\n        const copyMethod = new TableElements_1.MethodElement({\n            name: 'copy',\n            type: this,\n            scopeName: this.componentName,\n            memoryAddress: -1,\n        });\n        tableComponent.add(abortMethod, typeNameMethod, copyMethod);\n        this.addComponent(tableComponent);\n    }\n    allowsComparisonTo = (_incomingType) => {\n        return false;\n    };\n    coherseType = (_incomingType, value) => {\n        if (this.allowsAssignmentOf(_incomingType)) {\n            return value;\n        }\n        else\n            return null;\n    };\n    createChild = (context) => {\n        const newObject = new ClassType({ context });\n        const tableComponent = newObject.getComponent({\n            componentType: Components_1.TableComponent.Name,\n        });\n        const typeComponent = newObject.getComponent({ componentType: Components_1.TypeComponent.Name });\n        tableComponent.parent = this.getComponent({\n            componentType: Components_1.TableComponent.Name,\n        });\n        typeComponent.parent = this.getComponent({ componentType: Components_1.TypeComponent.Name });\n        return newObject;\n    };\n    allowsAssignmentOf = (value) => {\n        const typeComponent = value?.getComponent({ componentType: Components_1.TypeComponent.Type });\n        if (!typeComponent)\n            return false;\n        const entireHierarchyComponents = typeComponent.getHierarchy();\n        const entireHierarchyNames = entireHierarchyComponents\n            .map((t) => t.getComponent({ componentType: Components_1.BasicInfoComponent.Type })?.getName())\n            .filter((n) => !!n);\n        return entireHierarchyNames.includes(this.getComponent({ componentType: Components_1.BasicInfoComponent.Type })?.getName());\n    };\n    clone() {\n        return new ObjectType();\n    }\n    toString() {\n        return `<Primitive> ${this.getComponent({\n            componentType: Components_1.BasicInfoComponent.Type,\n        })?.getName()}`;\n    }\n}\nexports.ObjectType = ObjectType;\nclass ClassType extends ObjectType {\n    static Name = 'Class';\n    static Type = 'Class';\n    ctx;\n    constructor(options) {\n        super();\n        this.ctx = options.context;\n        this.componentName = options?.name ?? ClassType.Name;\n        this.parent = options?.parentType ?? null;\n        this.isGeneric = false;\n        const parentTable = options?.parentType?.getComponent({ componentType: Components_1.TableComponent.Type }) ?? null;\n        const basicInfo = this.getComponent({ componentType: Components_1.BasicInfoComponent.Type });\n        basicInfo.setName(options?.name ?? ClassType.Name);\n        const tableComponent = this.getComponent({ componentType: Components_1.TableComponent.Type });\n        tableComponent.parent = parentTable;\n    }\n    getType = () => {\n        return this.getComponent({ componentType: Components_1.TypeComponent.Type });\n    };\n    getBasicInfo = () => {\n        return this.getComponent({ componentType: Components_1.BasicInfoComponent.Type });\n    };\n    getName = () => {\n        const basicInfoComponent = this.getBasicInfo();\n        return basicInfoComponent.getName() ?? 'Unknown Class Name';\n    };\n    getTable = () => {\n        return this.getComponent({ componentType: Components_1.TableComponent.Type });\n    };\n    getElement = (name, options) => {\n        const tableComponent = this.getComponent({ componentType: Components_1.TableComponent.Type });\n        if (!tableComponent)\n            return null;\n        return tableComponent.get(name, options);\n    };\n    clone() {\n        return new ClassType({ context: this.ctx, name: this.getName(), parentType: this.parent });\n    }\n    getSize = () => {\n        const tableComponent = (0, Components_1.extractTableComponent)(this);\n        const size = tableComponent\n            .getAll(false)\n            .map((element) => {\n            if (element.componentName === TableElements_1.MethodElement.Name)\n                return 0;\n            return element.getSize();\n        })\n            .reduce((a, b) => a + b);\n        return size;\n    };\n    toString = () => {\n        const basicInfo = this.getComponent({ componentType: Components_1.BasicInfoComponent.Type });\n        const prepender = `<${ClassType.Name}>`;\n        const name = basicInfo.getName();\n        const thisTable = (0, Components_1.extractTableComponent)(this);\n        const elements = thisTable.elements\n            .filter((el) => el.componentName === 'SymbolElement')\n            .map((el) => el.toString())\n            .join('\\n\\t');\n        const methods = thisTable.elements\n            .filter((el) => el.componentName === 'MethodElement')\n            .map((el) => el.toString())\n            .join('\\n\\t');\n        const elementsString = elements.length ? `\\n\\t${elements}` : '';\n        const methodsString = methods.length ? `\\n\\t${methods}` : '';\n        return `${prepender} ${name}${elementsString}${methodsString}`;\n    };\n}\nexports.ClassType = ClassType;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Generics/Object.type.ts?")},"./src/Implementations/Generics/Primitive.type.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Primitive = void 0;\nconst BasicInformation_1 = __importDefault(__webpack_require__(/*! ../Components/BasicInformation */ "./src/Implementations/Components/BasicInformation.ts"));\nconst Type_1 = __importDefault(__webpack_require__(/*! ../Components/Type */ "./src/Implementations/Components/Type.ts"));\nconst ValueHolder_1 = __importDefault(__webpack_require__(/*! ../Components/ValueHolder */ "./src/Implementations/Components/ValueHolder.ts"));\nclass Primitive extends Type_1.default {\n    parent = null;\n    isGeneric = true;\n    constructor(options) {\n        super();\n        this.componentName = \'Primitive\';\n        const basicInfo = new BasicInformation_1.default({ name: options.name });\n        this.addComponent(basicInfo);\n    }\n    getValue = () => {\n        return (this.getComponent({ componentType: ValueHolder_1.default.Type })?.getValue() ??\n            this.defaultValue ??\n            null);\n    };\n    createChild = () => {\n        throw new Error(\'Cannot create child of primitive type\');\n    };\n    toString() {\n        return `Primitive{ ${this.getComponent({ componentType: BasicInformation_1.default.Type })?.getName()} }`;\n    }\n}\nexports.Primitive = Primitive;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Generics/Primitive.type.ts?')},"./src/Implementations/Generics/String.type.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StringType = void 0;\nconst Components_1 = __webpack_require__(/*! ../Components */ \"./src/Implementations/Components/index.ts\");\nconst TableElements_1 = __webpack_require__(/*! ../DataStructures/TableElements */ \"./src/Implementations/DataStructures/TableElements/index.ts\");\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ./Integer.type */ \"./src/Implementations/Generics/Integer.type.ts\"));\nconst Primitive_type_1 = __webpack_require__(/*! ./Primitive.type */ \"./src/Implementations/Generics/Primitive.type.ts\");\nclass StringType extends Primitive_type_1.Primitive {\n    static Name = 'String';\n    static Type = 'String';\n    static Size = 24;\n    defaultValue = '';\n    constructor() {\n        super({ name: StringType.Name });\n        this.componentName = StringType.Name;\n        this.sizeInBytes = StringType.Size;\n        const tableComponent = new Components_1.TableComponent();\n        this.addComponent(tableComponent);\n        const lengthMethod = new TableElements_1.MethodElement({\n            name: 'length',\n            type: new Integer_type_1.default(),\n            scopeName: this.componentName,\n            memoryAddress: -1,\n        });\n        const concatMethod = new TableElements_1.MethodElement({\n            name: 'concat',\n            type: this,\n            scopeName: this.componentName,\n            memoryAddress: -1,\n        });\n        concatMethod.addParameters(new TableElements_1.SymbolElement({ name: 's', type: this, scopeName: this.componentName, memoryAddress: -1 }));\n        const substrMethod = new TableElements_1.MethodElement({\n            name: 'substr',\n            type: this,\n            scopeName: this.componentName,\n            memoryAddress: -1,\n        });\n        substrMethod.addParameters(new TableElements_1.SymbolElement({ name: 'i', type: new Integer_type_1.default(), scopeName: this.componentName, memoryAddress: -1 }), new TableElements_1.SymbolElement({ name: 'l', type: new Integer_type_1.default(), scopeName: this.componentName, memoryAddress: -1 }));\n        tableComponent.add(lengthMethod, concatMethod, substrMethod);\n    }\n    allowsAssignmentOf = function (value) {\n        const incomingValueComponent = value?.getComponent({ componentType: Components_1.TypeComponent.Name });\n        if (!incomingValueComponent)\n            return false;\n        return [StringType.Name].includes(incomingValueComponent.componentName);\n    };\n    allowsComparisonTo = function (value) {\n        const incomingValueComponent = value?.getComponent({ componentType: Components_1.TypeComponent.Name });\n        if (!incomingValueComponent)\n            return false;\n        return [StringType.Name].includes(incomingValueComponent.componentName);\n    };\n    coherseType = function (value) {\n        const incomingValueTypeComponent = value?.getComponent({ componentType: Components_1.TypeComponent.Name });\n        const incomingValueComponent = value?.getComponent({ componentType: Components_1.ValueComponent.Name });\n        if (!incomingValueTypeComponent || !incomingValueComponent)\n            return null;\n        const newValue = new StringType();\n        newValue.addComponent(new Components_1.ValueComponent({ value: '' + incomingValueComponent.value }));\n        return newValue;\n    };\n    clone() {\n        return new StringType();\n    }\n}\nexports.StringType = StringType;\nexports[\"default\"] = StringType;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Generics/String.type.ts?")},"./src/Implementations/Generics/index.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.IntegerType = void 0;\nvar Integer_type_1 = __webpack_require__(/*! ./Integer.type */ "./src/Implementations/Generics/Integer.type.ts");\nObject.defineProperty(exports, "IntegerType", ({ enumerable: true, get: function () { return __importDefault(Integer_type_1).default; } }));\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/Generics/index.ts?')},"./src/Implementations/visitorFunctions/add.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst EmptyComponent_1 = __importDefault(__webpack_require__(/*! ../Components/EmptyComponent */ "./src/Implementations/Components/EmptyComponent.ts"));\nconst Type_1 = __webpack_require__(/*! ../Components/Type */ "./src/Implementations/Components/Type.ts");\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ../Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nfunction visitAdd(visitor, ctx) {\n    // TODO: Add value\n    // Must be done between two possible integers\n    const [leftChild, rightChild] = ctx.expression();\n    const intTable = visitor.findTable(Integer_type_1.default.Name).copy();\n    const leftElement = visitor.visit(leftChild);\n    const rightElement = visitor.visit(rightChild);\n    const lExpr = (0, Type_1.extractTypeComponent)(leftElement);\n    const rExpr = (0, Type_1.extractTypeComponent)(rightElement);\n    if (!lExpr || !rExpr) {\n        visitor.addError(ctx, `One of the expressions is not a type`);\n        return new EmptyComponent_1.default();\n    }\n    const allowedComparison = lExpr.allowsComparisonTo(rExpr);\n    // ERROR: If one of them is an ancestor of the other, they can be compared\n    if (!allowedComparison) {\n        visitor.addError(ctx, `Invalid Comparison: ${leftChild.toString()} = ${rightChild.toString()}`);\n        return new EmptyComponent_1.default();\n    }\n    return intTable;\n}\nexports["default"] = visitAdd;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/add.ts?')},"./src/Implementations/visitorFunctions/assignment.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst BasicInformation_1 = __webpack_require__(/*! ../Components/BasicInformation */ "./src/Implementations/Components/BasicInformation.ts");\nconst index_1 = __webpack_require__(/*! ../Components/index */ "./src/Implementations/Components/index.ts");\nfunction visitAssignment(visitor, ctx) {\n    const assignmentTo = ctx.IDENTIFIER();\n    const assignmentValue = visitor.visit(ctx.expression());\n    const assignmentValueBasicInfo = (0, BasicInformation_1.extractBasicInformation)(assignmentValue);\n    const currentScope = visitor.getCurrentScope();\n    const currentScopeBasicInfo = (0, BasicInformation_1.extractBasicInformation)(currentScope);\n    const tableComponent = (0, index_1.extractTableComponent)(currentScope);\n    const foundSymbol = tableComponent.get(assignmentTo.text);\n    const symbolBasicInformation = (0, BasicInformation_1.extractBasicInformation)(foundSymbol);\n    const symbolType = (0, index_1.extractTypeComponent)(foundSymbol);\n    // ERROR: The variable does not exist yet\n    if (!foundSymbol) {\n        visitor.addError(ctx, `Symbol ${assignmentTo.text} is not defined in scope ${currentScopeBasicInfo?.getName()}`);\n        return new index_1.EmptyComponent();\n    }\n    const allowed = symbolType?.allowsAssignmentOf(assignmentValue);\n    if (!allowed) {\n        visitor.addError(ctx, `Cannot assign ${assignmentValueBasicInfo?.getName()} to ${symbolBasicInformation?.getName()}`);\n    }\n    // TODO: Add an assignment in here\n    return new index_1.EmptyComponent(); // Assignments don\'t return anything\n}\nexports["default"] = visitAssignment;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/assignment.ts?')},"./src/Implementations/visitorFunctions/assignmentExpr.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst BasicInformation_1 = __webpack_require__(/*! ../Components/BasicInformation */ "./src/Implementations/Components/BasicInformation.ts");\nconst Table_1 = __webpack_require__(/*! ../Components/Table */ "./src/Implementations/Components/Table.ts");\nconst ValueHolder_1 = __webpack_require__(/*! ../Components/ValueHolder */ "./src/Implementations/Components/ValueHolder.ts");\nconst SymbolElement_1 = __importDefault(__webpack_require__(/*! ../DataStructures/TableElements/SymbolElement */ "./src/Implementations/DataStructures/TableElements/SymbolElement.ts"));\nconst meta_1 = __webpack_require__(/*! ./meta */ "./src/Implementations/visitorFunctions/meta.ts");\nfunction visitAssignmentExpr(visitor, ctx) {\n    // Previous table\n    const propertyName = ctx.IDENTIFIER();\n    const propertyType = ctx.TYPE();\n    const propertyAssignmentExpression = ctx.expression();\n    const propertyTypeClass = visitor.findTable(propertyType);\n    const currentScope = visitor.getCurrentScope();\n    // ERROR: The type is not yet defined\n    if (!propertyTypeClass) {\n        visitor.addError(ctx, `Type ${propertyType.text} is not (yet?) defined`);\n        return visitor.next(ctx);\n    }\n    const newTableElement = new SymbolElement_1.default({\n        name: propertyName.text,\n        type: propertyTypeClass,\n        scopeName: (0, BasicInformation_1.extractBasicInformation)(currentScope).getName(),\n        ...(0, meta_1.lineAndColumn)(ctx),\n    });\n    const currentScopeTable = (0, Table_1.extractTableComponent)(currentScope);\n    const previousDeclared = currentScopeTable.get(propertyName.text, { inCurrentScope: true });\n    // // Case 1: Overriding (It does nothing)\n    if (previousDeclared) {\n        visitor.addError(ctx, `Property ${propertyName.text} is already declared in ${currentScope.toString()}`);\n        return visitor.next(ctx);\n    }\n    if (propertyAssignmentExpression) {\n        const assignmentResolvesTo = visitor.visit(propertyAssignmentExpression);\n        const acceptsAssignment = propertyTypeClass.allowsAssignmentOf(assignmentResolvesTo);\n        // ERROR: Not allowed an assignment and the assignment is not to an ancestor\n        if (!acceptsAssignment) {\n            // TODO: Fix visitor\n            visitor.addError(ctx, `Cannot assign ${assignmentResolvesTo?.componentName ?? \'erroneous class\'} to ${propertyTypeClass.componentName} (Can\'t assign type ${assignmentResolvesTo?.componentName ?? \'\'} to ${propertyTypeClass.componentName})`);\n            return visitor.next(ctx);\n        }\n        const valueHolder = (0, ValueHolder_1.extractValueComponent)(assignmentResolvesTo);\n        newTableElement.addComponent(valueHolder?.copy());\n        // visitor.addQuadruple(simpleAssignment);\n    }\n    // Case 2: Declaration of a new property\n    currentScopeTable.add(newTableElement);\n    return newTableElement;\n}\nexports["default"] = visitAssignmentExpr;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/assignmentExpr.ts?')},"./src/Implementations/visitorFunctions/block.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst index_1 = __webpack_require__(/*! ../Components/index */ "./src/Implementations/Components/index.ts");\nfunction visitBlock(visitor, ctx) {\n    // Return only the last thing in the block\n    const resultingExpression = visitor.visitChildren(ctx);\n    if (!resultingExpression) {\n        visitor.addError(ctx, \'Empty code block\');\n        return new index_1.EmptyComponent();\n    }\n    const lastChild = Array.isArray(resultingExpression) ? resultingExpression.at(-1) : resultingExpression;\n    return lastChild;\n}\nexports["default"] = visitBlock;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/block.ts?')},"./src/Implementations/visitorFunctions/classDefine.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst BasicInformation_1 = __webpack_require__(/*! ../Components/BasicInformation */ "./src/Implementations/Components/BasicInformation.ts");\nconst Type_1 = __webpack_require__(/*! ../Components/Type */ "./src/Implementations/Components/Type.ts");\nconst Object_type_1 = __webpack_require__(/*! ../Generics/Object.type */ "./src/Implementations/Generics/Object.type.ts");\n/**\n * Checks that everything is alright in the class in itself\n * @param p_visitor\n * @param p_ctx\n * @returns The table\n */\nfunction semantic(p_visitor, p_ctx, p_errors) {\n    let [cls, inheritsFrom = Object_type_1.ObjectType.Name] = p_ctx.TYPE();\n    if (cls.text === \'Main\') {\n        p_visitor.mainBranch = p_ctx;\n    }\n    // ERROR: Class inherits from itself\n    if (cls.toString() === inheritsFrom.toString()) {\n        p_errors.push(`Class ${cls.toString()} can\'t inherit from itself`);\n        inheritsFrom = Object_type_1.ObjectType.Name; // FAILSAFE: If something inherits from itself, make it inherit from ObjectType\n    }\n    const classTable = p_visitor.findTable(cls);\n    // FATAL: Class already exists\n    if (classTable) {\n        const { isGeneric } = (0, Type_1.extractTypeComponent)(classTable);\n        if (isGeneric) {\n            p_errors.push(`Generic class ${cls} can\'t be redefined`);\n            return;\n        }\n        p_errors.push(`Redefinition of class ${cls}`);\n        return;\n    }\n    let parentTable = p_visitor.findTable(inheritsFrom);\n    const typeTableComponent = (0, Type_1.extractTypeComponent)(parentTable);\n    let defaultInheritance = true;\n    // ERROR: Trying to inherit from a non-existing class\n    if (!parentTable) {\n        p_errors.push(`Class ${cls} inherits from non-existing class ${inheritsFrom}`);\n    }\n    // ERROR: The table can\'t be inherited\n    else if (!typeTableComponent) {\n        p_errors.push(`Class ${cls} is trying to inherit from class ${inheritsFrom}, which is not a type`);\n    }\n    else if (typeTableComponent.isGeneric) {\n        p_errors.push(`Class ${cls} is trying to inherit from generic class ${inheritsFrom}`);\n    }\n    else {\n        defaultInheritance = false;\n    }\n    if (defaultInheritance) {\n        parentTable = p_visitor.findTable(Object_type_1.ObjectType.Name); // Shift back to ObjectType as a failsafe instead of failing\n    }\n    const inMainClass = cls.toString() === \'Main\';\n    if (inMainClass) {\n        p_visitor.enterMainScope();\n        p_visitor.mainExists = true;\n        // ERROR: Main class is trying to inherit from another class, which is not allowed\n        if (parentTable?.componentName !== Object_type_1.ObjectType.Name) {\n            p_errors.push(`Main class can\'t inherit from any class`);\n            parentTable = p_visitor.findTable(Object_type_1.ObjectType.Name);\n        }\n        p_visitor.mainBranch = p_ctx;\n    }\n    const newTable = parentTable.createChild(p_ctx);\n    newTable.componentName = cls.toString();\n    const basicComponent = (0, BasicInformation_1.extractBasicInformation)(newTable);\n    basicComponent.setName(cls.toString());\n    return newTable;\n}\nfunction visitClassDefine(p_visitor, p_ctx) {\n    p_visitor.returnToGlobalScope();\n    const errors = [];\n    const newTable = semantic(p_visitor, p_ctx, errors);\n    if (!newTable) {\n        return p_visitor.next(p_ctx);\n    }\n    p_visitor.addError(p_ctx, ...errors);\n    p_visitor.addSymbol(newTable);\n    p_visitor.addScope(newTable);\n    return p_visitor.next(p_ctx);\n}\nexports["default"] = visitClassDefine;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/classDefine.ts?')},"./src/Implementations/visitorFunctions/division.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst index_1 = __webpack_require__(/*! ../Components/index */ "./src/Implementations/Components/index.ts");\nconst Type_1 = __webpack_require__(/*! ../Components/Type */ "./src/Implementations/Components/Type.ts");\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ../Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nfunction visitDivision(visitor, ctx) {\n    // TODO: Add value\n    // Must be done between two possible integers\n    const [leftChild, rightChild] = ctx.expression();\n    const intTable = visitor.findTable(Integer_type_1.default.Name).copy();\n    const leftElement = visitor.visit(leftChild);\n    const rightElement = visitor.visit(rightChild);\n    const lExpr = (0, Type_1.extractTypeComponent)(leftElement);\n    const rExpr = (0, Type_1.extractTypeComponent)(rightElement);\n    if (!lExpr || !rExpr) {\n        visitor.addError(ctx, `One of the expressions is not a type`);\n        return new index_1.EmptyComponent();\n    }\n    const allowedComparison = lExpr.allowsComparisonTo(rExpr);\n    // ERROR: If one of them is an ancestor of the other, they can be compared\n    if (!allowedComparison) {\n        visitor.addError(ctx, `Invalid Comparison: ${leftChild.toString()} = ${rightChild.toString()}`);\n        return new index_1.EmptyComponent();\n    }\n    // Quadruplet\n    // const quadrupletElement = new DivOperation();\n    // const lValueComponent = extractQuadruplet(leftElement);\n    // const rValueComponent = extractQuadruplet(rightElement);\n    // quadrupletElement.elements = [lValueComponent, rValueComponent];\n    // intTable.addComponent(quadrupletElement);\n    // visitor.addQuadruple(quadrupletElement);\n    return intTable;\n}\nexports["default"] = visitDivision;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/division.ts?')},"./src/Implementations/visitorFunctions/equal.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst EmptyComponent_1 = __importDefault(__webpack_require__(/*! ../Components/EmptyComponent */ "./src/Implementations/Components/EmptyComponent.ts"));\nconst Type_1 = __webpack_require__(/*! ../Components/Type */ "./src/Implementations/Components/Type.ts");\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ../Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nfunction visitEqual(visitor, ctx) {\n    // TODO: Add value\n    // Must be done between two possible integers\n    const [leftChild, rightChild] = ctx.expression();\n    const boolTable = visitor.findTable(Boolean_type_1.default.Name).copy();\n    const lExpr = (0, Type_1.extractTypeComponent)(visitor.visit(leftChild));\n    const rExpr = (0, Type_1.extractTypeComponent)(visitor.visit(rightChild));\n    if (!lExpr || !rExpr) {\n        visitor.addError(ctx, `One of the expressions is not a type`);\n        return new EmptyComponent_1.default();\n    }\n    const allowedComparison = lExpr.allowsComparisonTo(rExpr);\n    // ERROR: If one of them is an ancestor of the other, they can be compared\n    if (!allowedComparison) {\n        visitor.addError(ctx, `Invalid Comparison: ${leftChild.toString()} = ${rightChild.toString()}`);\n        return new EmptyComponent_1.default();\n    }\n    return boolTable;\n}\nexports["default"] = visitEqual;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/equal.ts?')},"./src/Implementations/visitorFunctions/false.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst ValueHolder_1 = __importDefault(__webpack_require__(/*! ../Components/ValueHolder */ "./src/Implementations/Components/ValueHolder.ts"));\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ../Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nfunction visitFalse(_visitor, _ctx) {\n    const newBool = new Boolean_type_1.default();\n    const boolValue = new ValueHolder_1.default({ value: 0 });\n    newBool.addComponent(boolValue);\n    /*\n    Why does this component not have a quadrupleElement representation, you ask?\n      1. It holds no memory representation.\n      2. It can be hardcoded.\n      3. It is a terminal node that holds no variable value, such as Integers and Strings\n     */\n    return newBool;\n}\nexports["default"] = visitFalse;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/false.ts?')},"./src/Implementations/visitorFunctions/formal.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst EmptyComponent_1 = __importDefault(__webpack_require__(/*! ../Components/EmptyComponent */ "./src/Implementations/Components/EmptyComponent.ts"));\nconst SymbolElement_1 = __importDefault(__webpack_require__(/*! ../DataStructures/TableElements/SymbolElement */ "./src/Implementations/DataStructures/TableElements/SymbolElement.ts"));\nconst meta_1 = __webpack_require__(/*! ./meta */ "./src/Implementations/visitorFunctions/meta.ts");\nfunction visitFormal(visitor, ctx) {\n    const paramName = ctx.IDENTIFIER();\n    const dataType = ctx.TYPE();\n    const foundTable = visitor.findTable(dataType)?.copy();\n    // ERROR: The type is not yet defined\n    if (!foundTable) {\n        visitor.addError(ctx, `Type ${dataType.text} is not (yet?) defined`);\n        return new EmptyComponent_1.default();\n    }\n    const newSymbol = new SymbolElement_1.default({\n        name: paramName.text,\n        type: foundTable,\n        scopeName: visitor.getCurrentScope().getName(),\n        ...(0, meta_1.lineAndColumn)(ctx), // TODO: Add pass-by-reference or pass-by-value logic with memory addresses\n    });\n    return newSymbol;\n}\nexports["default"] = visitFormal;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/formal.ts?')},"./src/Implementations/visitorFunctions/id.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Components_1 = __webpack_require__(/*! ../Components */ "./src/Implementations/Components/index.ts");\nconst EmptyComponent_1 = __importDefault(__webpack_require__(/*! ../Components/EmptyComponent */ "./src/Implementations/Components/EmptyComponent.ts"));\nconst SimpleHolder_1 = __importDefault(__webpack_require__(/*! ../Components/Quadruple/SimpleHolder */ "./src/Implementations/Components/Quadruple/SimpleHolder.ts"));\nfunction visitId(visitor, ctx) {\n    // Find it in the scope\n    const name = ctx.IDENTIFIER();\n    const currentScope = visitor.getCurrentScope();\n    if (name.text.toLocaleLowerCase() === \'self\') {\n        return currentScope;\n    }\n    const tableComponent = (0, Components_1.extractTableComponent)(currentScope);\n    if (!tableComponent) {\n        return new EmptyComponent_1.default();\n    }\n    const foundComponent = tableComponent.get(name.text);\n    if (!foundComponent) {\n        const basicInfo = (0, Components_1.extractBasicInformation)(currentScope);\n        visitor.addError(ctx, `Symbol \'${name.toString()}\' is not defined in scope \'${basicInfo.name}\'`);\n        return new EmptyComponent_1.default();\n    }\n    const previousQuadruplet = (0, Components_1.extractQuadruplet)(foundComponent);\n    const quadrupletElement = previousQuadruplet ?? new SimpleHolder_1.default();\n    quadrupletElement.setValue(foundComponent);\n    if (!previousQuadruplet) {\n        foundComponent.addComponent(quadrupletElement);\n    }\n    // visitor.addQuadruple(quadrupletElement)\n    return foundComponent;\n}\nexports["default"] = visitId;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/id.ts?')},"./src/Implementations/visitorFunctions/if.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ../Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nfunction visitIf(visitor, ctx) {\n    // Empty bodies are disallowed by the parser in itself\n    const [condition, body, elses] = ctx.expression();\n    const boolTable = visitor.findTable(Boolean_type_1.default.Name);\n    const conditionType = visitor.visit(condition);\n    // ERROR: Condition can\'t be resolved to boolean\n    if (!boolTable.allowsAssignmentOf(conditionType)) {\n        visitor.addError(ctx, `Condition in if statement can\'t be resolved to boolean (got ${conditionType.tableName})`);\n    }\n    const thisIfType = visitor.visit(body);\n    const elseBodiesType = visitor.visit(elses);\n    // ERROR: If and else bodies don\'t have the same type\n    const allowsAssignment = thisIfType.allowsAssignmentOf(elseBodiesType);\n    if (!allowsAssignment) {\n        visitor.addError(ctx, `If and else bodies don\'t have the same type (got ${thisIfType.tableName} and ${elseBodiesType.tableName})`);\n    }\n    return thisIfType;\n}\nexports["default"] = visitIf;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/if.ts?')},"./src/Implementations/visitorFunctions/int.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst index_1 = __webpack_require__(/*! ../Components/index */ "./src/Implementations/Components/index.ts");\nconst SimpleHolder_1 = __importDefault(__webpack_require__(/*! ../Components/Quadruple/SimpleHolder */ "./src/Implementations/Components/Quadruple/SimpleHolder.ts"));\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ../Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nfunction visitInt(visitor, ctx) {\n    const newInt = new Integer_type_1.default();\n    newInt.addComponent(new index_1.ValueComponent({ value: parseInt(ctx.INT().text) }));\n    const quadrupletElement = new SimpleHolder_1.default();\n    quadrupletElement.setValue(parseInt(ctx.INT().text));\n    newInt.addComponent(quadrupletElement);\n    // visitor.addQuadruple(quadrupletElement)\n    return newInt;\n}\nexports["default"] = visitInt;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/int.ts?')},"./src/Implementations/visitorFunctions/isVoid.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Object_type_1 = __webpack_require__(/*! ../Generics/Object.type */ "./src/Implementations/Generics/Object.type.ts");\nfunction visitIsvoid(visitor, ctx) {\n    const expressionRaw = ctx.expression();\n    const expressionType = visitor.visit(expressionRaw);\n    // ERROR: Something that can\'t be instantiated can\'t be void\n    if (![Object_type_1.ClassType.Name, Object_type_1.ObjectType.Name].includes(expressionType.componentName)) {\n        visitor.addError(ctx, `Something of type ${expressionType.componentName} can\'t be void (Make sure it can be instantiated with \'new\')`);\n    }\n    return expressionType;\n}\nexports["default"] = visitIsvoid;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/isVoid.ts?')},"./src/Implementations/visitorFunctions/lessEqual.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst EmptyComponent_1 = __importDefault(__webpack_require__(/*! ../Components/EmptyComponent */ "./src/Implementations/Components/EmptyComponent.ts"));\nconst Type_1 = __webpack_require__(/*! ../Components/Type */ "./src/Implementations/Components/Type.ts");\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ../Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nfunction visitLessEqual(visitor, ctx) {\n    // Must be done between two possible integers\n    // TODO: Add value\n    const [leftChild, rightChild] = ctx.expression();\n    const boolTable = visitor.findTable(Boolean_type_1.default.Name).copy();\n    const lExpr = (0, Type_1.extractTypeComponent)(visitor.visit(leftChild));\n    const rExpr = (0, Type_1.extractTypeComponent)(visitor.visit(rightChild));\n    if (!lExpr || !rExpr) {\n        visitor.addError(ctx, `One of the expressions is not a type`);\n        return new EmptyComponent_1.default();\n    }\n    const allowedComparison = lExpr.allowsComparisonTo(rExpr);\n    // ERROR: If one of them is an ancestor of the other, they can be compared\n    if (!allowedComparison) {\n        visitor.addError(ctx, `Invalid Comparison: ${leftChild.toString()} = ${rightChild.toString()}`);\n        return new EmptyComponent_1.default();\n    }\n    return boolTable;\n}\nexports["default"] = visitLessEqual;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/lessEqual.ts?')},"./src/Implementations/visitorFunctions/lessThan.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst EmptyComponent_1 = __importDefault(__webpack_require__(/*! ../Components/EmptyComponent */ "./src/Implementations/Components/EmptyComponent.ts"));\nconst Type_1 = __webpack_require__(/*! ../Components/Type */ "./src/Implementations/Components/Type.ts");\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ../Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nfunction visitLessThan(visitor, ctx) {\n    // TODO: Add value\n    // Must be done between two possible integers\n    const [leftChild, rightChild] = ctx.expression();\n    const boolTable = visitor.findTable(Boolean_type_1.default.Name).copy();\n    const lExpr = (0, Type_1.extractTypeComponent)(visitor.visit(leftChild));\n    const rExpr = (0, Type_1.extractTypeComponent)(visitor.visit(rightChild));\n    if (!lExpr || !rExpr) {\n        visitor.addError(ctx, `One of the expressions is not a type`);\n        return new EmptyComponent_1.default();\n    }\n    const allowedComparison = lExpr.allowsComparisonTo(rExpr);\n    // ERROR: If one of them is an ancestor of the other, they can be compared\n    if (!allowedComparison) {\n        visitor.addError(ctx, `Invalid Comparison: ${leftChild.toString()} = ${rightChild.toString()}`);\n        return new EmptyComponent_1.default();\n    }\n    return boolTable;\n}\nexports["default"] = visitLessThan;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/lessThan.ts?')},"./src/Implementations/visitorFunctions/letin.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Table_1 = __webpack_require__(/*! ../Components/Table */ "./src/Implementations/Components/Table.ts");\nconst MethodElement_1 = __importDefault(__webpack_require__(/*! ../DataStructures/TableElements/MethodElement */ "./src/Implementations/DataStructures/TableElements/MethodElement.ts"));\nconst Object_type_1 = __webpack_require__(/*! ../Generics/Object.type */ "./src/Implementations/Generics/Object.type.ts");\nfunction visitLetIn(visitor, ctx) {\n    // const assignment = ctx.ASSIGNMENT();\n    // const expressions = ctx.expression().slice(0, -1);\n    // const expression = ctx.expression().slice(-1)\n    // const identifiers = ctx.IDENTIFIER();\n    // const expressionsRaw = ctx.expression();\n    // visitor.visit(identifiers[0])\n    // // const assignments =\n    const methodComponent = new MethodElement_1.default({\n        scopeName: \'letIn\',\n        name: \'leIn\',\n        type: new Object_type_1.ClassType({ name: \'letIn\', context: ctx }),\n    });\n    (0, Table_1.extractTableComponent)(methodComponent).parent = visitor.getCurrentScope();\n    visitor.scopeStack.push(methodComponent);\n    const assignments = ctx.assignmentExpr();\n    const expression = ctx.expression();\n    for (const assignment of assignments) {\n        const result = visitor.visit(assignment);\n    }\n    const result = visitor.visit(expression);\n    visitor.scopeStack.pop();\n    return result;\n    // for (const identifier of identifiers) {\n    // const result = visitor.visit()\n    // }\n}\nexports["default"] = visitLetIn;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/letin.ts?')},"./src/Implementations/visitorFunctions/meta.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ScopePosition = exports.Scope = exports.lineAndColumn = void 0;\nconst lineAndColumn = (ctx) => ({\n    line: ctx.start?.line ?? 0,\n    column: ctx.start?.charPositionInLine ?? 0,\n});\nexports.lineAndColumn = lineAndColumn;\nvar Scope;\n(function (Scope) {\n    Scope[Scope["Global"] = 1] = "Global";\n    Scope[Scope["General"] = 2] = "General";\n})(Scope = exports.Scope || (exports.Scope = {}));\nvar ScopePosition;\n(function (ScopePosition) {\n    ScopePosition[ScopePosition["Global"] = 0] = "Global";\n    ScopePosition[ScopePosition["Class"] = 1] = "Class";\n    ScopePosition[ScopePosition["Method"] = 2] = "Method";\n})(ScopePosition = exports.ScopePosition || (exports.ScopePosition = {}));\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/meta.ts?')},"./src/Implementations/visitorFunctions/method.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst ContextHolder_1 = __importDefault(__webpack_require__(/*! ../Components/ContextHolder */ "./src/Implementations/Components/ContextHolder.ts"));\nconst Table_1 = __webpack_require__(/*! ../Components/Table */ "./src/Implementations/Components/Table.ts");\nconst Type_1 = __webpack_require__(/*! ../Components/Type */ "./src/Implementations/Components/Type.ts");\nconst MethodElement_1 = __importDefault(__webpack_require__(/*! ../DataStructures/TableElements/MethodElement */ "./src/Implementations/DataStructures/TableElements/MethodElement.ts"));\nconst meta_1 = __webpack_require__(/*! ./meta */ "./src/Implementations/visitorFunctions/meta.ts");\nfunction visitMethod(visitor, ctx) {\n    const methodName = ctx.IDENTIFIER().text;\n    const methodExpectedType = ctx.TYPE();\n    const methodBody = ctx.expression();\n    const methodTable = methodExpectedType.text === \'SELF_TYPE\' ? visitor.getCurrentScope() : visitor.findTable(methodExpectedType);\n    const methodType = (0, Type_1.extractTypeComponent)(methodTable);\n    // ERROR: The method type is not yet defined (if ever)\n    if (!methodType) {\n        visitor.addError(ctx, `Method type ${methodExpectedType.toString()} is not defined`);\n        return visitor.next(ctx);\n    }\n    const newMethod = new MethodElement_1.default({\n        name: methodName,\n        type: methodType,\n        scopeName: visitor.getCurrentScope().getName() ?? \'Unknown name\',\n        ...(0, meta_1.lineAndColumn)(ctx),\n        memoryAddress: -1,\n    });\n    const methodContext = newMethod.getComponent({ componentType: ContextHolder_1.default.Type });\n    methodContext?.setContext(ctx);\n    const currentTable = visitor.getCurrentScope();\n    const classTableComponent = (0, Table_1.extractTableComponent)(currentTable);\n    const methodTableComponent = (0, Table_1.extractTableComponent)(newMethod);\n    methodTableComponent.parent = classTableComponent;\n    visitor.scopeStack.push(newMethod);\n    // If it doesn\'t exist, it is a syntax error\n    const formalParameters = ctx.formal();\n    for (const param of formalParameters) {\n        const newParam = visitor.visit(param);\n        newMethod.addParameters(newParam);\n    }\n    const expressionResultRaw = visitor.visit(methodBody);\n    const expressionResult = Array.isArray(expressionResultRaw) ? expressionResultRaw[0] : expressionResultRaw;\n    const expressionType = (0, Type_1.extractTypeComponent)(expressionResult);\n    // ERROR: If the expression is not valid, an empty component is returned, and no type will be found\n    if (!expressionType) {\n        visitor.addError(ctx, `Expected expression to return \'${methodExpectedType.text}\' inside method \'${methodName}\'`);\n        return visitor.next(ctx);\n    }\n    const canBeAssigned = methodType.allowsAssignmentOf(expressionType);\n    // ERROR: Last child and return type do not match or can\'t be assigned\n    if (!canBeAssigned) {\n        visitor.addError(ctx, `Cannot assign ${expressionType.componentName} to method of type ${methodType.componentName}`);\n        return visitor.next(ctx);\n    }\n    visitor.scopeStack.pop();\n    classTableComponent.add(newMethod);\n    return methodType;\n}\nexports["default"] = visitMethod;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/method.ts?')},"./src/Implementations/visitorFunctions/methodCall.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Components_1 = __webpack_require__(/*! ../Components */ \"./src/Implementations/Components/index.ts\");\nfunction visitMethodCall(visitor, ctx) {\n    const [calledVariable, ...parameters] = ctx.expression();\n    const methodName = ctx.IDENTIFIER();\n    const methodType = ctx.TYPE();\n    const callingClass = visitor.getCurrentScope();\n    const callingClassTable = (0, Components_1.extractTableComponent)(callingClass);\n    const callingVariable = callingClassTable.get(calledVariable.text);\n    const referencedClass = (0, Components_1.extractTypeComponent)(callingVariable);\n    const referencedClassTable = (0, Components_1.extractTableComponent)(referencedClass);\n    let referencedMethod = referencedClassTable?.get(methodName.text);\n    let referencedMethodType = (0, Components_1.extractTypeComponent)(referencedMethod);\n    if (methodType && methodType.text !== referencedClass.getName()) {\n        const referencedMethodParentClass = visitor.findTable(methodType);\n        if (!referencedMethodParentClass) {\n            visitor.addError(ctx, `Class '${methodType.text}' is not defined`);\n            return new Components_1.EmptyComponent();\n        }\n        const hasAccessTo = referencedClass.inheritsFrom(referencedMethodParentClass);\n        if (!hasAccessTo) {\n            visitor.addError(ctx, `Method ${methodName.text} is not accessible to class ${methodType.text}`);\n            return new Components_1.EmptyComponent();\n        }\n        const referencedMethodParentClassTable = (0, Components_1.extractTableComponent)(referencedMethodParentClass);\n        referencedMethod = referencedMethodParentClassTable?.get(methodName.text);\n        referencedMethodType = (0, Components_1.extractTypeComponent)(referencedMethod);\n    }\n    if (!referencedMethod) {\n        visitor.addError(ctx, `Method '${methodName.text}' is not defined in class '${referencedClass.getName()}'`);\n        return new Components_1.EmptyComponent();\n    }\n    const paramNum = parameters.length;\n    const requiredParams = (0, Components_1.extractTableComponent)(referencedMethod).getAll();\n    const requiredParamsNum = requiredParams.length;\n    if (paramNum !== requiredParamsNum) {\n        visitor.addError(ctx, `Incorrect number of parameters (expected ${requiredParamsNum} but found ${paramNum})`);\n        return visitor.next(ctx);\n    }\n    for (let i = 0; i < paramNum; ++i) {\n        const param = visitor.visit(parameters[i]);\n        const requiredParam = requiredParams[i];\n        const givenParamType = (0, Components_1.extractTypeComponent)(param);\n        const requiredParamType = (0, Components_1.extractTypeComponent)(requiredParam);\n        if (!givenParamType) {\n            visitor.addError(ctx, `Can't resolve type of ${parameters[i].text}`);\n            continue;\n        }\n        if (!requiredParamType.allowsAssignmentOf(givenParamType)) {\n            visitor.addError(ctx, `Can't assign parameter type`);\n        }\n    }\n    // const methodHolderClassName = ctx.TYPE() ?? currentVariableType.getName();\n    return referencedMethodType;\n    // const methodHolderClassName = ctx.TYPE()!;\n    // const methodName = ctx.IDENTIFIER();\n    // const [calledVariable, ...parameters] = ctx.expression();\n    // const currentMethod = visitor.getCurrentScope(ScopePosition.Method) as MethodElement;\n    // const currentClass = visitor.getCurrentScope(ScopePosition.Class) as ClassType;\n    // const classThatHoldsMethod = visitor.findTable(methodHolderClassName);\n    // if (!classThatHoldsMethod) {\n    //   visitor.addError(ctx, `Trying to access non-existent class ${methodHolderClassName.text}`);\n    //   return visitor.next(ctx);\n    // }\n    // const allowsAssignmentOf = classThatHoldsMethod.allowsAssignmentOf(currentClass);\n    // if (!allowsAssignmentOf) {\n    //   visitor.addError(\n    //     ctx,\n    //     `${currentClass.toString()} is trying to access non-inherited class ${classThatHoldsMethod.toString()}`,\n    //   );\n    //   return visitor.next(ctx);\n    // }\n    // // Get the type of the gotten variable\n    // const varType = extractTypeComponent(classThatHoldsMethod.getTable().get(calledVariable.text));\n    // if (!varType) {\n    //   visitor.addError(ctx, `Could not find ${calledVariable.text}`);\n    //   return visitor.next(ctx);\n    // }\n    // const originalClassTable = extractTableComponent(varType);\n    // const referencedMethodInOriginalClass = extractTableComponent(originalClassTable?.get(methodName.text));\n    // if (!referencedMethodInOriginalClass) {\n    //   visitor.addError(ctx, `Could not find method ${methodName.text} in desired class`);\n    //   return visitor.next(ctx);\n    // }\n    // return extractTypeComponent(referencedMethodInOriginalClass)!;\n}\nexports[\"default\"] = visitMethodCall;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/methodCall.ts?")},"./src/Implementations/visitorFunctions/minus.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst index_1 = __webpack_require__(/*! ../Components/index */ "./src/Implementations/Components/index.ts");\nconst SubOperation_1 = __importDefault(__webpack_require__(/*! ../Components/Quadruple/SubOperation */ "./src/Implementations/Components/Quadruple/SubOperation.ts"));\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ../Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nfunction visitMinus(visitor, ctx) {\n    const [leftChild, rightChild] = ctx.expression();\n    const intTable = visitor.findTable(Integer_type_1.default.Name).copy();\n    const leftElement = visitor.visit(leftChild);\n    const rightElement = visitor.visit(rightChild);\n    const lExpr = (0, index_1.extractTypeComponent)(leftElement);\n    const rExpr = (0, index_1.extractTypeComponent)(rightElement);\n    if (!lExpr || !rExpr) {\n        visitor.addError(ctx, `One of the expressions is not a type`);\n        return new index_1.EmptyComponent();\n    }\n    const allowedComparison = lExpr.allowsComparisonTo(rExpr);\n    // ERROR: If one of them is an ancestor of the other, they can be compared\n    if (!allowedComparison) {\n        visitor.addError(ctx, `Invalid Comparison: ${leftChild.toString()} = ${rightChild.toString()}`);\n        return new index_1.EmptyComponent();\n    }\n    // Quadruplet\n    const quadrupletElement = new SubOperation_1.default();\n    const lValueComponent = (0, index_1.extractQuadruplet)(leftElement);\n    const rValueComponent = (0, index_1.extractQuadruplet)(rightElement);\n    quadrupletElement.elements = [lValueComponent, rValueComponent];\n    intTable.addComponent(quadrupletElement);\n    // visitor.addQuadruple(quadrupletElement);\n    return intTable;\n}\nexports["default"] = visitMinus;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/minus.ts?')},"./src/Implementations/visitorFunctions/multiply.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst index_1 = __webpack_require__(/*! ../Components/index */ "./src/Implementations/Components/index.ts");\nconst MultOperation_1 = __importDefault(__webpack_require__(/*! ../Components/Quadruple/MultOperation */ "./src/Implementations/Components/Quadruple/MultOperation.ts"));\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ../Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nfunction visitMultiply(visitor, ctx) {\n    const [leftChild, rightChild] = ctx.expression();\n    const intTable = visitor.findTable(Integer_type_1.default.Name).copy();\n    const leftElement = visitor.visit(leftChild);\n    const rightElement = visitor.visit(rightChild);\n    const lExpr = (0, index_1.extractTypeComponent)(leftElement);\n    const rExpr = (0, index_1.extractTypeComponent)(rightElement);\n    if (!lExpr || !rExpr) {\n        visitor.addError(ctx, `One of the expressions is not a type`);\n        return new index_1.EmptyComponent();\n    }\n    const allowedComparison = lExpr.allowsComparisonTo(rExpr);\n    // ERROR: If one of them is an ancestor of the other, they can be compared\n    if (!allowedComparison) {\n        visitor.addError(ctx, `Invalid Comparison: ${leftChild.toString()} = ${rightChild.toString()}`);\n        return new index_1.EmptyComponent();\n    }\n    // Quadruplet\n    const quadrupletElement = new MultOperation_1.default();\n    const lValueComponent = (0, index_1.extractQuadruplet)(leftElement);\n    const rValueComponent = (0, index_1.extractQuadruplet)(rightElement);\n    quadrupletElement.elements = [lValueComponent, rValueComponent];\n    intTable.addComponent(quadrupletElement);\n    // visitor.addQuadruple(quadrupletElement);\n    return intTable;\n}\nexports["default"] = visitMultiply;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/multiply.ts?')},"./src/Implementations/visitorFunctions/negative.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst BasicInformation_1 = __webpack_require__(/*! ../Components/BasicInformation */ "./src/Implementations/Components/BasicInformation.ts");\nfunction visitNegative(visitor, ctx) {\n    const expressionRaw = ctx.expression();\n    const expressionType = visitor.visit(expressionRaw);\n    const basicInformationComponent = (0, BasicInformation_1.extractBasicInformation)(expressionType);\n    if (!basicInformationComponent) {\n        throw new Error(\'Semantic bug: expression type does not have basic information\');\n    }\n    // ERROR: Expression can\'t be negated\n    if (!expressionType.allowsNegation) {\n        visitor.addError(ctx, `Expression ${basicInformationComponent.getName()} of type ${expressionType.componentType} can\'t be negated`);\n    }\n    return expressionType;\n}\nexports["default"] = visitNegative;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/negative.ts?')},"./src/Implementations/visitorFunctions/new.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst EmptyComponent_1 = __importDefault(__webpack_require__(/*! ../Components/EmptyComponent */ "./src/Implementations/Components/EmptyComponent.ts"));\nfunction visitNew(visitor, ctx) {\n    const instantiationOf = ctx.TYPE();\n    const currentClass = visitor.getCurrentScope();\n    const currentClassBasicComponent = currentClass.getBasicInfo();\n    const instantiatingClass = visitor.findTable(instantiationOf.text);\n    const instantiatingType = instantiatingClass?.getType();\n    const instantiatingBasicComponent = instantiatingClass?.getBasicInfo();\n    if (!instantiatingType) {\n        visitor.addError(ctx, `Cannot instantiate non-existing class ${instantiationOf.text}`);\n        return new EmptyComponent_1.default();\n    }\n    else if (!instantiatingBasicComponent) {\n        throw new Error(\'Bug! Instantiating class has no basic info component\');\n    }\n    else if (currentClassBasicComponent?.getName() === instantiatingBasicComponent.getName()) {\n        visitor.addError(ctx, `Attempting to instantiate ${currentClassBasicComponent?.getName()} inside itself`);\n        return new EmptyComponent_1.default();\n    }\n    return instantiatingClass;\n}\nexports["default"] = visitNew;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/new.ts?')},"./src/Implementations/visitorFunctions/ownMethodCall.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst BasicInformation_1 = __webpack_require__(/*! ../Components/BasicInformation */ "./src/Implementations/Components/BasicInformation.ts");\nconst Table_1 = __webpack_require__(/*! ../Components/Table */ "./src/Implementations/Components/Table.ts");\nconst Type_1 = __webpack_require__(/*! ../Components/Type */ "./src/Implementations/Components/Type.ts");\nfunction visitOwnMethodCall(visitor, ctx) {\n    const methodIdentifier = ctx.IDENTIFIER();\n    const [...methodParametersRaw] = ctx.expression();\n    const methodParameters = methodParametersRaw.map((p) => visitor.visit(p));\n    const methodHoldingClass = visitor.getCurrentScope();\n    const methodHoldingClassTable = (0, Table_1.extractTableComponent)(methodHoldingClass);\n    const referencedMethod = methodHoldingClassTable.get(methodIdentifier);\n    // ERROR: The method does not exist in the class (self or not)\n    if (!referencedMethod) {\n        const methodHoldingClassName = (0, BasicInformation_1.extractBasicInformation)(methodHoldingClassTable)?.getName();\n        visitor.addError(ctx, `Attempting to call non-existing method ${methodIdentifier.toString()} from class ${methodHoldingClassName}`);\n        return visitor.next(ctx);\n    }\n    const requiredMethodParameters = referencedMethod.getParameters();\n    const sameNumberOfParameters = requiredMethodParameters.length === methodParameters.length;\n    // ERROR: The method is called with a different number of parameters than it requires\n    if (!sameNumberOfParameters) {\n        const methodHoldingClassName = (0, BasicInformation_1.extractBasicInformation)(methodHoldingClassTable)?.getName();\n        visitor.addError(ctx, `Incorrect number of parameters for method ${methodIdentifier.toString()} from class ${methodHoldingClassName} (expected ${requiredMethodParameters.length}, got ${methodParameters.length})`);\n        return visitor.next(ctx);\n    }\n    for (let i = 0; i < requiredMethodParameters.length; i++) {\n        const requiredParameterType = (0, Type_1.extractTypeComponent)(requiredMethodParameters[i]);\n        const methodParameterType = methodParameters[i];\n        const allowed = requiredParameterType.allowsAssignmentOf(methodParameterType);\n        // ERROR: The parameter required is not the same as the one passed\n        if (!allowed) {\n            visitor.addError(ctx, `Incorrect type of parameter ${requiredMethodParameters[i].getName()} for method ${methodIdentifier.toString()} from class ${methodHoldingClass.getName()}`);\n        }\n    }\n    return referencedMethod;\n}\nexports["default"] = visitOwnMethodCall;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/ownMethodCall.ts?')},"./src/Implementations/visitorFunctions/parentheses.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nfunction visitParentheses(visitor, ctx) {\n    return visitor.visit(ctx.expression());\n}\nexports["default"] = visitParentheses;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/parentheses.ts?')},"./src/Implementations/visitorFunctions/property.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst Components_1 = __webpack_require__(/*! ../Components */ "./src/Implementations/Components/index.ts");\nconst SimpleAssignment_1 = __importDefault(__webpack_require__(/*! ../Components/Quadruple/SimpleAssignment */ "./src/Implementations/Components/Quadruple/SimpleAssignment.ts"));\nconst SymbolElement_1 = __importDefault(__webpack_require__(/*! ../DataStructures/TableElements/SymbolElement */ "./src/Implementations/DataStructures/TableElements/SymbolElement.ts"));\nconst meta_1 = __webpack_require__(/*! ./meta */ "./src/Implementations/visitorFunctions/meta.ts");\nfunction visitProperty(visitor, ctx) {\n    // Previous table\n    const propertyName = ctx.IDENTIFIER();\n    const propertyType = ctx.TYPE();\n    const propertyAssignmentExpression = ctx.expression();\n    const propertyTypeClass = visitor.findTable(propertyType);\n    const currentScope = visitor.getCurrentScope();\n    // ERROR: The type is not yet defined\n    if (!propertyTypeClass) {\n        visitor.addError(ctx, `Type ${propertyType.text} is not (yet?) defined`);\n        return visitor.next(ctx);\n    }\n    const newTableElement = new SymbolElement_1.default({\n        name: propertyName.text,\n        type: propertyTypeClass,\n        scopeName: (currentScope.getName || (0, Components_1.extractBasicInformation)(currentScope).getName)(),\n        ...(0, meta_1.lineAndColumn)(ctx),\n    });\n    newTableElement.setAddress(currentScope.getSize());\n    const currentScopeTable = (0, Components_1.extractTableComponent)(currentScope);\n    const previousDeclared = currentScopeTable.get(propertyName.text, { inCurrentScope: true });\n    // // Case 1: Overriding (It does nothing)\n    if (previousDeclared) {\n        visitor.addError(ctx, `Property ${propertyName.text} is already declared in ${currentScope.toString()}`);\n        return visitor.next(ctx);\n    }\n    const simpleAssignment = new SimpleAssignment_1.default();\n    if (propertyAssignmentExpression) {\n        const assignmentResolvesTo = visitor.visit(propertyAssignmentExpression);\n        const acceptsAssignment = propertyTypeClass.allowsAssignmentOf(assignmentResolvesTo);\n        // ERROR: Not allowed an assignment and the assignment is not to an ancestor\n        if (!acceptsAssignment) {\n            // TODO: Fix visitor\n            visitor.addError(ctx, `Cannot assign ${assignmentResolvesTo?.componentName ?? \'erroneous class\'} to ${propertyTypeClass.componentName} (Can\'t assign type ${assignmentResolvesTo?.componentName ?? \'\'} to ${propertyTypeClass.componentName})`);\n            return visitor.next(ctx);\n        }\n        const valueHolder = (0, Components_1.extractValueComponent)(assignmentResolvesTo);\n        newTableElement.addComponent(valueHolder?.copy());\n        const resolvingToAssignment = (0, Components_1.extractQuadruplet)(assignmentResolvesTo);\n        simpleAssignment.setValue(resolvingToAssignment);\n        simpleAssignment.setAssigningTo(newTableElement);\n        // visitor.addQuadruple(simpleAssignment);\n    }\n    else {\n        simpleAssignment.setValue(propertyTypeClass.defaultValue);\n        simpleAssignment.setAssigningTo(newTableElement);\n        // visitor.addQuadruple(simpleAssignment);\n        newTableElement.addComponent(new Components_1.ValueComponent({ value: propertyTypeClass.defaultValue }));\n    }\n    // Case 2: Declaration of a new property\n    currentScopeTable.add(newTableElement);\n    return visitor.next(ctx);\n}\nexports["default"] = visitProperty;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/property.ts?')},"./src/Implementations/visitorFunctions/string.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst ValueHolder_1 = __importDefault(__webpack_require__(/*! ../Components/ValueHolder */ "./src/Implementations/Components/ValueHolder.ts"));\nconst String_type_1 = __importDefault(__webpack_require__(/*! ../Generics/String.type */ "./src/Implementations/Generics/String.type.ts"));\nfunction visitString(visitor, ctx) {\n    const newString = new String_type_1.default();\n    const stringValue = new ValueHolder_1.default({ value: ctx.STRING().text });\n    newString.addComponent(stringValue);\n    /*\n    Why does this component not have a quadrupleElement representation, you ask?\n      1. It holds no memory representation.\n      2. It can be hardcoded.\n      3. It is a terminal node that holds no variable value, such as Integers and Booleans\n    */\n    return newString;\n}\nexports["default"] = visitString;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/string.ts?')},"./src/Implementations/visitorFunctions/true.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst ValueHolder_1 = __importDefault(__webpack_require__(/*! ../Components/ValueHolder */ "./src/Implementations/Components/ValueHolder.ts"));\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ../Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nfunction visitTrue(_visitor, _ctx) {\n    const newBool = new Boolean_type_1.default();\n    const boolValue = new ValueHolder_1.default({ value: 1 });\n    newBool.addComponent(boolValue);\n    /*\n    Why does this component not have a triplet representation, you ask?\n      1. It holds no memory representation.\n      2. It can be hardcoded.\n      3. It is a terminal node that holds no variable value, such as Integers and Strings\n     */\n    return newBool;\n}\nexports["default"] = visitTrue;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/true.ts?')},"./src/Implementations/visitorFunctions/while.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nfunction visitWhile(visitor, ctx) {\n    const [booleanExpression, subResult] = ctx.expression();\n    // There is no expression inside the while loop\n    if (!booleanExpression) {\n        return visitor.next(ctx);\n    }\n    const foundExpression = visitor.visit(booleanExpression);\n    const boolTable = visitor.findTable("Bool");\n    const allowsAssignment = boolTable.allowsAssignmentOf(foundExpression);\n    // ERROR: The expression inside the while loop cannot be set as a boolean expression\n    if (!allowsAssignment) {\n        visitor.addError(ctx, `Expression inside while loop cannot be set as a boolean expression (got ${foundExpression.tableName})`);\n        visitor.next(ctx);\n    }\n    return visitor.visit(subResult);\n}\nexports["default"] = visitWhile;\n\n\n//# sourceURL=webpack://proyecto2/./src/Implementations/visitorFunctions/while.ts?')},"./src/antlr/yaplLexer.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\n// Generated from yapl.g4 by ANTLR 4.9.0-SNAPSHOT\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.yaplLexer = void 0;\nconst ATNDeserializer_1 = __webpack_require__(/*! antlr4ts/atn/ATNDeserializer */ "antlr4ts/atn/ATNDeserializer");\nconst Lexer_1 = __webpack_require__(/*! antlr4ts/Lexer */ "antlr4ts/Lexer");\nconst LexerATNSimulator_1 = __webpack_require__(/*! antlr4ts/atn/LexerATNSimulator */ "antlr4ts/atn/LexerATNSimulator");\nconst VocabularyImpl_1 = __webpack_require__(/*! antlr4ts/VocabularyImpl */ "antlr4ts/VocabularyImpl");\nconst Utils = __importStar(__webpack_require__(/*! antlr4ts/misc/Utils */ "antlr4ts/misc/Utils"));\nclass yaplLexer extends Lexer_1.Lexer {\n    static T__0 = 1;\n    static T__1 = 2;\n    static T__2 = 3;\n    static T__3 = 4;\n    static T__4 = 5;\n    static T__5 = 6;\n    static T__6 = 7;\n    static T__7 = 8;\n    static T__8 = 9;\n    static CLASS = 10;\n    static ELSE = 11;\n    static FALSE = 12;\n    static FI = 13;\n    static IF = 14;\n    static IN = 15;\n    static INHERITS = 16;\n    static ISVOID = 17;\n    static LET = 18;\n    static LOOP = 19;\n    static POOL = 20;\n    static THEN = 21;\n    static WHILE = 22;\n    static CASE = 23;\n    static ESAC = 24;\n    static NEW = 25;\n    static OF = 26;\n    static TRUE = 27;\n    static STRING = 28;\n    static INT = 29;\n    static TYPE = 30;\n    static IDENTIFIER = 31;\n    static ASSIGNMENT = 32;\n    static CASE_ARROW = 33;\n    static ADD = 34;\n    static MINUS = 35;\n    static MULTIPLY = 36;\n    static DIVISION = 37;\n    static LESS_THAN = 38;\n    static LESS_EQUAL = 39;\n    static EQUAL = 40;\n    static INTEGER_NEGATIVE = 41;\n    static OPEN_COMMENT = 42;\n    static CLOSE_COMMENT = 43;\n    static COMMENT = 44;\n    static ONE_LINE_COMMENT = 45;\n    static WHITESPACE = 46;\n    // tslint:disable:no-trailing-whitespace\n    static channelNames = [\n        "DEFAULT_TOKEN_CHANNEL", "HIDDEN",\n    ];\n    // tslint:disable:no-trailing-whitespace\n    static modeNames = [\n        "DEFAULT_MODE",\n    ];\n    static ruleNames = [\n        "T__0", "T__1", "T__2", "T__3", "T__4", "T__5", "T__6", "T__7", "T__8",\n        "CLASS", "ELSE", "FALSE", "FI", "IF", "IN", "INHERITS", "ISVOID", "LET",\n        "LOOP", "POOL", "THEN", "WHILE", "CASE", "ESAC", "NEW", "OF", "TRUE",\n        "STRING", "INT", "TYPE", "IDENTIFIER", "ASSIGNMENT", "CASE_ARROW", "ADD",\n        "MINUS", "MULTIPLY", "DIVISION", "LESS_THAN", "LESS_EQUAL", "EQUAL", "INTEGER_NEGATIVE",\n        "A", "C", "D", "E", "F", "H", "I", "L", "N", "O", "P", "R", "S", "T",\n        "U", "V", "W", "ESC", "UNICODE", "HEX", "OPEN_COMMENT", "CLOSE_COMMENT",\n        "COMMENT", "ONE_LINE_COMMENT", "WHITESPACE",\n    ];\n    static _LITERAL_NAMES = [\n        undefined, "\';\'", "\'{\'", "\'}\'", "\'(\'", "\',\'", "\')\'", "\':\'", "\'@\'", "\'.\'",\n        undefined, undefined, "\'false\'", undefined, undefined, undefined, undefined,\n        undefined, undefined, undefined, undefined, undefined, undefined, undefined,\n        undefined, undefined, undefined, "\'true\'", undefined, undefined, undefined,\n        undefined, "\'<-\'", "\'=>\'", "\'+\'", "\'-\'", "\'*\'", "\'/\'", "\'<\'", "\'<=\'",\n        "\'=\'", "\'~\'", "\'(*\'", "\'*)\'",\n    ];\n    static _SYMBOLIC_NAMES = [\n        undefined, undefined, undefined, undefined, undefined, undefined, undefined,\n        undefined, undefined, undefined, "CLASS", "ELSE", "FALSE", "FI", "IF",\n        "IN", "INHERITS", "ISVOID", "LET", "LOOP", "POOL", "THEN", "WHILE", "CASE",\n        "ESAC", "NEW", "OF", "TRUE", "STRING", "INT", "TYPE", "IDENTIFIER", "ASSIGNMENT",\n        "CASE_ARROW", "ADD", "MINUS", "MULTIPLY", "DIVISION", "LESS_THAN", "LESS_EQUAL",\n        "EQUAL", "INTEGER_NEGATIVE", "OPEN_COMMENT", "CLOSE_COMMENT", "COMMENT",\n        "ONE_LINE_COMMENT", "WHITESPACE",\n    ];\n    static VOCABULARY = new VocabularyImpl_1.VocabularyImpl(yaplLexer._LITERAL_NAMES, yaplLexer._SYMBOLIC_NAMES, []);\n    // @Override\n    // @NotNull\n    get vocabulary() {\n        return yaplLexer.VOCABULARY;\n    }\n    // tslint:enable:no-trailing-whitespace\n    constructor(input) {\n        super(input);\n        this._interp = new LexerATNSimulator_1.LexerATNSimulator(yaplLexer._ATN, this);\n    }\n    // @Override\n    get grammarFileName() { return "yapl.g4"; }\n    // @Override\n    get ruleNames() { return yaplLexer.ruleNames; }\n    // @Override\n    get serializedATN() { return yaplLexer._serializedATN; }\n    // @Override\n    get channelNames() { return yaplLexer.channelNames; }\n    // @Override\n    get modeNames() { return yaplLexer.modeNames; }\n    static _serializedATN = "\\x03\\uC91D\\uCABA\\u058D\\uAFBA\\u4F53\\u0607\\uEA8B\\uC241\\x020\\u017C\\b\\x01" +\n        "\\x04\\x02\\t\\x02\\x04\\x03\\t\\x03\\x04\\x04\\t\\x04\\x04\\x05\\t\\x05\\x04\\x06\\t\\x06" +\n        "\\x04\\x07\\t\\x07\\x04\\b\\t\\b\\x04\\t\\t\\t\\x04\\n\\t\\n\\x04\\v\\t\\v\\x04\\f\\t\\f\\x04\\r" +\n        "\\t\\r\\x04\\x0E\\t\\x0E\\x04\\x0F\\t\\x0F\\x04\\x10\\t\\x10\\x04\\x11\\t\\x11\\x04\\x12\\t" +\n        "\\x12\\x04\\x13\\t\\x13\\x04\\x14\\t\\x14\\x04\\x15\\t\\x15\\x04\\x16\\t\\x16\\x04\\x17\\t" +\n        "\\x17\\x04\\x18\\t\\x18\\x04\\x19\\t\\x19\\x04\\x1A\\t\\x1A\\x04\\x1B\\t\\x1B\\x04\\x1C\\t" +\n        "\\x1C\\x04\\x1D\\t\\x1D\\x04\\x1E\\t\\x1E\\x04\\x1F\\t\\x1F\\x04 \\t \\x04!\\t!\\x04\\"\\t" +\n        "\\"\\x04#\\t#\\x04$\\t$\\x04%\\t%\\x04&\\t&\\x04\\\'\\t\\\'\\x04(\\t(\\x04)\\t)\\x04*\\t*\\x04" +\n        "+\\t+\\x04,\\t,\\x04-\\t-\\x04.\\t.\\x04/\\t/\\x040\\t0\\x041\\t1\\x042\\t2\\x043\\t3\\x04" +\n        "4\\t4\\x045\\t5\\x046\\t6\\x047\\t7\\x048\\t8\\x049\\t9\\x04:\\t:\\x04;\\t;\\x04<\\t<\\x04" +\n        "=\\t=\\x04>\\t>\\x04?\\t?\\x04@\\t@\\x04A\\tA\\x04B\\tB\\x04C\\tC\\x03\\x02\\x03\\x02\\x03" +\n        "\\x03\\x03\\x03\\x03\\x04\\x03\\x04\\x03\\x05\\x03\\x05\\x03\\x06\\x03\\x06\\x03\\x07\\x03" +\n        "\\x07\\x03\\b\\x03\\b\\x03\\t\\x03\\t\\x03\\n\\x03\\n\\x03\\v\\x03\\v\\x03\\v\\x03\\v\\x03\\v" +\n        "\\x03\\v\\x03\\f\\x03\\f\\x03\\f\\x03\\f\\x03\\f\\x03\\r\\x03\\r\\x03\\r\\x03\\r\\x03\\r\\x03" +\n        "\\r\\x03\\x0E\\x03\\x0E\\x03\\x0E\\x03\\x0F\\x03\\x0F\\x03\\x0F\\x03\\x10\\x03\\x10\\x03" +\n        "\\x10\\x03\\x11\\x03\\x11\\x03\\x11\\x03\\x11\\x03\\x11\\x03\\x11\\x03\\x11\\x03\\x11\\x03" +\n        "\\x11\\x03\\x12\\x03\\x12\\x03\\x12\\x03\\x12\\x03\\x12\\x03\\x12\\x03\\x12\\x03\\x13\\x03" +\n        "\\x13\\x03\\x13\\x03\\x13\\x03\\x14\\x03\\x14\\x03\\x14\\x03\\x14\\x03\\x14\\x03\\x15\\x03" +\n        "\\x15\\x03\\x15\\x03\\x15\\x03\\x15\\x03\\x16\\x03\\x16\\x03\\x16\\x03\\x16\\x03\\x16\\x03" +\n        "\\x17\\x03\\x17\\x03\\x17\\x03\\x17\\x03\\x17\\x03\\x17\\x03\\x18\\x03\\x18\\x03\\x18\\x03" +\n        "\\x18\\x03\\x18\\x03\\x19\\x03\\x19\\x03\\x19\\x03\\x19\\x03\\x19\\x03\\x1A\\x03\\x1A\\x03" +\n        "\\x1A\\x03\\x1A\\x03\\x1B\\x03\\x1B\\x03\\x1B\\x03\\x1C\\x03\\x1C\\x03\\x1C\\x03\\x1C\\x03" +\n        "\\x1C\\x03\\x1D\\x03\\x1D\\x03\\x1D\\x07\\x1D\\xF6\\n\\x1D\\f\\x1D\\x0E\\x1D\\xF9\\v\\x1D" +\n        "\\x03\\x1D\\x03\\x1D\\x03\\x1E\\x06\\x1E\\xFE\\n\\x1E\\r\\x1E\\x0E\\x1E\\xFF\\x03\\x1F\\x03" +\n        "\\x1F\\x07\\x1F\\u0104\\n\\x1F\\f\\x1F\\x0E\\x1F\\u0107\\v\\x1F\\x03 \\x03 \\x07 \\u010B" +\n        "\\n \\f \\x0E \\u010E\\v \\x03!\\x03!\\x03!\\x03\\"\\x03\\"\\x03\\"\\x03#\\x03#\\x03$\\x03" +\n        "$\\x03%\\x03%\\x03&\\x03&\\x03\\\'\\x03\\\'\\x03(\\x03(\\x03(\\x03)\\x03)\\x03*\\x03*\\x03" +\n        "+\\x03+\\x03,\\x03,\\x03-\\x03-\\x03.\\x03.\\x03/\\x03/\\x030\\x030\\x031\\x031\\x03" +\n        "2\\x032\\x033\\x033\\x034\\x034\\x035\\x035\\x036\\x036\\x037\\x037\\x038\\x038\\x03" +\n        "9\\x039\\x03:\\x03:\\x03;\\x03;\\x03<\\x03<\\x03<\\x05<\\u014C\\n<\\x03=\\x03=\\x03" +\n        "=\\x03=\\x03=\\x03=\\x03>\\x03>\\x03?\\x03?\\x03?\\x03@\\x03@\\x03@\\x03A\\x03A\\x03" +\n        "A\\x07A\\u015F\\nA\\fA\\x0EA\\u0162\\vA\\x03A\\x03A\\x03A\\x03A\\x03B\\x03B\\x03B\\x03" +\n        "B\\x07B\\u016C\\nB\\fB\\x0EB\\u016F\\vB\\x03B\\x05B\\u0172\\nB\\x03B\\x03B\\x03C\\x06" +\n        "C\\u0177\\nC\\rC\\x0EC\\u0178\\x03C\\x03C\\x03\\u0160\\x02\\x02D\\x03\\x02\\x03\\x05" +\n        "\\x02\\x04\\x07\\x02\\x05\\t\\x02\\x06\\v\\x02\\x07\\r\\x02\\b\\x0F\\x02\\t\\x11\\x02\\n\\x13" +\n        "\\x02\\v\\x15\\x02\\f\\x17\\x02\\r\\x19\\x02\\x0E\\x1B\\x02\\x0F\\x1D\\x02\\x10\\x1F\\x02" +\n        "\\x11!\\x02\\x12#\\x02\\x13%\\x02\\x14\\\'\\x02\\x15)\\x02\\x16+\\x02\\x17-\\x02\\x18/" +\n        "\\x02\\x191\\x02\\x1A3\\x02\\x1B5\\x02\\x1C7\\x02\\x1D9\\x02\\x1E;\\x02\\x1F=\\x02 ?" +\n        "\\x02!A\\x02\\"C\\x02#E\\x02$G\\x02%I\\x02&K\\x02\\\'M\\x02(O\\x02)Q\\x02*S\\x02+U\\x02" +\n        "\\x02W\\x02\\x02Y\\x02\\x02[\\x02\\x02]\\x02\\x02_\\x02\\x02a\\x02\\x02c\\x02\\x02e\\x02" +\n        "\\x02g\\x02\\x02i\\x02\\x02k\\x02\\x02m\\x02\\x02o\\x02\\x02q\\x02\\x02s\\x02\\x02u\\x02" +\n        "\\x02w\\x02\\x02y\\x02\\x02{\\x02\\x02}\\x02,\\x7F\\x02-\\x81\\x02.\\x83\\x02/\\x85\\x02" +\n        "0\\x03\\x02\\x1C\\x04\\x02$$^^\\x03\\x022;\\x03\\x02C\\\\\\x06\\x022;C\\\\aac|\\x03\\x02" +\n        "c|\\x04\\x02CCcc\\x04\\x02EEee\\x04\\x02FFff\\x04\\x02GGgg\\x04\\x02HHhh\\x04\\x02" +\n        "JJjj\\x04\\x02KKkk\\x04\\x02NNnn\\x04\\x02PPpp\\x04\\x02QQqq\\x04\\x02RRrr\\x04\\x02" +\n        "TTtt\\x04\\x02UUuu\\x04\\x02VVvv\\x04\\x02WWww\\x04\\x02XXxx\\x04\\x02YYyy\\n\\x02" +\n        "$$11^^ddhhppttvv\\x05\\x022;CHch\\x03\\x02\\f\\f\\x05\\x02\\v\\f\\x0E\\x0F\\"\\"\\x02" +\n        "\\u0172\\x02\\x03\\x03\\x02\\x02\\x02\\x02\\x05\\x03\\x02\\x02\\x02\\x02\\x07\\x03\\x02" +\n        "\\x02\\x02\\x02\\t\\x03\\x02\\x02\\x02\\x02\\v\\x03\\x02\\x02\\x02\\x02\\r\\x03\\x02\\x02" +\n        "\\x02\\x02\\x0F\\x03\\x02\\x02\\x02\\x02\\x11\\x03\\x02\\x02\\x02\\x02\\x13\\x03\\x02\\x02" +\n        "\\x02\\x02\\x15\\x03\\x02\\x02\\x02\\x02\\x17\\x03\\x02\\x02\\x02\\x02\\x19\\x03\\x02\\x02" +\n        "\\x02\\x02\\x1B\\x03\\x02\\x02\\x02\\x02\\x1D\\x03\\x02\\x02\\x02\\x02\\x1F\\x03\\x02\\x02" +\n        "\\x02\\x02!\\x03\\x02\\x02\\x02\\x02#\\x03\\x02\\x02\\x02\\x02%\\x03\\x02\\x02\\x02\\x02" +\n        "\\\'\\x03\\x02\\x02\\x02\\x02)\\x03\\x02\\x02\\x02\\x02+\\x03\\x02\\x02\\x02\\x02-\\x03" +\n        "\\x02\\x02\\x02\\x02/\\x03\\x02\\x02\\x02\\x021\\x03\\x02\\x02\\x02\\x023\\x03\\x02\\x02" +\n        "\\x02\\x025\\x03\\x02\\x02\\x02\\x027\\x03\\x02\\x02\\x02\\x029\\x03\\x02\\x02\\x02\\x02" +\n        ";\\x03\\x02\\x02\\x02\\x02=\\x03\\x02\\x02\\x02\\x02?\\x03\\x02\\x02\\x02\\x02A\\x03\\x02" +\n        "\\x02\\x02\\x02C\\x03\\x02\\x02\\x02\\x02E\\x03\\x02\\x02\\x02\\x02G\\x03\\x02\\x02\\x02" +\n        "\\x02I\\x03\\x02\\x02\\x02\\x02K\\x03\\x02\\x02\\x02\\x02M\\x03\\x02\\x02\\x02\\x02O\\x03" +\n        "\\x02\\x02\\x02\\x02Q\\x03\\x02\\x02\\x02\\x02S\\x03\\x02\\x02\\x02\\x02}\\x03\\x02\\x02" +\n        "\\x02\\x02\\x7F\\x03\\x02\\x02\\x02\\x02\\x81\\x03\\x02\\x02\\x02\\x02\\x83\\x03\\x02\\x02" +\n        "\\x02\\x02\\x85\\x03\\x02\\x02\\x02\\x03\\x87\\x03\\x02\\x02\\x02\\x05\\x89\\x03\\x02\\x02" +\n        "\\x02\\x07\\x8B\\x03\\x02\\x02\\x02\\t\\x8D\\x03\\x02\\x02\\x02\\v\\x8F\\x03\\x02\\x02\\x02" +\n        "\\r\\x91\\x03\\x02\\x02\\x02\\x0F\\x93\\x03\\x02\\x02\\x02\\x11\\x95\\x03\\x02\\x02\\x02" +\n        "\\x13\\x97\\x03\\x02\\x02\\x02\\x15\\x99\\x03\\x02\\x02\\x02\\x17\\x9F\\x03\\x02\\x02\\x02" +\n        "\\x19\\xA4\\x03\\x02\\x02\\x02\\x1B\\xAA\\x03\\x02\\x02\\x02\\x1D\\xAD\\x03\\x02\\x02\\x02" +\n        "\\x1F\\xB0\\x03\\x02\\x02\\x02!\\xB3\\x03\\x02\\x02\\x02#\\xBC\\x03\\x02\\x02\\x02%\\xC3" +\n        "\\x03\\x02\\x02\\x02\\\'\\xC7\\x03\\x02\\x02\\x02)\\xCC\\x03\\x02\\x02\\x02+\\xD1\\x03\\x02" +\n        "\\x02\\x02-\\xD6\\x03\\x02\\x02\\x02/\\xDC\\x03\\x02\\x02\\x021\\xE1\\x03\\x02\\x02\\x02" +\n        "3\\xE6\\x03\\x02\\x02\\x025\\xEA\\x03\\x02\\x02\\x027\\xED\\x03\\x02\\x02\\x029\\xF2\\x03" +\n        "\\x02\\x02\\x02;\\xFD\\x03\\x02\\x02\\x02=\\u0101\\x03\\x02\\x02\\x02?\\u0108\\x03\\x02" +\n        "\\x02\\x02A\\u010F\\x03\\x02\\x02\\x02C\\u0112\\x03\\x02\\x02\\x02E\\u0115\\x03\\x02" +\n        "\\x02\\x02G\\u0117\\x03\\x02\\x02\\x02I\\u0119\\x03\\x02\\x02\\x02K\\u011B\\x03\\x02" +\n        "\\x02\\x02M\\u011D\\x03\\x02\\x02\\x02O\\u011F\\x03\\x02\\x02\\x02Q\\u0122\\x03\\x02" +\n        "\\x02\\x02S\\u0124\\x03\\x02\\x02\\x02U\\u0126\\x03\\x02\\x02\\x02W\\u0128\\x03\\x02" +\n        "\\x02\\x02Y\\u012A\\x03\\x02\\x02\\x02[\\u012C\\x03\\x02\\x02\\x02]\\u012E\\x03\\x02" +\n        "\\x02\\x02_\\u0130\\x03\\x02\\x02\\x02a\\u0132\\x03\\x02\\x02\\x02c\\u0134\\x03\\x02" +\n        "\\x02\\x02e\\u0136\\x03\\x02\\x02\\x02g\\u0138\\x03\\x02\\x02\\x02i\\u013A\\x03\\x02" +\n        "\\x02\\x02k\\u013C\\x03\\x02\\x02\\x02m\\u013E\\x03\\x02\\x02\\x02o\\u0140\\x03\\x02" +\n        "\\x02\\x02q\\u0142\\x03\\x02\\x02\\x02s\\u0144\\x03\\x02\\x02\\x02u\\u0146\\x03\\x02" +\n        "\\x02\\x02w\\u0148\\x03\\x02\\x02\\x02y\\u014D\\x03\\x02\\x02\\x02{\\u0153\\x03\\x02" +\n        "\\x02\\x02}\\u0155\\x03\\x02\\x02\\x02\\x7F\\u0158\\x03\\x02\\x02\\x02\\x81\\u015B\\x03" +\n        "\\x02\\x02\\x02\\x83\\u0167\\x03\\x02\\x02\\x02\\x85\\u0176\\x03\\x02\\x02\\x02\\x87\\x88" +\n        "\\x07=\\x02\\x02\\x88\\x04\\x03\\x02\\x02\\x02\\x89\\x8A\\x07}\\x02\\x02\\x8A\\x06\\x03" +\n        "\\x02\\x02\\x02\\x8B\\x8C\\x07\\x7F\\x02\\x02\\x8C\\b\\x03\\x02\\x02\\x02\\x8D\\x8E\\x07" +\n        "*\\x02\\x02\\x8E\\n\\x03\\x02\\x02\\x02\\x8F\\x90\\x07.\\x02\\x02\\x90\\f\\x03\\x02\\x02" +\n        "\\x02\\x91\\x92\\x07+\\x02\\x02\\x92\\x0E\\x03\\x02\\x02\\x02\\x93\\x94\\x07<\\x02\\x02" +\n        "\\x94\\x10\\x03\\x02\\x02\\x02\\x95\\x96\\x07B\\x02\\x02\\x96\\x12\\x03\\x02\\x02\\x02" +\n        "\\x97\\x98\\x070\\x02\\x02\\x98\\x14\\x03\\x02\\x02\\x02\\x99\\x9A\\x05W,\\x02\\x9A\\x9B" +\n        "\\x05c2\\x02\\x9B\\x9C\\x05U+\\x02\\x9C\\x9D\\x05m7\\x02\\x9D\\x9E\\x05m7\\x02\\x9E\\x16" +\n        "\\x03\\x02\\x02\\x02\\x9F\\xA0\\x05[.\\x02\\xA0\\xA1\\x05c2\\x02\\xA1\\xA2\\x05m7\\x02" +\n        "\\xA2\\xA3\\x05[.\\x02\\xA3\\x18\\x03\\x02\\x02\\x02\\xA4\\xA5\\x07h\\x02\\x02\\xA5\\xA6" +\n        "\\x07c\\x02\\x02\\xA6\\xA7\\x07n\\x02\\x02\\xA7\\xA8\\x07u\\x02\\x02\\xA8\\xA9\\x07g\\x02" +\n        "\\x02\\xA9\\x1A\\x03\\x02\\x02\\x02\\xAA\\xAB\\x05]/\\x02\\xAB\\xAC\\x05a1\\x02\\xAC\\x1C" +\n        "\\x03\\x02\\x02\\x02\\xAD\\xAE\\x05a1\\x02\\xAE\\xAF\\x05]/\\x02\\xAF\\x1E\\x03\\x02\\x02" +\n        "\\x02\\xB0\\xB1\\x05a1\\x02\\xB1\\xB2\\x05e3\\x02\\xB2 \\x03\\x02\\x02\\x02\\xB3\\xB4" +\n        "\\x05a1\\x02\\xB4\\xB5\\x05e3\\x02\\xB5\\xB6\\x05_0\\x02\\xB6\\xB7\\x05[.\\x02\\xB7\\xB8" +\n        "\\x05k6\\x02\\xB8\\xB9\\x05a1\\x02\\xB9\\xBA\\x05o8\\x02\\xBA\\xBB\\x05m7\\x02\\xBB\\"" +\n        "\\x03\\x02\\x02\\x02\\xBC\\xBD\\x05a1\\x02\\xBD\\xBE\\x05m7\\x02\\xBE\\xBF\\x05s:\\x02" +\n        "\\xBF\\xC0\\x05g4\\x02\\xC0\\xC1\\x05a1\\x02\\xC1\\xC2\\x05Y-\\x02\\xC2$\\x03\\x02\\x02" +\n        "\\x02\\xC3\\xC4\\x05c2\\x02\\xC4\\xC5\\x05[.\\x02\\xC5\\xC6\\x05o8\\x02\\xC6&\\x03\\x02" +\n        "\\x02\\x02\\xC7\\xC8\\x05c2\\x02\\xC8\\xC9\\x05g4\\x02\\xC9\\xCA\\x05g4\\x02\\xCA\\xCB" +\n        "\\x05i5\\x02\\xCB(\\x03\\x02\\x02\\x02\\xCC\\xCD\\x05i5\\x02\\xCD\\xCE\\x05g4\\x02\\xCE" +\n        "\\xCF\\x05g4\\x02\\xCF\\xD0\\x05c2\\x02\\xD0*\\x03\\x02\\x02\\x02\\xD1\\xD2\\x05o8\\x02" +\n        "\\xD2\\xD3\\x05_0\\x02\\xD3\\xD4\\x05[.\\x02\\xD4\\xD5\\x05e3\\x02\\xD5,\\x03\\x02\\x02" +\n        "\\x02\\xD6\\xD7\\x05u;\\x02\\xD7\\xD8\\x05_0\\x02\\xD8\\xD9\\x05a1\\x02\\xD9\\xDA\\x05" +\n        "c2\\x02\\xDA\\xDB\\x05[.\\x02\\xDB.\\x03\\x02\\x02\\x02\\xDC\\xDD\\x05W,\\x02\\xDD\\xDE" +\n        "\\x05U+\\x02\\xDE\\xDF\\x05m7\\x02\\xDF\\xE0\\x05[.\\x02\\xE00\\x03\\x02\\x02\\x02\\xE1" +\n        "\\xE2\\x05[.\\x02\\xE2\\xE3\\x05m7\\x02\\xE3\\xE4\\x05U+\\x02\\xE4\\xE5\\x05W,\\x02\\xE5" +\n        "2\\x03\\x02\\x02\\x02\\xE6\\xE7\\x05e3\\x02\\xE7\\xE8\\x05[.\\x02\\xE8\\xE9\\x05u;\\x02" +\n        "\\xE94\\x03\\x02\\x02\\x02\\xEA\\xEB\\x05g4\\x02\\xEB\\xEC\\x05]/\\x02\\xEC6\\x03\\x02" +\n        "\\x02\\x02\\xED\\xEE\\x07v\\x02\\x02\\xEE\\xEF\\x07t\\x02\\x02\\xEF\\xF0\\x07w\\x02\\x02" +\n        "\\xF0\\xF1\\x07g\\x02\\x02\\xF18\\x03\\x02\\x02\\x02\\xF2\\xF7\\x07$\\x02\\x02\\xF3\\xF6" +\n        "\\x05w<\\x02\\xF4\\xF6\\n\\x02\\x02\\x02\\xF5\\xF3\\x03\\x02\\x02\\x02\\xF5\\xF4\\x03\\x02" +\n        "\\x02\\x02\\xF6\\xF9\\x03\\x02\\x02\\x02\\xF7\\xF5\\x03\\x02\\x02\\x02\\xF7\\xF8\\x03\\x02" +\n        "\\x02\\x02\\xF8\\xFA\\x03\\x02\\x02\\x02\\xF9\\xF7\\x03\\x02\\x02\\x02\\xFA\\xFB\\x07$" +\n        "\\x02\\x02\\xFB:\\x03\\x02\\x02\\x02\\xFC\\xFE\\t\\x03\\x02\\x02\\xFD\\xFC\\x03\\x02\\x02" +\n        "\\x02\\xFE\\xFF\\x03\\x02\\x02\\x02\\xFF\\xFD\\x03\\x02\\x02\\x02\\xFF\\u0100\\x03\\x02" +\n        "\\x02\\x02\\u0100<\\x03\\x02\\x02\\x02\\u0101\\u0105\\t\\x04\\x02\\x02\\u0102\\u0104" +\n        "\\t\\x05\\x02\\x02\\u0103\\u0102\\x03\\x02\\x02\\x02\\u0104\\u0107\\x03\\x02\\x02\\x02" +\n        "\\u0105\\u0103\\x03\\x02\\x02\\x02\\u0105\\u0106\\x03\\x02\\x02\\x02\\u0106>\\x03\\x02" +\n        "\\x02\\x02\\u0107\\u0105\\x03\\x02\\x02\\x02\\u0108\\u010C\\t\\x06\\x02\\x02\\u0109\\u010B" +\n        "\\t\\x05\\x02\\x02\\u010A\\u0109\\x03\\x02\\x02\\x02\\u010B\\u010E\\x03\\x02\\x02\\x02" +\n        "\\u010C\\u010A\\x03\\x02\\x02\\x02\\u010C\\u010D\\x03\\x02\\x02\\x02\\u010D@\\x03\\x02" +\n        "\\x02\\x02\\u010E\\u010C\\x03\\x02\\x02\\x02\\u010F\\u0110\\x07>\\x02\\x02\\u0110\\u0111" +\n        "\\x07/\\x02\\x02\\u0111B\\x03\\x02\\x02\\x02\\u0112\\u0113\\x07?\\x02\\x02\\u0113\\u0114" +\n        "\\x07@\\x02\\x02\\u0114D\\x03\\x02\\x02\\x02\\u0115\\u0116\\x07-\\x02\\x02\\u0116F\\x03" +\n        "\\x02\\x02\\x02\\u0117\\u0118\\x07/\\x02\\x02\\u0118H\\x03\\x02\\x02\\x02\\u0119\\u011A" +\n        "\\x07,\\x02\\x02\\u011AJ\\x03\\x02\\x02\\x02\\u011B\\u011C\\x071\\x02\\x02\\u011CL\\x03" +\n        "\\x02\\x02\\x02\\u011D\\u011E\\x07>\\x02\\x02\\u011EN\\x03\\x02\\x02\\x02\\u011F\\u0120" +\n        "\\x07>\\x02\\x02\\u0120\\u0121\\x07?\\x02\\x02\\u0121P\\x03\\x02\\x02\\x02\\u0122\\u0123" +\n        "\\x07?\\x02\\x02\\u0123R\\x03\\x02\\x02\\x02\\u0124\\u0125\\x07\\x80\\x02\\x02\\u0125" +\n        "T\\x03\\x02\\x02\\x02\\u0126\\u0127\\t\\x07\\x02\\x02\\u0127V\\x03\\x02\\x02\\x02\\u0128" +\n        "\\u0129\\t\\b\\x02\\x02\\u0129X\\x03\\x02\\x02\\x02\\u012A\\u012B\\t\\t\\x02\\x02\\u012B" +\n        "Z\\x03\\x02\\x02\\x02\\u012C\\u012D\\t\\n\\x02\\x02\\u012D\\\\\\x03\\x02\\x02\\x02\\u012E" +\n        "\\u012F\\t\\v\\x02\\x02\\u012F^\\x03\\x02\\x02\\x02\\u0130\\u0131\\t\\f\\x02\\x02\\u0131" +\n        "`\\x03\\x02\\x02\\x02\\u0132\\u0133\\t\\r\\x02\\x02\\u0133b\\x03\\x02\\x02\\x02\\u0134" +\n        "\\u0135\\t\\x0E\\x02\\x02\\u0135d\\x03\\x02\\x02\\x02\\u0136\\u0137\\t\\x0F\\x02\\x02" +\n        "\\u0137f\\x03\\x02\\x02\\x02\\u0138\\u0139\\t\\x10\\x02\\x02\\u0139h\\x03\\x02\\x02\\x02" +\n        "\\u013A\\u013B\\t\\x11\\x02\\x02\\u013Bj\\x03\\x02\\x02\\x02\\u013C\\u013D\\t\\x12\\x02" +\n        "\\x02\\u013Dl\\x03\\x02\\x02\\x02\\u013E\\u013F\\t\\x13\\x02\\x02\\u013Fn\\x03\\x02\\x02" +\n        "\\x02\\u0140\\u0141\\t\\x14\\x02\\x02\\u0141p\\x03\\x02\\x02\\x02\\u0142\\u0143\\t\\x15" +\n        "\\x02\\x02\\u0143r\\x03\\x02\\x02\\x02\\u0144\\u0145\\t\\x16\\x02\\x02\\u0145t\\x03\\x02" +\n        "\\x02\\x02\\u0146\\u0147\\t\\x17\\x02\\x02\\u0147v\\x03\\x02\\x02\\x02\\u0148\\u014B" +\n        "\\x07^\\x02\\x02\\u0149\\u014C\\t\\x18\\x02\\x02\\u014A\\u014C\\x05y=\\x02\\u014B\\u0149" +\n        "\\x03\\x02\\x02\\x02\\u014B\\u014A\\x03\\x02\\x02\\x02\\u014Cx\\x03\\x02\\x02\\x02\\u014D" +\n        "\\u014E\\x07w\\x02\\x02\\u014E\\u014F\\x05{>\\x02\\u014F\\u0150\\x05{>\\x02\\u0150" +\n        "\\u0151\\x05{>\\x02\\u0151\\u0152\\x05{>\\x02\\u0152z\\x03\\x02\\x02\\x02\\u0153\\u0154" +\n        "\\t\\x19\\x02\\x02\\u0154|\\x03\\x02\\x02\\x02\\u0155\\u0156\\x07*\\x02\\x02\\u0156\\u0157" +\n        "\\x07,\\x02\\x02\\u0157~\\x03\\x02\\x02\\x02\\u0158\\u0159\\x07,\\x02\\x02\\u0159\\u015A" +\n        "\\x07+\\x02\\x02\\u015A\\x80\\x03\\x02\\x02\\x02\\u015B\\u0160\\x05}?\\x02\\u015C\\u015F" +\n        "\\x05\\x81A\\x02\\u015D\\u015F\\v\\x02\\x02\\x02\\u015E\\u015C\\x03\\x02\\x02\\x02\\u015E" +\n        "\\u015D\\x03\\x02\\x02\\x02\\u015F\\u0162\\x03\\x02\\x02\\x02\\u0160\\u0161\\x03\\x02" +\n        "\\x02\\x02\\u0160\\u015E\\x03\\x02\\x02\\x02\\u0161\\u0163\\x03\\x02\\x02\\x02\\u0162" +\n        "\\u0160\\x03\\x02\\x02\\x02\\u0163\\u0164\\x05\\x7F@\\x02\\u0164\\u0165\\x03\\x02\\x02" +\n        "\\x02\\u0165\\u0166\\bA\\x02\\x02\\u0166\\x82\\x03\\x02\\x02\\x02\\u0167\\u0168\\x07" +\n        "/\\x02\\x02\\u0168\\u0169\\x07/\\x02\\x02\\u0169\\u016D\\x03\\x02\\x02\\x02\\u016A\\u016C" +\n        "\\n\\x1A\\x02\\x02\\u016B\\u016A\\x03\\x02\\x02\\x02\\u016C\\u016F\\x03\\x02\\x02\\x02" +\n        "\\u016D\\u016B\\x03\\x02\\x02\\x02\\u016D\\u016E\\x03\\x02\\x02\\x02\\u016E\\u0171\\x03" +\n        "\\x02\\x02\\x02\\u016F\\u016D\\x03\\x02\\x02\\x02\\u0170\\u0172\\x07\\f\\x02\\x02\\u0171" +\n        "\\u0170\\x03\\x02\\x02\\x02\\u0171\\u0172\\x03\\x02\\x02\\x02\\u0172\\u0173\\x03\\x02" +\n        "\\x02\\x02\\u0173\\u0174\\bB\\x02\\x02\\u0174\\x84\\x03\\x02\\x02\\x02\\u0175\\u0177" +\n        "\\t\\x1B\\x02\\x02\\u0176\\u0175\\x03\\x02\\x02\\x02\\u0177\\u0178\\x03\\x02\\x02\\x02" +\n        "\\u0178\\u0176\\x03\\x02\\x02\\x02\\u0178\\u0179\\x03\\x02\\x02\\x02\\u0179\\u017A\\x03" +\n        "\\x02\\x02\\x02\\u017A\\u017B\\bC\\x02\\x02\\u017B\\x86\\x03\\x02\\x02\\x02\\x0E\\x02" +\n        "\\xF5\\xF7\\xFF\\u0105\\u010C\\u014B\\u015E\\u0160\\u016D\\u0171\\u0178\\x03\\b\\x02" +\n        "\\x02";\n    static __ATN;\n    static get _ATN() {\n        if (!yaplLexer.__ATN) {\n            yaplLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(yaplLexer._serializedATN));\n        }\n        return yaplLexer.__ATN;\n    }\n}\nexports.yaplLexer = yaplLexer;\n\n\n//# sourceURL=webpack://proyecto2/./src/antlr/yaplLexer.ts?')},"./src/antlr/yaplParser.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\n// Generated from yapl.g4 by ANTLR 4.9.0-SNAPSHOT\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.AssignmentContext = exports.FalseContext = exports.TrueContext = exports.StringContext = exports.IntContext = exports.IdContext = exports.ParenthesesContext = exports.BoolNotContext = exports.EqualContext = exports.LessEqualContext = exports.LessThanContext = exports.MinusContext = exports.AddContext = exports.DivisionContext = exports.MultiplyContext = exports.IsvoidContext = exports.NegativeContext = exports.NewContext = exports.LetInContext = exports.BlockContext = exports.WhileContext = exports.IfContext = exports.OwnMethodCallContext = exports.MethodCallContext = exports.ExpressionContext = exports.AssignmentExprContext = exports.FormalContext = exports.PropertyContext = exports.MethodContext = exports.FeatureContext = exports.ClassDefineContext = exports.EofContext = exports.ClassesContext = exports.ProgramBlocksContext = exports.ProgramContext = exports.yaplParser = void 0;\nconst ATN_1 = __webpack_require__(/*! antlr4ts/atn/ATN */ "antlr4ts/atn/ATN");\nconst ATNDeserializer_1 = __webpack_require__(/*! antlr4ts/atn/ATNDeserializer */ "antlr4ts/atn/ATNDeserializer");\nconst FailedPredicateException_1 = __webpack_require__(/*! antlr4ts/FailedPredicateException */ "antlr4ts/FailedPredicateException");\nconst NoViableAltException_1 = __webpack_require__(/*! antlr4ts/NoViableAltException */ "antlr4ts/NoViableAltException");\nconst Parser_1 = __webpack_require__(/*! antlr4ts/Parser */ "antlr4ts/Parser");\nconst ParserRuleContext_1 = __webpack_require__(/*! antlr4ts/ParserRuleContext */ "antlr4ts/ParserRuleContext");\nconst ParserATNSimulator_1 = __webpack_require__(/*! antlr4ts/atn/ParserATNSimulator */ "antlr4ts/atn/ParserATNSimulator");\nconst RecognitionException_1 = __webpack_require__(/*! antlr4ts/RecognitionException */ "antlr4ts/RecognitionException");\nconst VocabularyImpl_1 = __webpack_require__(/*! antlr4ts/VocabularyImpl */ "antlr4ts/VocabularyImpl");\nconst Utils = __importStar(__webpack_require__(/*! antlr4ts/misc/Utils */ "antlr4ts/misc/Utils"));\nclass yaplParser extends Parser_1.Parser {\n    static T__0 = 1;\n    static T__1 = 2;\n    static T__2 = 3;\n    static T__3 = 4;\n    static T__4 = 5;\n    static T__5 = 6;\n    static T__6 = 7;\n    static T__7 = 8;\n    static T__8 = 9;\n    static CLASS = 10;\n    static ELSE = 11;\n    static FALSE = 12;\n    static FI = 13;\n    static IF = 14;\n    static IN = 15;\n    static INHERITS = 16;\n    static ISVOID = 17;\n    static LET = 18;\n    static LOOP = 19;\n    static POOL = 20;\n    static THEN = 21;\n    static WHILE = 22;\n    static CASE = 23;\n    static ESAC = 24;\n    static NEW = 25;\n    static OF = 26;\n    static TRUE = 27;\n    static STRING = 28;\n    static INT = 29;\n    static TYPE = 30;\n    static IDENTIFIER = 31;\n    static ASSIGNMENT = 32;\n    static CASE_ARROW = 33;\n    static ADD = 34;\n    static MINUS = 35;\n    static MULTIPLY = 36;\n    static DIVISION = 37;\n    static LESS_THAN = 38;\n    static LESS_EQUAL = 39;\n    static EQUAL = 40;\n    static INTEGER_NEGATIVE = 41;\n    static OPEN_COMMENT = 42;\n    static CLOSE_COMMENT = 43;\n    static COMMENT = 44;\n    static ONE_LINE_COMMENT = 45;\n    static WHITESPACE = 46;\n    static RULE_program = 0;\n    static RULE_programBlocks = 1;\n    static RULE_classDefine = 2;\n    static RULE_feature = 3;\n    static RULE_formal = 4;\n    static RULE_assignmentExpr = 5;\n    static RULE_expression = 6;\n    // tslint:disable:no-trailing-whitespace\n    static ruleNames = [\n        "program", "programBlocks", "classDefine", "feature", "formal", "assignmentExpr",\n        "expression",\n    ];\n    static _LITERAL_NAMES = [\n        undefined, "\';\'", "\'{\'", "\'}\'", "\'(\'", "\',\'", "\')\'", "\':\'", "\'@\'", "\'.\'",\n        undefined, undefined, "\'false\'", undefined, undefined, undefined, undefined,\n        undefined, undefined, undefined, undefined, undefined, undefined, undefined,\n        undefined, undefined, undefined, "\'true\'", undefined, undefined, undefined,\n        undefined, "\'<-\'", "\'=>\'", "\'+\'", "\'-\'", "\'*\'", "\'/\'", "\'<\'", "\'<=\'",\n        "\'=\'", "\'~\'", "\'(*\'", "\'*)\'",\n    ];\n    static _SYMBOLIC_NAMES = [\n        undefined, undefined, undefined, undefined, undefined, undefined, undefined,\n        undefined, undefined, undefined, "CLASS", "ELSE", "FALSE", "FI", "IF",\n        "IN", "INHERITS", "ISVOID", "LET", "LOOP", "POOL", "THEN", "WHILE", "CASE",\n        "ESAC", "NEW", "OF", "TRUE", "STRING", "INT", "TYPE", "IDENTIFIER", "ASSIGNMENT",\n        "CASE_ARROW", "ADD", "MINUS", "MULTIPLY", "DIVISION", "LESS_THAN", "LESS_EQUAL",\n        "EQUAL", "INTEGER_NEGATIVE", "OPEN_COMMENT", "CLOSE_COMMENT", "COMMENT",\n        "ONE_LINE_COMMENT", "WHITESPACE",\n    ];\n    static VOCABULARY = new VocabularyImpl_1.VocabularyImpl(yaplParser._LITERAL_NAMES, yaplParser._SYMBOLIC_NAMES, []);\n    // @Override\n    // @NotNull\n    get vocabulary() {\n        return yaplParser.VOCABULARY;\n    }\n    // tslint:enable:no-trailing-whitespace\n    // @Override\n    get grammarFileName() { return "yapl.g4"; }\n    // @Override\n    get ruleNames() { return yaplParser.ruleNames; }\n    // @Override\n    get serializedATN() { return yaplParser._serializedATN; }\n    createFailedPredicateException(predicate, message) {\n        return new FailedPredicateException_1.FailedPredicateException(this, predicate, message);\n    }\n    constructor(input) {\n        super(input);\n        this._interp = new ParserATNSimulator_1.ParserATNSimulator(yaplParser._ATN, this);\n    }\n    // @RuleVersion(0)\n    program() {\n        let _localctx = new ProgramContext(this._ctx, this.state);\n        this.enterRule(_localctx, 0, yaplParser.RULE_program);\n        try {\n            this.enterOuterAlt(_localctx, 1);\n            {\n                this.state = 14;\n                this.programBlocks();\n                this.state = 15;\n                this.match(yaplParser.EOF);\n            }\n        }\n        catch (re) {\n            if (re instanceof RecognitionException_1.RecognitionException) {\n                _localctx.exception = re;\n                this._errHandler.reportError(this, re);\n                this._errHandler.recover(this, re);\n            }\n            else {\n                throw re;\n            }\n        }\n        finally {\n            this.exitRule();\n        }\n        return _localctx;\n    }\n    // @RuleVersion(0)\n    programBlocks() {\n        let _localctx = new ProgramBlocksContext(this._ctx, this.state);\n        this.enterRule(_localctx, 2, yaplParser.RULE_programBlocks);\n        try {\n            this.state = 22;\n            this._errHandler.sync(this);\n            switch (this._input.LA(1)) {\n                case yaplParser.CLASS:\n                    _localctx = new ClassesContext(_localctx);\n                    this.enterOuterAlt(_localctx, 1);\n                    {\n                        this.state = 17;\n                        this.classDefine();\n                        this.state = 18;\n                        this.match(yaplParser.T__0);\n                        this.state = 19;\n                        this.programBlocks();\n                    }\n                    break;\n                case yaplParser.EOF:\n                    _localctx = new EofContext(_localctx);\n                    this.enterOuterAlt(_localctx, 2);\n                    {\n                        this.state = 21;\n                        this.match(yaplParser.EOF);\n                    }\n                    break;\n                default:\n                    throw new NoViableAltException_1.NoViableAltException(this);\n            }\n        }\n        catch (re) {\n            if (re instanceof RecognitionException_1.RecognitionException) {\n                _localctx.exception = re;\n                this._errHandler.reportError(this, re);\n                this._errHandler.recover(this, re);\n            }\n            else {\n                throw re;\n            }\n        }\n        finally {\n            this.exitRule();\n        }\n        return _localctx;\n    }\n    // @RuleVersion(0)\n    classDefine() {\n        let _localctx = new ClassDefineContext(this._ctx, this.state);\n        this.enterRule(_localctx, 4, yaplParser.RULE_classDefine);\n        let _la;\n        try {\n            this.enterOuterAlt(_localctx, 1);\n            {\n                this.state = 24;\n                this.match(yaplParser.CLASS);\n                this.state = 25;\n                this.match(yaplParser.TYPE);\n                this.state = 28;\n                this._errHandler.sync(this);\n                _la = this._input.LA(1);\n                if (_la === yaplParser.INHERITS) {\n                    {\n                        this.state = 26;\n                        this.match(yaplParser.INHERITS);\n                        this.state = 27;\n                        this.match(yaplParser.TYPE);\n                    }\n                }\n                this.state = 30;\n                this.match(yaplParser.T__1);\n                this.state = 36;\n                this._errHandler.sync(this);\n                _la = this._input.LA(1);\n                while (_la === yaplParser.IDENTIFIER) {\n                    {\n                        {\n                            this.state = 31;\n                            this.feature();\n                            this.state = 32;\n                            this.match(yaplParser.T__0);\n                        }\n                    }\n                    this.state = 38;\n                    this._errHandler.sync(this);\n                    _la = this._input.LA(1);\n                }\n                this.state = 39;\n                this.match(yaplParser.T__2);\n            }\n        }\n        catch (re) {\n            if (re instanceof RecognitionException_1.RecognitionException) {\n                _localctx.exception = re;\n                this._errHandler.reportError(this, re);\n                this._errHandler.recover(this, re);\n            }\n            else {\n                throw re;\n            }\n        }\n        finally {\n            this.exitRule();\n        }\n        return _localctx;\n    }\n    // @RuleVersion(0)\n    feature() {\n        let _localctx = new FeatureContext(this._ctx, this.state);\n        this.enterRule(_localctx, 6, yaplParser.RULE_feature);\n        let _la;\n        try {\n            this.state = 67;\n            this._errHandler.sync(this);\n            switch (this.interpreter.adaptivePredict(this._input, 6, this._ctx)) {\n                case 1:\n                    _localctx = new MethodContext(_localctx);\n                    this.enterOuterAlt(_localctx, 1);\n                    {\n                        this.state = 41;\n                        this.match(yaplParser.IDENTIFIER);\n                        this.state = 42;\n                        this.match(yaplParser.T__3);\n                        this.state = 51;\n                        this._errHandler.sync(this);\n                        _la = this._input.LA(1);\n                        if (_la === yaplParser.IDENTIFIER) {\n                            {\n                                this.state = 43;\n                                this.formal();\n                                this.state = 48;\n                                this._errHandler.sync(this);\n                                _la = this._input.LA(1);\n                                while (_la === yaplParser.T__4) {\n                                    {\n                                        {\n                                            this.state = 44;\n                                            this.match(yaplParser.T__4);\n                                            this.state = 45;\n                                            this.formal();\n                                        }\n                                    }\n                                    this.state = 50;\n                                    this._errHandler.sync(this);\n                                    _la = this._input.LA(1);\n                                }\n                            }\n                        }\n                        this.state = 53;\n                        this.match(yaplParser.T__5);\n                        this.state = 54;\n                        this.match(yaplParser.T__6);\n                        this.state = 55;\n                        this.match(yaplParser.TYPE);\n                        this.state = 56;\n                        this.match(yaplParser.T__1);\n                        this.state = 57;\n                        this.expression(0);\n                        this.state = 58;\n                        this.match(yaplParser.T__2);\n                    }\n                    break;\n                case 2:\n                    _localctx = new PropertyContext(_localctx);\n                    this.enterOuterAlt(_localctx, 2);\n                    {\n                        this.state = 60;\n                        this.match(yaplParser.IDENTIFIER);\n                        this.state = 61;\n                        this.match(yaplParser.T__6);\n                        this.state = 62;\n                        this.match(yaplParser.TYPE);\n                        this.state = 65;\n                        this._errHandler.sync(this);\n                        _la = this._input.LA(1);\n                        if (_la === yaplParser.ASSIGNMENT) {\n                            {\n                                this.state = 63;\n                                this.match(yaplParser.ASSIGNMENT);\n                                this.state = 64;\n                                this.expression(0);\n                            }\n                        }\n                    }\n                    break;\n            }\n        }\n        catch (re) {\n            if (re instanceof RecognitionException_1.RecognitionException) {\n                _localctx.exception = re;\n                this._errHandler.reportError(this, re);\n                this._errHandler.recover(this, re);\n            }\n            else {\n                throw re;\n            }\n        }\n        finally {\n            this.exitRule();\n        }\n        return _localctx;\n    }\n    // @RuleVersion(0)\n    formal() {\n        let _localctx = new FormalContext(this._ctx, this.state);\n        this.enterRule(_localctx, 8, yaplParser.RULE_formal);\n        try {\n            this.enterOuterAlt(_localctx, 1);\n            {\n                this.state = 69;\n                this.match(yaplParser.IDENTIFIER);\n                this.state = 70;\n                this.match(yaplParser.T__6);\n                this.state = 71;\n                this.match(yaplParser.TYPE);\n            }\n        }\n        catch (re) {\n            if (re instanceof RecognitionException_1.RecognitionException) {\n                _localctx.exception = re;\n                this._errHandler.reportError(this, re);\n                this._errHandler.recover(this, re);\n            }\n            else {\n                throw re;\n            }\n        }\n        finally {\n            this.exitRule();\n        }\n        return _localctx;\n    }\n    // @RuleVersion(0)\n    assignmentExpr() {\n        let _localctx = new AssignmentExprContext(this._ctx, this.state);\n        this.enterRule(_localctx, 10, yaplParser.RULE_assignmentExpr);\n        let _la;\n        try {\n            this.enterOuterAlt(_localctx, 1);\n            {\n                this.state = 73;\n                this.match(yaplParser.IDENTIFIER);\n                this.state = 74;\n                this.match(yaplParser.T__6);\n                this.state = 75;\n                this.match(yaplParser.TYPE);\n                this.state = 78;\n                this._errHandler.sync(this);\n                _la = this._input.LA(1);\n                if (_la === yaplParser.ASSIGNMENT) {\n                    {\n                        this.state = 76;\n                        this.match(yaplParser.ASSIGNMENT);\n                        this.state = 77;\n                        this.expression(0);\n                    }\n                }\n            }\n        }\n        catch (re) {\n            if (re instanceof RecognitionException_1.RecognitionException) {\n                _localctx.exception = re;\n                this._errHandler.reportError(this, re);\n                this._errHandler.recover(this, re);\n            }\n            else {\n                throw re;\n            }\n        }\n        finally {\n            this.exitRule();\n        }\n        return _localctx;\n    }\n    // @RuleVersion(0)\n    expression(_p) {\n        if (_p === undefined) {\n            _p = 0;\n        }\n        let _parentctx = this._ctx;\n        let _parentState = this.state;\n        let _localctx = new ExpressionContext(this._ctx, _parentState);\n        let _prevctx = _localctx;\n        let _startState = 12;\n        this.enterRecursionRule(_localctx, 12, yaplParser.RULE_expression, _p);\n        let _la;\n        try {\n            let _alt;\n            this.enterOuterAlt(_localctx, 1);\n            {\n                this.state = 150;\n                this._errHandler.sync(this);\n                switch (this.interpreter.adaptivePredict(this._input, 12, this._ctx)) {\n                    case 1:\n                        {\n                            _localctx = new OwnMethodCallContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 81;\n                            this.match(yaplParser.IDENTIFIER);\n                            this.state = 82;\n                            this.match(yaplParser.T__3);\n                            this.state = 91;\n                            this._errHandler.sync(this);\n                            _la = this._input.LA(1);\n                            if ((((_la) & ~0x1F) === 0 && ((1 << _la) & ((1 << yaplParser.T__1) | (1 << yaplParser.T__3) | (1 << yaplParser.FALSE) | (1 << yaplParser.IF) | (1 << yaplParser.ISVOID) | (1 << yaplParser.LET) | (1 << yaplParser.WHILE) | (1 << yaplParser.NEW) | (1 << yaplParser.TRUE) | (1 << yaplParser.STRING) | (1 << yaplParser.INT) | (1 << yaplParser.IDENTIFIER))) !== 0) || _la === yaplParser.INTEGER_NEGATIVE) {\n                                {\n                                    this.state = 83;\n                                    this.expression(0);\n                                    this.state = 88;\n                                    this._errHandler.sync(this);\n                                    _la = this._input.LA(1);\n                                    while (_la === yaplParser.T__4) {\n                                        {\n                                            {\n                                                this.state = 84;\n                                                this.match(yaplParser.T__4);\n                                                this.state = 85;\n                                                this.expression(0);\n                                            }\n                                        }\n                                        this.state = 90;\n                                        this._errHandler.sync(this);\n                                        _la = this._input.LA(1);\n                                    }\n                                }\n                            }\n                            this.state = 93;\n                            this.match(yaplParser.T__5);\n                        }\n                        break;\n                    case 2:\n                        {\n                            _localctx = new IfContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 94;\n                            this.match(yaplParser.IF);\n                            this.state = 95;\n                            this.expression(0);\n                            this.state = 96;\n                            this.match(yaplParser.THEN);\n                            this.state = 97;\n                            this.expression(0);\n                            this.state = 98;\n                            this.match(yaplParser.ELSE);\n                            this.state = 99;\n                            this.expression(0);\n                            this.state = 100;\n                            this.match(yaplParser.FI);\n                        }\n                        break;\n                    case 3:\n                        {\n                            _localctx = new WhileContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 102;\n                            this.match(yaplParser.WHILE);\n                            this.state = 103;\n                            this.expression(0);\n                            this.state = 104;\n                            this.match(yaplParser.LOOP);\n                            this.state = 105;\n                            this.expression(0);\n                            this.state = 106;\n                            this.match(yaplParser.POOL);\n                        }\n                        break;\n                    case 4:\n                        {\n                            _localctx = new BlockContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 108;\n                            this.match(yaplParser.T__1);\n                            this.state = 112;\n                            this._errHandler.sync(this);\n                            _la = this._input.LA(1);\n                            do {\n                                {\n                                    {\n                                        this.state = 109;\n                                        this.expression(0);\n                                        this.state = 110;\n                                        this.match(yaplParser.T__0);\n                                    }\n                                }\n                                this.state = 114;\n                                this._errHandler.sync(this);\n                                _la = this._input.LA(1);\n                            } while ((((_la) & ~0x1F) === 0 && ((1 << _la) & ((1 << yaplParser.T__1) | (1 << yaplParser.T__3) | (1 << yaplParser.FALSE) | (1 << yaplParser.IF) | (1 << yaplParser.ISVOID) | (1 << yaplParser.LET) | (1 << yaplParser.WHILE) | (1 << yaplParser.NEW) | (1 << yaplParser.TRUE) | (1 << yaplParser.STRING) | (1 << yaplParser.INT) | (1 << yaplParser.IDENTIFIER))) !== 0) || _la === yaplParser.INTEGER_NEGATIVE);\n                            this.state = 116;\n                            this.match(yaplParser.T__2);\n                        }\n                        break;\n                    case 5:\n                        {\n                            _localctx = new LetInContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 118;\n                            this.match(yaplParser.LET);\n                            this.state = 119;\n                            this.assignmentExpr();\n                            this.state = 124;\n                            this._errHandler.sync(this);\n                            _la = this._input.LA(1);\n                            while (_la === yaplParser.T__4) {\n                                {\n                                    {\n                                        this.state = 120;\n                                        this.match(yaplParser.T__4);\n                                        this.state = 121;\n                                        this.assignmentExpr();\n                                    }\n                                }\n                                this.state = 126;\n                                this._errHandler.sync(this);\n                                _la = this._input.LA(1);\n                            }\n                            this.state = 127;\n                            this.match(yaplParser.IN);\n                            this.state = 128;\n                            this.expression(19);\n                        }\n                        break;\n                    case 6:\n                        {\n                            _localctx = new NewContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 130;\n                            this.match(yaplParser.NEW);\n                            this.state = 131;\n                            this.match(yaplParser.TYPE);\n                        }\n                        break;\n                    case 7:\n                        {\n                            _localctx = new NegativeContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 132;\n                            this.match(yaplParser.INTEGER_NEGATIVE);\n                            this.state = 133;\n                            this.expression(17);\n                        }\n                        break;\n                    case 8:\n                        {\n                            _localctx = new IsvoidContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 134;\n                            this.match(yaplParser.ISVOID);\n                            this.state = 135;\n                            this.expression(16);\n                        }\n                        break;\n                    case 9:\n                        {\n                            _localctx = new BoolNotContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 136;\n                            this.match(yaplParser.INTEGER_NEGATIVE);\n                            this.state = 137;\n                            this.expression(8);\n                        }\n                        break;\n                    case 10:\n                        {\n                            _localctx = new ParenthesesContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 138;\n                            this.match(yaplParser.T__3);\n                            this.state = 139;\n                            this.expression(0);\n                            this.state = 140;\n                            this.match(yaplParser.T__5);\n                        }\n                        break;\n                    case 11:\n                        {\n                            _localctx = new IdContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 142;\n                            this.match(yaplParser.IDENTIFIER);\n                        }\n                        break;\n                    case 12:\n                        {\n                            _localctx = new IntContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 143;\n                            this.match(yaplParser.INT);\n                        }\n                        break;\n                    case 13:\n                        {\n                            _localctx = new StringContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 144;\n                            this.match(yaplParser.STRING);\n                        }\n                        break;\n                    case 14:\n                        {\n                            _localctx = new TrueContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 145;\n                            this.match(yaplParser.TRUE);\n                        }\n                        break;\n                    case 15:\n                        {\n                            _localctx = new FalseContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 146;\n                            this.match(yaplParser.FALSE);\n                        }\n                        break;\n                    case 16:\n                        {\n                            _localctx = new AssignmentContext(_localctx);\n                            this._ctx = _localctx;\n                            _prevctx = _localctx;\n                            this.state = 147;\n                            this.match(yaplParser.IDENTIFIER);\n                            this.state = 148;\n                            this.match(yaplParser.ASSIGNMENT);\n                            this.state = 149;\n                            this.expression(1);\n                        }\n                        break;\n                }\n                this._ctx._stop = this._input.tryLT(-1);\n                this.state = 194;\n                this._errHandler.sync(this);\n                _alt = this.interpreter.adaptivePredict(this._input, 17, this._ctx);\n                while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n                    if (_alt === 1) {\n                        if (this._parseListeners != null) {\n                            this.triggerExitRuleEvent();\n                        }\n                        _prevctx = _localctx;\n                        {\n                            this.state = 192;\n                            this._errHandler.sync(this);\n                            switch (this.interpreter.adaptivePredict(this._input, 16, this._ctx)) {\n                                case 1:\n                                    {\n                                        _localctx = new MultiplyContext(new ExpressionContext(_parentctx, _parentState));\n                                        this.pushNewRecursionContext(_localctx, _startState, yaplParser.RULE_expression);\n                                        this.state = 152;\n                                        if (!(this.precpred(this._ctx, 15))) {\n                                            throw this.createFailedPredicateException("this.precpred(this._ctx, 15)");\n                                        }\n                                        this.state = 153;\n                                        this.match(yaplParser.MULTIPLY);\n                                        this.state = 154;\n                                        this.expression(16);\n                                    }\n                                    break;\n                                case 2:\n                                    {\n                                        _localctx = new DivisionContext(new ExpressionContext(_parentctx, _parentState));\n                                        this.pushNewRecursionContext(_localctx, _startState, yaplParser.RULE_expression);\n                                        this.state = 155;\n                                        if (!(this.precpred(this._ctx, 14))) {\n                                            throw this.createFailedPredicateException("this.precpred(this._ctx, 14)");\n                                        }\n                                        this.state = 156;\n                                        this.match(yaplParser.DIVISION);\n                                        this.state = 157;\n                                        this.expression(15);\n                                    }\n                                    break;\n                                case 3:\n                                    {\n                                        _localctx = new AddContext(new ExpressionContext(_parentctx, _parentState));\n                                        this.pushNewRecursionContext(_localctx, _startState, yaplParser.RULE_expression);\n                                        this.state = 158;\n                                        if (!(this.precpred(this._ctx, 13))) {\n                                            throw this.createFailedPredicateException("this.precpred(this._ctx, 13)");\n                                        }\n                                        this.state = 159;\n                                        this.match(yaplParser.ADD);\n                                        this.state = 160;\n                                        this.expression(14);\n                                    }\n                                    break;\n                                case 4:\n                                    {\n                                        _localctx = new MinusContext(new ExpressionContext(_parentctx, _parentState));\n                                        this.pushNewRecursionContext(_localctx, _startState, yaplParser.RULE_expression);\n                                        this.state = 161;\n                                        if (!(this.precpred(this._ctx, 12))) {\n                                            throw this.createFailedPredicateException("this.precpred(this._ctx, 12)");\n                                        }\n                                        this.state = 162;\n                                        this.match(yaplParser.MINUS);\n                                        this.state = 163;\n                                        this.expression(13);\n                                    }\n                                    break;\n                                case 5:\n                                    {\n                                        _localctx = new LessThanContext(new ExpressionContext(_parentctx, _parentState));\n                                        this.pushNewRecursionContext(_localctx, _startState, yaplParser.RULE_expression);\n                                        this.state = 164;\n                                        if (!(this.precpred(this._ctx, 11))) {\n                                            throw this.createFailedPredicateException("this.precpred(this._ctx, 11)");\n                                        }\n                                        this.state = 165;\n                                        this.match(yaplParser.LESS_THAN);\n                                        this.state = 166;\n                                        this.expression(12);\n                                    }\n                                    break;\n                                case 6:\n                                    {\n                                        _localctx = new LessEqualContext(new ExpressionContext(_parentctx, _parentState));\n                                        this.pushNewRecursionContext(_localctx, _startState, yaplParser.RULE_expression);\n                                        this.state = 167;\n                                        if (!(this.precpred(this._ctx, 10))) {\n                                            throw this.createFailedPredicateException("this.precpred(this._ctx, 10)");\n                                        }\n                                        this.state = 168;\n                                        this.match(yaplParser.LESS_EQUAL);\n                                        this.state = 169;\n                                        this.expression(11);\n                                    }\n                                    break;\n                                case 7:\n                                    {\n                                        _localctx = new EqualContext(new ExpressionContext(_parentctx, _parentState));\n                                        this.pushNewRecursionContext(_localctx, _startState, yaplParser.RULE_expression);\n                                        this.state = 170;\n                                        if (!(this.precpred(this._ctx, 9))) {\n                                            throw this.createFailedPredicateException("this.precpred(this._ctx, 9)");\n                                        }\n                                        this.state = 171;\n                                        this.match(yaplParser.EQUAL);\n                                        this.state = 172;\n                                        this.expression(10);\n                                    }\n                                    break;\n                                case 8:\n                                    {\n                                        _localctx = new MethodCallContext(new ExpressionContext(_parentctx, _parentState));\n                                        this.pushNewRecursionContext(_localctx, _startState, yaplParser.RULE_expression);\n                                        this.state = 173;\n                                        if (!(this.precpred(this._ctx, 24))) {\n                                            throw this.createFailedPredicateException("this.precpred(this._ctx, 24)");\n                                        }\n                                        this.state = 176;\n                                        this._errHandler.sync(this);\n                                        _la = this._input.LA(1);\n                                        if (_la === yaplParser.T__7) {\n                                            {\n                                                this.state = 174;\n                                                this.match(yaplParser.T__7);\n                                                this.state = 175;\n                                                this.match(yaplParser.TYPE);\n                                            }\n                                        }\n                                        this.state = 178;\n                                        this.match(yaplParser.T__8);\n                                        this.state = 179;\n                                        this.match(yaplParser.IDENTIFIER);\n                                        this.state = 180;\n                                        this.match(yaplParser.T__3);\n                                        this.state = 189;\n                                        this._errHandler.sync(this);\n                                        _la = this._input.LA(1);\n                                        if ((((_la) & ~0x1F) === 0 && ((1 << _la) & ((1 << yaplParser.T__1) | (1 << yaplParser.T__3) | (1 << yaplParser.FALSE) | (1 << yaplParser.IF) | (1 << yaplParser.ISVOID) | (1 << yaplParser.LET) | (1 << yaplParser.WHILE) | (1 << yaplParser.NEW) | (1 << yaplParser.TRUE) | (1 << yaplParser.STRING) | (1 << yaplParser.INT) | (1 << yaplParser.IDENTIFIER))) !== 0) || _la === yaplParser.INTEGER_NEGATIVE) {\n                                            {\n                                                this.state = 181;\n                                                this.expression(0);\n                                                this.state = 186;\n                                                this._errHandler.sync(this);\n                                                _la = this._input.LA(1);\n                                                while (_la === yaplParser.T__4) {\n                                                    {\n                                                        {\n                                                            this.state = 182;\n                                                            this.match(yaplParser.T__4);\n                                                            this.state = 183;\n                                                            this.expression(0);\n                                                        }\n                                                    }\n                                                    this.state = 188;\n                                                    this._errHandler.sync(this);\n                                                    _la = this._input.LA(1);\n                                                }\n                                            }\n                                        }\n                                        this.state = 191;\n                                        this.match(yaplParser.T__5);\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n                    this.state = 196;\n                    this._errHandler.sync(this);\n                    _alt = this.interpreter.adaptivePredict(this._input, 17, this._ctx);\n                }\n            }\n        }\n        catch (re) {\n            if (re instanceof RecognitionException_1.RecognitionException) {\n                _localctx.exception = re;\n                this._errHandler.reportError(this, re);\n                this._errHandler.recover(this, re);\n            }\n            else {\n                throw re;\n            }\n        }\n        finally {\n            this.unrollRecursionContexts(_parentctx);\n        }\n        return _localctx;\n    }\n    sempred(_localctx, ruleIndex, predIndex) {\n        switch (ruleIndex) {\n            case 6:\n                return this.expression_sempred(_localctx, predIndex);\n        }\n        return true;\n    }\n    expression_sempred(_localctx, predIndex) {\n        switch (predIndex) {\n            case 0:\n                return this.precpred(this._ctx, 15);\n            case 1:\n                return this.precpred(this._ctx, 14);\n            case 2:\n                return this.precpred(this._ctx, 13);\n            case 3:\n                return this.precpred(this._ctx, 12);\n            case 4:\n                return this.precpred(this._ctx, 11);\n            case 5:\n                return this.precpred(this._ctx, 10);\n            case 6:\n                return this.precpred(this._ctx, 9);\n            case 7:\n                return this.precpred(this._ctx, 24);\n        }\n        return true;\n    }\n    static _serializedATN = "\\x03\\uC91D\\uCABA\\u058D\\uAFBA\\u4F53\\u0607\\uEA8B\\uC241\\x030\\xC8\\x04\\x02" +\n        "\\t\\x02\\x04\\x03\\t\\x03\\x04\\x04\\t\\x04\\x04\\x05\\t\\x05\\x04\\x06\\t\\x06\\x04\\x07" +\n        "\\t\\x07\\x04\\b\\t\\b\\x03\\x02\\x03\\x02\\x03\\x02\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03" +\n        "\\x03\\x03\\x05\\x03\\x19\\n\\x03\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x05\\x04\\x1F" +\n        "\\n\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x07\\x04%\\n\\x04\\f\\x04\\x0E\\x04(\\v" +\n        "\\x04\\x03\\x04\\x03\\x04\\x03\\x05\\x03\\x05\\x03\\x05\\x03\\x05\\x03\\x05\\x07\\x051" +\n        "\\n\\x05\\f\\x05\\x0E\\x054\\v\\x05\\x05\\x056\\n\\x05\\x03\\x05\\x03\\x05\\x03\\x05\\x03" +\n        "\\x05\\x03\\x05\\x03\\x05\\x03\\x05\\x03\\x05\\x03\\x05\\x03\\x05\\x03\\x05\\x03\\x05\\x05" +\n        "\\x05D\\n\\x05\\x05\\x05F\\n\\x05\\x03\\x06\\x03\\x06\\x03\\x06\\x03\\x06\\x03\\x07\\x03" +\n        "\\x07\\x03\\x07\\x03\\x07\\x03\\x07\\x05\\x07Q\\n\\x07\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03" +\n        "\\b\\x03\\b\\x07\\bY\\n\\b\\f\\b\\x0E\\b\\\\\\v\\b\\x05\\b^\\n\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b" +\n        "\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03" +\n        "\\b\\x03\\b\\x03\\b\\x03\\b\\x06\\bs\\n\\b\\r\\b\\x0E\\bt\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03" +\n        "\\b\\x03\\b\\x07\\b}\\n\\b\\f\\b\\x0E\\b\\x80\\v\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03" +\n        "\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03" +\n        "\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x05\\b\\x99\\n\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b" +\n        "\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03" +\n        "\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x05\\b\\xB3\\n\\b\\x03\\b" +\n        "\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x03\\b\\x07\\b\\xBB\\n\\b\\f\\b\\x0E\\b\\xBE\\v\\b\\x05\\b\\xC0" +\n        "\\n\\b\\x03\\b\\x07\\b\\xC3\\n\\b\\f\\b\\x0E\\b\\xC6\\v\\b\\x03\\b\\x02\\x02\\x03\\x0E\\t\\x02" +\n        "\\x02\\x04\\x02\\x06\\x02\\b\\x02\\n\\x02\\f\\x02\\x0E\\x02\\x02\\x02\\x02\\xE6\\x02\\x10" +\n        "\\x03\\x02\\x02\\x02\\x04\\x18\\x03\\x02\\x02\\x02\\x06\\x1A\\x03\\x02\\x02\\x02\\bE\\x03" +\n        "\\x02\\x02\\x02\\nG\\x03\\x02\\x02\\x02\\fK\\x03\\x02\\x02\\x02\\x0E\\x98\\x03\\x02\\x02" +\n        "\\x02\\x10\\x11\\x05\\x04\\x03\\x02\\x11\\x12\\x07\\x02\\x02\\x03\\x12\\x03\\x03\\x02\\x02" +\n        "\\x02\\x13\\x14\\x05\\x06\\x04\\x02\\x14\\x15\\x07\\x03\\x02\\x02\\x15\\x16\\x05\\x04\\x03" +\n        "\\x02\\x16\\x19\\x03\\x02\\x02\\x02\\x17\\x19\\x07\\x02\\x02\\x03\\x18\\x13\\x03\\x02\\x02" +\n        "\\x02\\x18\\x17\\x03\\x02\\x02\\x02\\x19\\x05\\x03\\x02\\x02\\x02\\x1A\\x1B\\x07\\f\\x02" +\n        "\\x02\\x1B\\x1E\\x07 \\x02\\x02\\x1C\\x1D\\x07\\x12\\x02\\x02\\x1D\\x1F\\x07 \\x02\\x02" +\n        "\\x1E\\x1C\\x03\\x02\\x02\\x02\\x1E\\x1F\\x03\\x02\\x02\\x02\\x1F \\x03\\x02\\x02\\x02" +\n        " &\\x07\\x04\\x02\\x02!\\"\\x05\\b\\x05\\x02\\"#\\x07\\x03\\x02\\x02#%\\x03\\x02\\x02\\x02" +\n        "$!\\x03\\x02\\x02\\x02%(\\x03\\x02\\x02\\x02&$\\x03\\x02\\x02\\x02&\\\'\\x03\\x02\\x02" +\n        "\\x02\\\')\\x03\\x02\\x02\\x02(&\\x03\\x02\\x02\\x02)*\\x07\\x05\\x02\\x02*\\x07\\x03\\x02" +\n        "\\x02\\x02+,\\x07!\\x02\\x02,5\\x07\\x06\\x02\\x02-2\\x05\\n\\x06\\x02./\\x07\\x07\\x02" +\n        "\\x02/1\\x05\\n\\x06\\x020.\\x03\\x02\\x02\\x0214\\x03\\x02\\x02\\x0220\\x03\\x02\\x02" +\n        "\\x0223\\x03\\x02\\x02\\x0236\\x03\\x02\\x02\\x0242\\x03\\x02\\x02\\x025-\\x03\\x02\\x02" +\n        "\\x0256\\x03\\x02\\x02\\x0267\\x03\\x02\\x02\\x0278\\x07\\b\\x02\\x0289\\x07\\t\\x02\\x02" +\n        "9:\\x07 \\x02\\x02:;\\x07\\x04\\x02\\x02;<\\x05\\x0E\\b\\x02<=\\x07\\x05\\x02\\x02=F" +\n        "\\x03\\x02\\x02\\x02>?\\x07!\\x02\\x02?@\\x07\\t\\x02\\x02@C\\x07 \\x02\\x02AB\\x07\\"" +\n        "\\x02\\x02BD\\x05\\x0E\\b\\x02CA\\x03\\x02\\x02\\x02CD\\x03\\x02\\x02\\x02DF\\x03\\x02" +\n        "\\x02\\x02E+\\x03\\x02\\x02\\x02E>\\x03\\x02\\x02\\x02F\\t\\x03\\x02\\x02\\x02GH\\x07" +\n        "!\\x02\\x02HI\\x07\\t\\x02\\x02IJ\\x07 \\x02\\x02J\\v\\x03\\x02\\x02\\x02KL\\x07!\\x02" +\n        "\\x02LM\\x07\\t\\x02\\x02MP\\x07 \\x02\\x02NO\\x07\\"\\x02\\x02OQ\\x05\\x0E\\b\\x02PN" +\n        "\\x03\\x02\\x02\\x02PQ\\x03\\x02\\x02\\x02Q\\r\\x03\\x02\\x02\\x02RS\\b\\b\\x01\\x02ST" +\n        "\\x07!\\x02\\x02T]\\x07\\x06\\x02\\x02UZ\\x05\\x0E\\b\\x02VW\\x07\\x07\\x02\\x02WY\\x05" +\n        "\\x0E\\b\\x02XV\\x03\\x02\\x02\\x02Y\\\\\\x03\\x02\\x02\\x02ZX\\x03\\x02\\x02\\x02Z[\\x03" +\n        "\\x02\\x02\\x02[^\\x03\\x02\\x02\\x02\\\\Z\\x03\\x02\\x02\\x02]U\\x03\\x02\\x02\\x02]^" +\n        "\\x03\\x02\\x02\\x02^_\\x03\\x02\\x02\\x02_\\x99\\x07\\b\\x02\\x02`a\\x07\\x10\\x02\\x02" +\n        "ab\\x05\\x0E\\b\\x02bc\\x07\\x17\\x02\\x02cd\\x05\\x0E\\b\\x02de\\x07\\r\\x02\\x02ef\\x05" +\n        "\\x0E\\b\\x02fg\\x07\\x0F\\x02\\x02g\\x99\\x03\\x02\\x02\\x02hi\\x07\\x18\\x02\\x02ij" +\n        "\\x05\\x0E\\b\\x02jk\\x07\\x15\\x02\\x02kl\\x05\\x0E\\b\\x02lm\\x07\\x16\\x02\\x02m\\x99" +\n        "\\x03\\x02\\x02\\x02nr\\x07\\x04\\x02\\x02op\\x05\\x0E\\b\\x02pq\\x07\\x03\\x02\\x02q" +\n        "s\\x03\\x02\\x02\\x02ro\\x03\\x02\\x02\\x02st\\x03\\x02\\x02\\x02tr\\x03\\x02\\x02\\x02" +\n        "tu\\x03\\x02\\x02\\x02uv\\x03\\x02\\x02\\x02vw\\x07\\x05\\x02\\x02w\\x99\\x03\\x02\\x02" +\n        "\\x02xy\\x07\\x14\\x02\\x02y~\\x05\\f\\x07\\x02z{\\x07\\x07\\x02\\x02{}\\x05\\f\\x07\\x02" +\n        "|z\\x03\\x02\\x02\\x02}\\x80\\x03\\x02\\x02\\x02~|\\x03\\x02\\x02\\x02~\\x7F\\x03\\x02" +\n        "\\x02\\x02\\x7F\\x81\\x03\\x02\\x02\\x02\\x80~\\x03\\x02\\x02\\x02\\x81\\x82\\x07\\x11" +\n        "\\x02\\x02\\x82\\x83\\x05\\x0E\\b\\x15\\x83\\x99\\x03\\x02\\x02\\x02\\x84\\x85\\x07\\x1B" +\n        "\\x02\\x02\\x85\\x99\\x07 \\x02\\x02\\x86\\x87\\x07+\\x02\\x02\\x87\\x99\\x05\\x0E\\b\\x13" +\n        "\\x88\\x89\\x07\\x13\\x02\\x02\\x89\\x99\\x05\\x0E\\b\\x12\\x8A\\x8B\\x07+\\x02\\x02\\x8B" +\n        "\\x99\\x05\\x0E\\b\\n\\x8C\\x8D\\x07\\x06\\x02\\x02\\x8D\\x8E\\x05\\x0E\\b\\x02\\x8E\\x8F" +\n        "\\x07\\b\\x02\\x02\\x8F\\x99\\x03\\x02\\x02\\x02\\x90\\x99\\x07!\\x02\\x02\\x91\\x99\\x07" +\n        "\\x1F\\x02\\x02\\x92\\x99\\x07\\x1E\\x02\\x02\\x93\\x99\\x07\\x1D\\x02\\x02\\x94\\x99\\x07" +\n        "\\x0E\\x02\\x02\\x95\\x96\\x07!\\x02\\x02\\x96\\x97\\x07\\"\\x02\\x02\\x97\\x99\\x05\\x0E" +\n        "\\b\\x03\\x98R\\x03\\x02\\x02\\x02\\x98`\\x03\\x02\\x02\\x02\\x98h\\x03\\x02\\x02\\x02" +\n        "\\x98n\\x03\\x02\\x02\\x02\\x98x\\x03\\x02\\x02\\x02\\x98\\x84\\x03\\x02\\x02\\x02\\x98" +\n        "\\x86\\x03\\x02\\x02\\x02\\x98\\x88\\x03\\x02\\x02\\x02\\x98\\x8A\\x03\\x02\\x02\\x02\\x98" +\n        "\\x8C\\x03\\x02\\x02\\x02\\x98\\x90\\x03\\x02\\x02\\x02\\x98\\x91\\x03\\x02\\x02\\x02\\x98" +\n        "\\x92\\x03\\x02\\x02\\x02\\x98\\x93\\x03\\x02\\x02\\x02\\x98\\x94\\x03\\x02\\x02\\x02\\x98" +\n        "\\x95\\x03\\x02\\x02\\x02\\x99\\xC4\\x03\\x02\\x02\\x02\\x9A\\x9B\\f\\x11\\x02\\x02\\x9B" +\n        "\\x9C\\x07&\\x02\\x02\\x9C\\xC3\\x05\\x0E\\b\\x12\\x9D\\x9E\\f\\x10\\x02\\x02\\x9E\\x9F" +\n        "\\x07\\\'\\x02\\x02\\x9F\\xC3\\x05\\x0E\\b\\x11\\xA0\\xA1\\f\\x0F\\x02\\x02\\xA1\\xA2\\x07" +\n        "$\\x02\\x02\\xA2\\xC3\\x05\\x0E\\b\\x10\\xA3\\xA4\\f\\x0E\\x02\\x02\\xA4\\xA5\\x07%\\x02" +\n        "\\x02\\xA5\\xC3\\x05\\x0E\\b\\x0F\\xA6\\xA7\\f\\r\\x02\\x02\\xA7\\xA8\\x07(\\x02\\x02\\xA8" +\n        "\\xC3\\x05\\x0E\\b\\x0E\\xA9\\xAA\\f\\f\\x02\\x02\\xAA\\xAB\\x07)\\x02\\x02\\xAB\\xC3\\x05" +\n        "\\x0E\\b\\r\\xAC\\xAD\\f\\v\\x02\\x02\\xAD\\xAE\\x07*\\x02\\x02\\xAE\\xC3\\x05\\x0E\\b\\f" +\n        "\\xAF\\xB2\\f\\x1A\\x02\\x02\\xB0\\xB1\\x07\\n\\x02\\x02\\xB1\\xB3\\x07 \\x02\\x02\\xB2" +\n        "\\xB0\\x03\\x02\\x02\\x02\\xB2\\xB3\\x03\\x02\\x02\\x02\\xB3\\xB4\\x03\\x02\\x02\\x02\\xB4" +\n        "\\xB5\\x07\\v\\x02\\x02\\xB5\\xB6\\x07!\\x02\\x02\\xB6\\xBF\\x07\\x06\\x02\\x02\\xB7\\xBC" +\n        "\\x05\\x0E\\b\\x02\\xB8\\xB9\\x07\\x07\\x02\\x02\\xB9\\xBB\\x05\\x0E\\b\\x02\\xBA\\xB8\\x03" +\n        "\\x02\\x02\\x02\\xBB\\xBE\\x03\\x02\\x02\\x02\\xBC\\xBA\\x03\\x02\\x02\\x02\\xBC\\xBD\\x03" +\n        "\\x02\\x02\\x02\\xBD\\xC0\\x03\\x02\\x02\\x02\\xBE\\xBC\\x03\\x02\\x02\\x02\\xBF\\xB7\\x03" +\n        "\\x02\\x02\\x02\\xBF\\xC0\\x03\\x02\\x02\\x02\\xC0\\xC1\\x03\\x02\\x02\\x02\\xC1\\xC3\\x07" +\n        "\\b\\x02\\x02\\xC2\\x9A\\x03\\x02\\x02\\x02\\xC2\\x9D\\x03\\x02\\x02\\x02\\xC2\\xA0\\x03" +\n        "\\x02\\x02\\x02\\xC2\\xA3\\x03\\x02\\x02\\x02\\xC2\\xA6\\x03\\x02\\x02\\x02\\xC2\\xA9\\x03" +\n        "\\x02\\x02\\x02\\xC2\\xAC\\x03\\x02\\x02\\x02\\xC2\\xAF\\x03\\x02\\x02\\x02\\xC3\\xC6\\x03" +\n        "\\x02\\x02\\x02\\xC4\\xC2\\x03\\x02\\x02\\x02\\xC4\\xC5\\x03\\x02\\x02\\x02\\xC5\\x0F\\x03" +\n        "\\x02\\x02\\x02\\xC6\\xC4\\x03\\x02\\x02\\x02\\x14\\x18\\x1E&25CEPZ]t~\\x98\\xB2\\xBC" +\n        "\\xBF\\xC2\\xC4";\n    static __ATN;\n    static get _ATN() {\n        if (!yaplParser.__ATN) {\n            yaplParser.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(yaplParser._serializedATN));\n        }\n        return yaplParser.__ATN;\n    }\n}\nexports.yaplParser = yaplParser;\nclass ProgramContext extends ParserRuleContext_1.ParserRuleContext {\n    programBlocks() {\n        return this.getRuleContext(0, ProgramBlocksContext);\n    }\n    EOF() { return this.getToken(yaplParser.EOF, 0); }\n    constructor(parent, invokingState) {\n        super(parent, invokingState);\n    }\n    // @Override\n    get ruleIndex() { return yaplParser.RULE_program; }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterProgram) {\n            listener.enterProgram(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitProgram) {\n            listener.exitProgram(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitProgram) {\n            return visitor.visitProgram(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.ProgramContext = ProgramContext;\nclass ProgramBlocksContext extends ParserRuleContext_1.ParserRuleContext {\n    constructor(parent, invokingState) {\n        super(parent, invokingState);\n    }\n    // @Override\n    get ruleIndex() { return yaplParser.RULE_programBlocks; }\n    copyFrom(ctx) {\n        super.copyFrom(ctx);\n    }\n}\nexports.ProgramBlocksContext = ProgramBlocksContext;\nclass ClassesContext extends ProgramBlocksContext {\n    classDefine() {\n        return this.getRuleContext(0, ClassDefineContext);\n    }\n    programBlocks() {\n        return this.getRuleContext(0, ProgramBlocksContext);\n    }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterClasses) {\n            listener.enterClasses(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitClasses) {\n            listener.exitClasses(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitClasses) {\n            return visitor.visitClasses(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.ClassesContext = ClassesContext;\nclass EofContext extends ProgramBlocksContext {\n    EOF() { return this.getToken(yaplParser.EOF, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterEof) {\n            listener.enterEof(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitEof) {\n            listener.exitEof(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitEof) {\n            return visitor.visitEof(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.EofContext = EofContext;\nclass ClassDefineContext extends ParserRuleContext_1.ParserRuleContext {\n    CLASS() { return this.getToken(yaplParser.CLASS, 0); }\n    TYPE(i) {\n        if (i === undefined) {\n            return this.getTokens(yaplParser.TYPE);\n        }\n        else {\n            return this.getToken(yaplParser.TYPE, i);\n        }\n    }\n    INHERITS() { return this.tryGetToken(yaplParser.INHERITS, 0); }\n    feature(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(FeatureContext);\n        }\n        else {\n            return this.getRuleContext(i, FeatureContext);\n        }\n    }\n    constructor(parent, invokingState) {\n        super(parent, invokingState);\n    }\n    // @Override\n    get ruleIndex() { return yaplParser.RULE_classDefine; }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterClassDefine) {\n            listener.enterClassDefine(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitClassDefine) {\n            listener.exitClassDefine(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitClassDefine) {\n            return visitor.visitClassDefine(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.ClassDefineContext = ClassDefineContext;\nclass FeatureContext extends ParserRuleContext_1.ParserRuleContext {\n    constructor(parent, invokingState) {\n        super(parent, invokingState);\n    }\n    // @Override\n    get ruleIndex() { return yaplParser.RULE_feature; }\n    copyFrom(ctx) {\n        super.copyFrom(ctx);\n    }\n}\nexports.FeatureContext = FeatureContext;\nclass MethodContext extends FeatureContext {\n    IDENTIFIER() { return this.getToken(yaplParser.IDENTIFIER, 0); }\n    TYPE() { return this.getToken(yaplParser.TYPE, 0); }\n    expression() {\n        return this.getRuleContext(0, ExpressionContext);\n    }\n    formal(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(FormalContext);\n        }\n        else {\n            return this.getRuleContext(i, FormalContext);\n        }\n    }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterMethod) {\n            listener.enterMethod(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitMethod) {\n            listener.exitMethod(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitMethod) {\n            return visitor.visitMethod(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.MethodContext = MethodContext;\nclass PropertyContext extends FeatureContext {\n    IDENTIFIER() { return this.getToken(yaplParser.IDENTIFIER, 0); }\n    TYPE() { return this.getToken(yaplParser.TYPE, 0); }\n    ASSIGNMENT() { return this.tryGetToken(yaplParser.ASSIGNMENT, 0); }\n    expression() {\n        return this.tryGetRuleContext(0, ExpressionContext);\n    }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterProperty) {\n            listener.enterProperty(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitProperty) {\n            listener.exitProperty(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitProperty) {\n            return visitor.visitProperty(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.PropertyContext = PropertyContext;\nclass FormalContext extends ParserRuleContext_1.ParserRuleContext {\n    IDENTIFIER() { return this.getToken(yaplParser.IDENTIFIER, 0); }\n    TYPE() { return this.getToken(yaplParser.TYPE, 0); }\n    constructor(parent, invokingState) {\n        super(parent, invokingState);\n    }\n    // @Override\n    get ruleIndex() { return yaplParser.RULE_formal; }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterFormal) {\n            listener.enterFormal(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitFormal) {\n            listener.exitFormal(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitFormal) {\n            return visitor.visitFormal(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.FormalContext = FormalContext;\nclass AssignmentExprContext extends ParserRuleContext_1.ParserRuleContext {\n    IDENTIFIER() { return this.getToken(yaplParser.IDENTIFIER, 0); }\n    TYPE() { return this.getToken(yaplParser.TYPE, 0); }\n    ASSIGNMENT() { return this.tryGetToken(yaplParser.ASSIGNMENT, 0); }\n    expression() {\n        return this.tryGetRuleContext(0, ExpressionContext);\n    }\n    constructor(parent, invokingState) {\n        super(parent, invokingState);\n    }\n    // @Override\n    get ruleIndex() { return yaplParser.RULE_assignmentExpr; }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterAssignmentExpr) {\n            listener.enterAssignmentExpr(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitAssignmentExpr) {\n            listener.exitAssignmentExpr(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitAssignmentExpr) {\n            return visitor.visitAssignmentExpr(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.AssignmentExprContext = AssignmentExprContext;\nclass ExpressionContext extends ParserRuleContext_1.ParserRuleContext {\n    constructor(parent, invokingState) {\n        super(parent, invokingState);\n    }\n    // @Override\n    get ruleIndex() { return yaplParser.RULE_expression; }\n    copyFrom(ctx) {\n        super.copyFrom(ctx);\n    }\n}\nexports.ExpressionContext = ExpressionContext;\nclass MethodCallContext extends ExpressionContext {\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    IDENTIFIER() { return this.getToken(yaplParser.IDENTIFIER, 0); }\n    TYPE() { return this.tryGetToken(yaplParser.TYPE, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterMethodCall) {\n            listener.enterMethodCall(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitMethodCall) {\n            listener.exitMethodCall(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitMethodCall) {\n            return visitor.visitMethodCall(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.MethodCallContext = MethodCallContext;\nclass OwnMethodCallContext extends ExpressionContext {\n    IDENTIFIER() { return this.getToken(yaplParser.IDENTIFIER, 0); }\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterOwnMethodCall) {\n            listener.enterOwnMethodCall(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitOwnMethodCall) {\n            listener.exitOwnMethodCall(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitOwnMethodCall) {\n            return visitor.visitOwnMethodCall(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.OwnMethodCallContext = OwnMethodCallContext;\nclass IfContext extends ExpressionContext {\n    IF() { return this.getToken(yaplParser.IF, 0); }\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    THEN() { return this.getToken(yaplParser.THEN, 0); }\n    ELSE() { return this.getToken(yaplParser.ELSE, 0); }\n    FI() { return this.getToken(yaplParser.FI, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterIf) {\n            listener.enterIf(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitIf) {\n            listener.exitIf(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitIf) {\n            return visitor.visitIf(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.IfContext = IfContext;\nclass WhileContext extends ExpressionContext {\n    WHILE() { return this.getToken(yaplParser.WHILE, 0); }\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    LOOP() { return this.getToken(yaplParser.LOOP, 0); }\n    POOL() { return this.getToken(yaplParser.POOL, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterWhile) {\n            listener.enterWhile(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitWhile) {\n            listener.exitWhile(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitWhile) {\n            return visitor.visitWhile(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.WhileContext = WhileContext;\nclass BlockContext extends ExpressionContext {\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterBlock) {\n            listener.enterBlock(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitBlock) {\n            listener.exitBlock(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitBlock) {\n            return visitor.visitBlock(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.BlockContext = BlockContext;\nclass LetInContext extends ExpressionContext {\n    LET() { return this.getToken(yaplParser.LET, 0); }\n    assignmentExpr(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(AssignmentExprContext);\n        }\n        else {\n            return this.getRuleContext(i, AssignmentExprContext);\n        }\n    }\n    IN() { return this.getToken(yaplParser.IN, 0); }\n    expression() {\n        return this.getRuleContext(0, ExpressionContext);\n    }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterLetIn) {\n            listener.enterLetIn(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitLetIn) {\n            listener.exitLetIn(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitLetIn) {\n            return visitor.visitLetIn(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.LetInContext = LetInContext;\nclass NewContext extends ExpressionContext {\n    NEW() { return this.getToken(yaplParser.NEW, 0); }\n    TYPE() { return this.getToken(yaplParser.TYPE, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterNew) {\n            listener.enterNew(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitNew) {\n            listener.exitNew(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitNew) {\n            return visitor.visitNew(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.NewContext = NewContext;\nclass NegativeContext extends ExpressionContext {\n    INTEGER_NEGATIVE() { return this.getToken(yaplParser.INTEGER_NEGATIVE, 0); }\n    expression() {\n        return this.getRuleContext(0, ExpressionContext);\n    }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterNegative) {\n            listener.enterNegative(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitNegative) {\n            listener.exitNegative(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitNegative) {\n            return visitor.visitNegative(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.NegativeContext = NegativeContext;\nclass IsvoidContext extends ExpressionContext {\n    ISVOID() { return this.getToken(yaplParser.ISVOID, 0); }\n    expression() {\n        return this.getRuleContext(0, ExpressionContext);\n    }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterIsvoid) {\n            listener.enterIsvoid(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitIsvoid) {\n            listener.exitIsvoid(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitIsvoid) {\n            return visitor.visitIsvoid(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.IsvoidContext = IsvoidContext;\nclass MultiplyContext extends ExpressionContext {\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    MULTIPLY() { return this.getToken(yaplParser.MULTIPLY, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterMultiply) {\n            listener.enterMultiply(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitMultiply) {\n            listener.exitMultiply(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitMultiply) {\n            return visitor.visitMultiply(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.MultiplyContext = MultiplyContext;\nclass DivisionContext extends ExpressionContext {\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    DIVISION() { return this.getToken(yaplParser.DIVISION, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterDivision) {\n            listener.enterDivision(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitDivision) {\n            listener.exitDivision(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitDivision) {\n            return visitor.visitDivision(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.DivisionContext = DivisionContext;\nclass AddContext extends ExpressionContext {\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    ADD() { return this.getToken(yaplParser.ADD, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterAdd) {\n            listener.enterAdd(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitAdd) {\n            listener.exitAdd(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitAdd) {\n            return visitor.visitAdd(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.AddContext = AddContext;\nclass MinusContext extends ExpressionContext {\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    MINUS() { return this.getToken(yaplParser.MINUS, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterMinus) {\n            listener.enterMinus(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitMinus) {\n            listener.exitMinus(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitMinus) {\n            return visitor.visitMinus(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.MinusContext = MinusContext;\nclass LessThanContext extends ExpressionContext {\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    LESS_THAN() { return this.getToken(yaplParser.LESS_THAN, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterLessThan) {\n            listener.enterLessThan(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitLessThan) {\n            listener.exitLessThan(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitLessThan) {\n            return visitor.visitLessThan(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.LessThanContext = LessThanContext;\nclass LessEqualContext extends ExpressionContext {\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    LESS_EQUAL() { return this.getToken(yaplParser.LESS_EQUAL, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterLessEqual) {\n            listener.enterLessEqual(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitLessEqual) {\n            listener.exitLessEqual(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitLessEqual) {\n            return visitor.visitLessEqual(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.LessEqualContext = LessEqualContext;\nclass EqualContext extends ExpressionContext {\n    expression(i) {\n        if (i === undefined) {\n            return this.getRuleContexts(ExpressionContext);\n        }\n        else {\n            return this.getRuleContext(i, ExpressionContext);\n        }\n    }\n    EQUAL() { return this.getToken(yaplParser.EQUAL, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterEqual) {\n            listener.enterEqual(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitEqual) {\n            listener.exitEqual(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitEqual) {\n            return visitor.visitEqual(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.EqualContext = EqualContext;\nclass BoolNotContext extends ExpressionContext {\n    INTEGER_NEGATIVE() { return this.getToken(yaplParser.INTEGER_NEGATIVE, 0); }\n    expression() {\n        return this.getRuleContext(0, ExpressionContext);\n    }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterBoolNot) {\n            listener.enterBoolNot(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitBoolNot) {\n            listener.exitBoolNot(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitBoolNot) {\n            return visitor.visitBoolNot(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.BoolNotContext = BoolNotContext;\nclass ParenthesesContext extends ExpressionContext {\n    expression() {\n        return this.getRuleContext(0, ExpressionContext);\n    }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterParentheses) {\n            listener.enterParentheses(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitParentheses) {\n            listener.exitParentheses(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitParentheses) {\n            return visitor.visitParentheses(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.ParenthesesContext = ParenthesesContext;\nclass IdContext extends ExpressionContext {\n    IDENTIFIER() { return this.getToken(yaplParser.IDENTIFIER, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterId) {\n            listener.enterId(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitId) {\n            listener.exitId(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitId) {\n            return visitor.visitId(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.IdContext = IdContext;\nclass IntContext extends ExpressionContext {\n    INT() { return this.getToken(yaplParser.INT, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterInt) {\n            listener.enterInt(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitInt) {\n            listener.exitInt(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitInt) {\n            return visitor.visitInt(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.IntContext = IntContext;\nclass StringContext extends ExpressionContext {\n    STRING() { return this.getToken(yaplParser.STRING, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterString) {\n            listener.enterString(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitString) {\n            listener.exitString(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitString) {\n            return visitor.visitString(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.StringContext = StringContext;\nclass TrueContext extends ExpressionContext {\n    TRUE() { return this.getToken(yaplParser.TRUE, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterTrue) {\n            listener.enterTrue(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitTrue) {\n            listener.exitTrue(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitTrue) {\n            return visitor.visitTrue(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.TrueContext = TrueContext;\nclass FalseContext extends ExpressionContext {\n    FALSE() { return this.getToken(yaplParser.FALSE, 0); }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterFalse) {\n            listener.enterFalse(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitFalse) {\n            listener.exitFalse(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitFalse) {\n            return visitor.visitFalse(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.FalseContext = FalseContext;\nclass AssignmentContext extends ExpressionContext {\n    IDENTIFIER() { return this.getToken(yaplParser.IDENTIFIER, 0); }\n    ASSIGNMENT() { return this.getToken(yaplParser.ASSIGNMENT, 0); }\n    expression() {\n        return this.getRuleContext(0, ExpressionContext);\n    }\n    constructor(ctx) {\n        super(ctx.parent, ctx.invokingState);\n        this.copyFrom(ctx);\n    }\n    // @Override\n    enterRule(listener) {\n        if (listener.enterAssignment) {\n            listener.enterAssignment(this);\n        }\n    }\n    // @Override\n    exitRule(listener) {\n        if (listener.exitAssignment) {\n            listener.exitAssignment(this);\n        }\n    }\n    // @Override\n    accept(visitor) {\n        if (visitor.visitAssignment) {\n            return visitor.visitAssignment(this);\n        }\n        else {\n            return visitor.visitChildren(this);\n        }\n    }\n}\nexports.AssignmentContext = AssignmentContext;\n\n\n//# sourceURL=webpack://proyecto2/./src/antlr/yaplParser.ts?')},"./src/index.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst antlr4ts_1 = __webpack_require__(/*! antlr4ts */ \"antlr4ts\");\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst yaplLexer_1 = __webpack_require__(/*! ./antlr/yaplLexer */ \"./src/antlr/yaplLexer.ts\");\nconst yaplParser_1 = __webpack_require__(/*! ./antlr/yaplParser */ \"./src/antlr/yaplParser.ts\");\nconst yaplVisitor_1 = __webpack_require__(/*! ./yaplVisitor */ \"./src/yaplVisitor.ts\");\nconst Table_1 = __webpack_require__(/*! ./Implementations/Components/Table */ \"./src/Implementations/Components/Table.ts\");\nconst Memory_1 = __webpack_require__(/*! ./Implementations/DataStructures/Memory */ \"./src/Implementations/DataStructures/Memory.ts\");\nconst uuid_1 = __webpack_require__(/*! uuid */ \"uuid\");\nconst TemporaryValues_1 = __webpack_require__(/*! ./Implementations/DataStructures/MemoryVisitors/TemporaryValues */ \"./src/Implementations/DataStructures/MemoryVisitors/TemporaryValues.ts\");\nclass Register {\n    reservedUntil = 0;\n    id = (0, uuid_1.v4)();\n    constructor() { }\n    reserveUntil(until) {\n        this.reservedUntil = until;\n    }\n    isAvailable = () => this.reservedUntil === 0;\n    tick = () => (this.reservedUntil === 0 ? this.reserveUntil : this.reservedUntil--);\n    toString = () => `$t${this.id}`;\n    setId = (id) => (this.id = id);\n}\nclass RegisterManager {\n    registers;\n    constructor(registerNumber) {\n        this.registers = new Array(registerNumber);\n        for (let i = 0; i < registerNumber; i++) {\n            this.registers[i] = new Register();\n        }\n        this.registers.forEach((register, index) => register.setId(index));\n    }\n    getRegister() {\n        const register = this.registers.find((value) => value.isAvailable());\n        if (!register)\n            return null;\n        return register;\n    }\n    tick() {\n        this.registers.forEach((register) => register.tick());\n        this.pairs = this.pairs.filter((pair) => !pair[1].isAvailable());\n    }\n    pairs = [];\n    reserveRegister(usingRegister, forTicks) {\n        const register = this.getRegister();\n        if (!register)\n            return null;\n        register.reserveUntil(forTicks);\n        this.pairs.push([usingRegister, register]);\n        return register;\n    }\n    getPairedRegister(temporal) {\n        return this.pairs.find((pair) => pair[0].id.startsWith(temporal.id))?.[1];\n    }\n}\nconst optimize = (tuples) => {\n    const registerController = new RegisterManager(100);\n    const newTuples = [];\n    const temporalRegex = /T\\{.{3}\\}/;\n    /**\n     *\n     * @param lookingFor What we are trying to find\n     * @param fromIndex From what index\n     * @returns The index of next usage or -1 if not used afterwards\n     */\n    const lastUsage = (lookingFor, fromIndex) => {\n        let lastFound = -1;\n        for (let i = fromIndex + 1; i < tuples.length; i++) {\n            const tuple = tuples[i];\n            const [_op, op1, op2, dest] = tuple;\n            if (op1 === lookingFor ||\n                op2 === lookingFor ||\n                (dest !== lookingFor && temporalRegex.exec(dest?.toString() ?? ''))) {\n                lastFound = i;\n            }\n        }\n        return lastFound;\n    };\n    for (let i = 0; i < tuples.length; i++) {\n        const currentTuple = tuples[i];\n        const [_op, op1, op2, dest] = currentTuple;\n        if (temporalRegex.test(op1.toString())) {\n            const registerUsed = registerController.getPairedRegister(op1);\n            if (registerUsed) {\n                currentTuple[1] = registerUsed.toString();\n            }\n        }\n        if (temporalRegex.test(op2?.toString() ?? '')) {\n            const registerUsed = registerController.getPairedRegister(op2);\n            if (registerUsed) {\n                currentTuple[2] = registerUsed.toString();\n            }\n        }\n        if (!dest) {\n            newTuples.push(currentTuple);\n            continue;\n        }\n        const destString = dest.toString();\n        const result = temporalRegex.exec(destString);\n        if (!result) {\n            newTuples.push(currentTuple);\n            continue;\n        }\n        const foundDest = result[0];\n        const foundTemp = new TemporaryValues_1.TemporalValue();\n        foundTemp.id = foundDest.replace('T{', '').replace('}', '');\n        const pairedRegister = registerController.getPairedRegister(foundTemp);\n        if (pairedRegister) {\n            const newQuadruple = [...currentTuple];\n            newQuadruple[3] = dest.toString().replace(temporalRegex, pairedRegister.toString());\n            // @ts-ignore\n            newTuples.push(newQuadruple);\n            continue;\n        }\n        const lastUsed = lastUsage(foundTemp, i);\n        const lastUsedReservation = lastUsed === -1 ? 0 : lastUsed - i;\n        const newPairedRegister = registerController.reserveRegister(dest, lastUsedReservation);\n        if (!newPairedRegister) {\n            throw new Error('No registers available');\n        }\n        const newQuadruple = [...currentTuple];\n        newQuadruple[3] = dest.toString().replace(temporalRegex, newPairedRegister.toString());\n        // @ts-ignore\n        newTuples.push(newQuadruple);\n        registerController.tick();\n    }\n    const returnTuples = newTuples.map((tuple) => {\n        const [op, op1, op2, dest] = tuple;\n        return [op, op1?.toString() ?? 'null', op2?.toString() ?? 'null', dest?.toString() ?? 'null'];\n    });\n    return returnTuples;\n};\nfunction main(input) {\n    let inputStream = new antlr4ts_1.ANTLRInputStream(input);\n    let lexer = new yaplLexer_1.yaplLexer(inputStream);\n    let tokenStream = new antlr4ts_1.CommonTokenStream(lexer);\n    let parser = new yaplParser_1.yaplParser(tokenStream);\n    let tree = parser.program();\n    const visitor = new yaplVisitor_1.YaplVisitor();\n    // Semantic\n    visitor.visit(tree);\n    const symbolsTable = visitor.symbolsTable;\n    const errors = visitor.errorComponent().getAll();\n    if (errors.length) {\n        console.log('Errors found, aborting');\n        return {\n            errors: errors.map((e) => `[${e.line}: ${e.column}]${e.message}`),\n            quadruples: '',\n            tuples: [],\n        };\n    }\n    // Memory\n    const mainClass = symbolsTable.get('Main');\n    if (!mainClass) {\n        console.log('Main method not found, aborting');\n        return {\n            errors: ['Main method not found'],\n            quadruples: '',\n            tuples: [],\n        };\n    }\n    const mainTable = (0, Table_1.extractTableComponent)(mainClass);\n    const mainMethod = mainTable.get('main');\n    if (!mainMethod) {\n        return {\n            errors: ['Main method not found'],\n            quadruples: '',\n            tuples: [],\n        };\n    }\n    const memory = new Memory_1.MemoryVisitor(symbolsTable, visitor.mainBranch);\n    memory.instantiate();\n    const allScopes = Object.keys(memory.methods);\n    const optimizedTuples = [];\n    for (const scope of allScopes) {\n        const allQuads = memory.methods[scope].map((t) => t.toTuple());\n        optimizedTuples.push(...optimize(allQuads));\n    }\n    const quadruples = memory.getQuadruples();\n    return {\n        errors: errors.map((e) => `[${e.line}: ${e.column}]${e.message}`),\n        quadruples,\n        tuples: optimizedTuples.map((t) => t.toString()),\n    };\n}\n// const pathToFileURL = path.join(__dirname, '..', 'example.txt');\n// const contents = fs.readFileSync(pathToFileURL, 'utf8');\n// main(contents);\nconst app = (0, express_1.default)();\nconst port = 3001;\napp.use(express_1.default.json());\napp.use(express_1.default.urlencoded({ extended: true }));\napp.get('/', (req, res) => {\n    res.sendStatus(200);\n});\napp.post('/', (req, res) => {\n    console.log('Received request');\n    const { program } = req.body;\n    if (!program) {\n        return res.sendStatus(400);\n    }\n    const parsed = JSON.parse(program);\n    const result = main(parsed);\n    res.json(result);\n});\napp.listen(port, () => {\n    console.log('Running on port', port);\n});\n\n\n//# sourceURL=webpack://proyecto2/./src/index.ts?")},"./src/yaplVisitor.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.YaplVisitor = void 0;\nconst AbstractParseTreeVisitor_1 = __webpack_require__(/*! antlr4ts/tree/AbstractParseTreeVisitor */ "antlr4ts/tree/AbstractParseTreeVisitor");\nconst index_1 = __webpack_require__(/*! ./Implementations/Components/index */ "./src/Implementations/Components/index.ts");\nconst Error_1 = __importDefault(__webpack_require__(/*! ./Implementations/DataStructures/Error */ "./src/Implementations/DataStructures/Error.ts"));\nconst Stack_1 = __webpack_require__(/*! ./Implementations/DataStructures/Stack */ "./src/Implementations/DataStructures/Stack.ts");\nconst Boolean_type_1 = __importDefault(__webpack_require__(/*! ./Implementations/Generics/Boolean.type */ "./src/Implementations/Generics/Boolean.type.ts"));\nconst Integer_type_1 = __importDefault(__webpack_require__(/*! ./Implementations/Generics/Integer.type */ "./src/Implementations/Generics/Integer.type.ts"));\nconst IO_type_1 = __webpack_require__(/*! ./Implementations/Generics/IO.type */ "./src/Implementations/Generics/IO.type.ts");\nconst Object_type_1 = __webpack_require__(/*! ./Implementations/Generics/Object.type */ "./src/Implementations/Generics/Object.type.ts");\nconst String_type_1 = __webpack_require__(/*! ./Implementations/Generics/String.type */ "./src/Implementations/Generics/String.type.ts");\nconst add_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/add */ "./src/Implementations/visitorFunctions/add.ts"));\nconst assignment_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/assignment */ "./src/Implementations/visitorFunctions/assignment.ts"));\nconst assignmentExpr_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/assignmentExpr */ "./src/Implementations/visitorFunctions/assignmentExpr.ts"));\nconst block_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/block */ "./src/Implementations/visitorFunctions/block.ts"));\nconst classDefine_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/classDefine */ "./src/Implementations/visitorFunctions/classDefine.ts"));\nconst division_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/division */ "./src/Implementations/visitorFunctions/division.ts"));\nconst equal_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/equal */ "./src/Implementations/visitorFunctions/equal.ts"));\nconst false_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/false */ "./src/Implementations/visitorFunctions/false.ts"));\nconst letin_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/letin */ "./src/Implementations/visitorFunctions/letin.ts"));\nconst formal_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/formal */ "./src/Implementations/visitorFunctions/formal.ts"));\nconst id_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/id */ "./src/Implementations/visitorFunctions/id.ts"));\nconst if_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/if */ "./src/Implementations/visitorFunctions/if.ts"));\nconst int_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/int */ "./src/Implementations/visitorFunctions/int.ts"));\nconst isVoid_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/isVoid */ "./src/Implementations/visitorFunctions/isVoid.ts"));\nconst lessEqual_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/lessEqual */ "./src/Implementations/visitorFunctions/lessEqual.ts"));\nconst lessThan_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/lessThan */ "./src/Implementations/visitorFunctions/lessThan.ts"));\nconst meta_1 = __webpack_require__(/*! ./Implementations/visitorFunctions/meta */ "./src/Implementations/visitorFunctions/meta.ts");\nconst method_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/method */ "./src/Implementations/visitorFunctions/method.ts"));\nconst methodCall_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/methodCall */ "./src/Implementations/visitorFunctions/methodCall.ts"));\nconst minus_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/minus */ "./src/Implementations/visitorFunctions/minus.ts"));\nconst multiply_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/multiply */ "./src/Implementations/visitorFunctions/multiply.ts"));\nconst negative_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/negative */ "./src/Implementations/visitorFunctions/negative.ts"));\nconst new_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/new */ "./src/Implementations/visitorFunctions/new.ts"));\nconst ownMethodCall_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/ownMethodCall */ "./src/Implementations/visitorFunctions/ownMethodCall.ts"));\nconst parentheses_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/parentheses */ "./src/Implementations/visitorFunctions/parentheses.ts"));\nconst property_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/property */ "./src/Implementations/visitorFunctions/property.ts"));\nconst string_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/string */ "./src/Implementations/visitorFunctions/string.ts"));\nconst true_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/true */ "./src/Implementations/visitorFunctions/true.ts"));\nconst while_1 = __importDefault(__webpack_require__(/*! ./Implementations/visitorFunctions/while */ "./src/Implementations/visitorFunctions/while.ts"));\nclass YaplVisitor extends AbstractParseTreeVisitor_1.AbstractParseTreeVisitor {\n    /** Helps recognize the stack: Global, Class or Method*/\n    scopeStack;\n    /** Universal Symbols table. Unique values only. */\n    symbolsTable;\n    /** Memory table. Allows for non-unique values. Similar to the symbols table. */\n    memoryTable;\n    /**\n     * @deprecated\n     * Workaround to show that a main does exist\n     */\n    mainExists = false;\n    /**\n     * @deprecated\n     * Shows whether or not the main method exists. No code is generated if mainExists is always false.\n     */\n    mainMethodExists = false;\n    /** Holds the quadruplets generated by the code. */\n    quadrupleArr = [];\n    /** Holds the Main\'s main method\'s quadruplets */\n    quadrupleArrMain = [];\n    /** Shows whether we are inside the main or not */\n    inMain = false;\n    /**\n     * @deprecated\n     * A rudomentary memory counter.\n     * */\n    memoryCounter = 0;\n    addQuadruple(newQuadruple) {\n        if (this.inMain) {\n            this.quadrupleArrMain.push(newQuadruple);\n            return;\n        }\n        this.quadrupleArr.push(newQuadruple);\n    }\n    enterMainScope() {\n        this.inMain = true;\n    }\n    exitMainScope() {\n        this.inMain = false;\n    }\n    mainBranch;\n    //#region Metadata\n    constructor() {\n        super();\n        this.scopeStack = new Stack_1.Stack(); // Scopes are implemented as a stack.\n        this.symbolsTable = new index_1.TableComponent(); // Symbols are universal\n        this.memoryTable = new index_1.TableComponent();\n        const objectType = new Object_type_1.ObjectType();\n        const intType = new Integer_type_1.default();\n        const stringType = new String_type_1.StringType();\n        const boolType = new Boolean_type_1.default();\n        const ioType = new IO_type_1.IOType();\n        this.scopeStack.push(new Object_type_1.ObjectType());\n        this.symbolsTable.add(objectType, intType, stringType, boolType, ioType);\n    }\n    _errorComponent = new Error_1.default();\n    _quadrupletComponent = new index_1.QuadrupletComponent();\n    errorComponent = () => this._errorComponent;\n    quadrupleComponent = () => this._quadrupletComponent;\n    registerMemory = (size) => {\n        const starterPointer = this.memoryCounter;\n        this.memoryCounter += size;\n        return starterPointer;\n    };\n    addScope = (newScope) => {\n        this.scopeStack.push(newScope);\n    };\n    addSymbol = (newSymbol) => {\n        this.symbolsTable.add(newSymbol);\n    };\n    getMemory = () => this.memoryCounter;\n    defaultResult() {\n        return [];\n    }\n    aggregateResult(aggregate, nextResult) {\n        if (Array.isArray(nextResult)) {\n            return [...(aggregate ?? []), ...(nextResult ?? [])];\n        }\n        return [...aggregate, nextResult];\n    }\n    addError(ctx, ...errorMessage) {\n        this.errorComponent().addError(ctx, ...errorMessage);\n    }\n    findTable(name) {\n        return this.symbolsTable.get(name.toString(), { inCurrentScope: true });\n    }\n    returnToScope(scope) {\n        while (this.scopeStack.size() > scope) {\n            this.scopeStack.pop();\n        }\n    }\n    next = (ctx) => super.visitChildren(ctx);\n    returnToGlobalScope() {\n        this.returnToScope(meta_1.Scope.Global);\n    }\n    // The second scope in the stack is always a class\n    getCurrentScope(p_offset) {\n        return this.scopeStack.getItem(p_offset ?? this.scopeStack.size() - 1);\n    }\n    //#endregion\n    visitClassDefine = (ctx) => {\n        return (0, classDefine_1.default)(this, ctx);\n    };\n    visitMethodCall = (ctx) => {\n        return (0, methodCall_1.default)(this, ctx);\n    };\n    visitLetIn = (ctx) => {\n        return (0, letin_1.default)(this, ctx);\n    };\n    visitOwnMethodCall = (ctx) => {\n        return (0, ownMethodCall_1.default)(this, ctx);\n    };\n    // The first if (the one on top of the stack) defines the type, the others follow it\n    visitIf = (ctx) => {\n        return (0, if_1.default)(this, ctx);\n    };\n    visitWhile = (ctx) => {\n        return (0, while_1.default)(this, ctx);\n    };\n    visitBlock = (ctx) => {\n        return (0, block_1.default)(this, ctx);\n    };\n    visitNew = (ctx) => {\n        return (0, new_1.default)(this, ctx);\n    };\n    visitNegative = (ctx) => {\n        return (0, negative_1.default)(this, ctx);\n    };\n    visitIsvoid = (ctx) => {\n        return (0, isVoid_1.default)(this, ctx);\n    };\n    visitMultiply = (ctx) => {\n        return (0, multiply_1.default)(this, ctx);\n    };\n    visitDivision = (ctx) => {\n        return (0, division_1.default)(this, ctx);\n    };\n    visitAdd = (ctx) => {\n        return (0, add_1.default)(this, ctx);\n    };\n    visitMinus = (ctx) => {\n        return (0, minus_1.default)(this, ctx);\n    };\n    // Less than return booleans.\n    visitLessThan = (ctx) => {\n        return (0, lessThan_1.default)(this, ctx);\n    };\n    visitLessEqual = (ctx) => {\n        return (0, lessEqual_1.default)(this, ctx);\n    };\n    visitEqual = (ctx) => {\n        return (0, equal_1.default)(this, ctx);\n    };\n    visitParentheses = (ctx) => {\n        return (0, parentheses_1.default)(this, ctx);\n    };\n    visitId = (ctx) => {\n        return (0, id_1.default)(this, ctx);\n    };\n    visitInt = (ctx) => {\n        return (0, int_1.default)(this, ctx);\n    };\n    visitString = (ctx) => {\n        return (0, string_1.default)(this, ctx);\n    };\n    visitTrue = (ctx) => {\n        return (0, true_1.default)(this, ctx);\n    };\n    visitFalse = (ctx) => {\n        return (0, false_1.default)(this, ctx);\n    };\n    visitAssignment = (ctx) => {\n        return (0, assignment_1.default)(this, ctx);\n    };\n    visitAssignmentExpr = (ctx) => {\n        return (0, assignmentExpr_1.default)(this, ctx);\n    };\n    visitMethod = (ctx) => {\n        return (0, method_1.default)(this, ctx);\n    };\n    visitProperty = (ctx) => {\n        return (0, property_1.default)(this, ctx);\n    };\n    visitFormal = (ctx) => {\n        return (0, formal_1.default)(this, ctx);\n    };\n}\nexports.YaplVisitor = YaplVisitor;\n\n\n//# sourceURL=webpack://proyecto2/./src/yaplVisitor.ts?')},antlr4ts:e=>{e.exports=require("antlr4ts")},"antlr4ts/FailedPredicateException":e=>{e.exports=require("antlr4ts/FailedPredicateException")},"antlr4ts/Lexer":e=>{e.exports=require("antlr4ts/Lexer")},"antlr4ts/NoViableAltException":e=>{e.exports=require("antlr4ts/NoViableAltException")},"antlr4ts/Parser":e=>{e.exports=require("antlr4ts/Parser")},"antlr4ts/ParserRuleContext":e=>{e.exports=require("antlr4ts/ParserRuleContext")},"antlr4ts/RecognitionException":e=>{e.exports=require("antlr4ts/RecognitionException")},"antlr4ts/VocabularyImpl":e=>{e.exports=require("antlr4ts/VocabularyImpl")},"antlr4ts/atn/ATN":e=>{e.exports=require("antlr4ts/atn/ATN")},"antlr4ts/atn/ATNDeserializer":e=>{e.exports=require("antlr4ts/atn/ATNDeserializer")},"antlr4ts/atn/LexerATNSimulator":e=>{e.exports=require("antlr4ts/atn/LexerATNSimulator")},"antlr4ts/atn/ParserATNSimulator":e=>{e.exports=require("antlr4ts/atn/ParserATNSimulator")},"antlr4ts/misc/Utils":e=>{e.exports=require("antlr4ts/misc/Utils")},"antlr4ts/tree/AbstractParseTreeVisitor":e=>{e.exports=require("antlr4ts/tree/AbstractParseTreeVisitor")},express:e=>{e.exports=require("express")},uuid:e=>{e.exports=require("uuid")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n){if(void 0!==n.error)throw n.error;return n.exports}var t=__webpack_module_cache__[e]={exports:{}};try{var r={id:e,module:t,factory:__webpack_modules__[e],require:__webpack_require__};__webpack_require__.i.forEach((function(e){e(r)})),t=r.module,r.factory.call(t.exports,t,t.exports,r.require)}catch(e){throw t.error=e,e}return t.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.c=__webpack_module_cache__,__webpack_require__.i=[],__webpack_require__.hu=e=>e+"."+__webpack_require__.h()+".hot-update.js",__webpack_require__.hmrF=()=>"server."+__webpack_require__.h()+".hot-update.json",__webpack_require__.h=()=>"d778123830db42b1f1b7",__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),(()=>{var e,n,t,r={},o=__webpack_require__.c,s=[],i=[],a="idle",l=0,p=[];function c(e){a=e;for(var n=[],t=0;t<i.length;t++)n[t]=i[t].call(null,e);return Promise.all(n)}function u(){0==--l&&c("ready").then((function(){if(0===l){var e=p;p=[];for(var n=0;n<e.length;n++)e[n]()}}))}function m(e){if("idle"!==a)throw new Error("check() is only allowed in idle status");return c("check").then(__webpack_require__.hmrM).then((function(t){return t?c("prepare").then((function(){var r=[];return n=[],Promise.all(Object.keys(__webpack_require__.hmrC).reduce((function(e,o){return __webpack_require__.hmrC[o](t.c,t.r,t.m,e,n,r),e}),[])).then((function(){return n=function(){return e?_(e):c("ready").then((function(){return r}))},0===l?n():new Promise((function(e){p.push((function(){e(n())}))}));var n}))})):c(d()?"ready":"idle").then((function(){return null}))}))}function x(e){return"ready"!==a?Promise.resolve().then((function(){throw new Error("apply() is only allowed in ready status (state: "+a+")")})):_(e)}function _(e){e=e||{},d();var r=n.map((function(n){return n(e)}));n=void 0;var o=r.map((function(e){return e.error})).filter(Boolean);if(o.length>0)return c("abort").then((function(){throw o[0]}));var s=c("dispose");r.forEach((function(e){e.dispose&&e.dispose()}));var i,a=c("apply"),l=function(e){i||(i=e)},p=[];return r.forEach((function(e){if(e.apply){var n=e.apply(l);if(n)for(var t=0;t<n.length;t++)p.push(n[t])}})),Promise.all([s,a]).then((function(){return i?c("fail").then((function(){throw i})):t?_(e).then((function(e){return p.forEach((function(n){e.indexOf(n)<0&&e.push(n)})),e})):c("idle").then((function(){return p}))}))}function d(){if(t)return n||(n=[]),Object.keys(__webpack_require__.hmrI).forEach((function(e){t.forEach((function(t){__webpack_require__.hmrI[e](t,n)}))})),t=void 0,!0}__webpack_require__.hmrD=r,__webpack_require__.i.push((function(p){var _,d,h,f,y=p.module,v=function(n,t){var r=o[t];if(!r)return n;var i=function(i){if(r.hot.active){if(o[i]){var a=o[i].parents;-1===a.indexOf(t)&&a.push(t)}else s=[t],e=i;-1===r.children.indexOf(i)&&r.children.push(i)}else console.warn("[HMR] unexpected require("+i+") from disposed module "+t),s=[];return n(i)},p=function(e){return{configurable:!0,enumerable:!0,get:function(){return n[e]},set:function(t){n[e]=t}}};for(var m in n)Object.prototype.hasOwnProperty.call(n,m)&&"e"!==m&&Object.defineProperty(i,m,p(m));return i.e=function(e){return function(e){switch(a){case"ready":c("prepare");case"prepare":return l++,e.then(u,u),e;default:return e}}(n.e(e))},i}(p.require,p.id);y.hot=(_=p.id,d=y,f={_acceptedDependencies:{},_acceptedErrorHandlers:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:h=e!==_,_requireSelf:function(){s=d.parents.slice(),e=h?void 0:_,__webpack_require__(_)},active:!0,accept:function(e,n,t){if(void 0===e)f._selfAccepted=!0;else if("function"==typeof e)f._selfAccepted=e;else if("object"==typeof e&&null!==e)for(var r=0;r<e.length;r++)f._acceptedDependencies[e[r]]=n||function(){},f._acceptedErrorHandlers[e[r]]=t;else f._acceptedDependencies[e]=n||function(){},f._acceptedErrorHandlers[e]=t},decline:function(e){if(void 0===e)f._selfDeclined=!0;else if("object"==typeof e&&null!==e)for(var n=0;n<e.length;n++)f._declinedDependencies[e[n]]=!0;else f._declinedDependencies[e]=!0},dispose:function(e){f._disposeHandlers.push(e)},addDisposeHandler:function(e){f._disposeHandlers.push(e)},removeDisposeHandler:function(e){var n=f._disposeHandlers.indexOf(e);n>=0&&f._disposeHandlers.splice(n,1)},invalidate:function(){switch(this._selfInvalidated=!0,a){case"idle":n=[],Object.keys(__webpack_require__.hmrI).forEach((function(e){__webpack_require__.hmrI[e](_,n)})),c("ready");break;case"ready":Object.keys(__webpack_require__.hmrI).forEach((function(e){__webpack_require__.hmrI[e](_,n)}));break;case"prepare":case"check":case"dispose":case"apply":(t=t||[]).push(_)}},check:m,apply:x,status:function(e){if(!e)return a;i.push(e)},addStatusHandler:function(e){i.push(e)},removeStatusHandler:function(e){var n=i.indexOf(e);n>=0&&i.splice(n,1)},data:r[_]},e=void 0,f),y.parents=s,y.children=[],s=[],p.require=v})),__webpack_require__.hmrC={},__webpack_require__.hmrI={}})(),(()=>{var e,n,t,r,o=__webpack_require__.hmrS_require=__webpack_require__.hmrS_require||{server:1};function s(e,t){var o=require("./"+__webpack_require__.hu(e)),s=o.modules,i=o.runtime;for(var a in s)__webpack_require__.o(s,a)&&(n[a]=s[a],t&&t.push(a));i&&r.push(i)}function i(s){function i(e){for(var n=[e],t={},r=n.map((function(e){return{chain:[e],id:e}}));r.length>0;){var o=r.pop(),s=o.id,i=o.chain,l=__webpack_require__.c[s];if(l&&(!l.hot._selfAccepted||l.hot._selfInvalidated)){if(l.hot._selfDeclined)return{type:"self-declined",chain:i,moduleId:s};if(l.hot._main)return{type:"unaccepted",chain:i,moduleId:s};for(var p=0;p<l.parents.length;p++){var c=l.parents[p],u=__webpack_require__.c[c];if(u){if(u.hot._declinedDependencies[s])return{type:"declined",chain:i.concat([c]),moduleId:s,parentId:c};-1===n.indexOf(c)&&(u.hot._acceptedDependencies[s]?(t[c]||(t[c]=[]),a(t[c],[s])):(delete t[c],n.push(c),r.push({chain:i.concat([c]),id:c})))}}}}return{type:"accepted",moduleId:e,outdatedModules:n,outdatedDependencies:t}}function a(e,n){for(var t=0;t<n.length;t++){var r=n[t];-1===e.indexOf(r)&&e.push(r)}}__webpack_require__.f&&delete __webpack_require__.f.requireHmr,e=void 0;var l={},p=[],c={},u=function(e){console.warn("[HMR] unexpected require("+e.id+") to disposed module")};for(var m in n)if(__webpack_require__.o(n,m)){var x,_=n[m],d=!1,h=!1,f=!1,y="";switch((x=_?i(m):{type:"disposed",moduleId:m}).chain&&(y="\nUpdate propagation: "+x.chain.join(" -> ")),x.type){case"self-declined":s.onDeclined&&s.onDeclined(x),s.ignoreDeclined||(d=new Error("Aborted because of self decline: "+x.moduleId+y));break;case"declined":s.onDeclined&&s.onDeclined(x),s.ignoreDeclined||(d=new Error("Aborted because of declined dependency: "+x.moduleId+" in "+x.parentId+y));break;case"unaccepted":s.onUnaccepted&&s.onUnaccepted(x),s.ignoreUnaccepted||(d=new Error("Aborted because "+m+" is not accepted"+y));break;case"accepted":s.onAccepted&&s.onAccepted(x),h=!0;break;case"disposed":s.onDisposed&&s.onDisposed(x),f=!0;break;default:throw new Error("Unexception type "+x.type)}if(d)return{error:d};if(h)for(m in c[m]=_,a(p,x.outdatedModules),x.outdatedDependencies)__webpack_require__.o(x.outdatedDependencies,m)&&(l[m]||(l[m]=[]),a(l[m],x.outdatedDependencies[m]));f&&(a(p,[x.moduleId]),c[m]=u)}n=void 0;for(var v,b=[],C=0;C<p.length;C++){var T=p[C],g=__webpack_require__.c[T];g&&(g.hot._selfAccepted||g.hot._main)&&c[T]!==u&&!g.hot._selfInvalidated&&b.push({module:T,require:g.hot._requireSelf,errorHandler:g.hot._selfAccepted})}return{dispose:function(){var e;t.forEach((function(e){delete o[e]})),t=void 0;for(var n,r=p.slice();r.length>0;){var s=r.pop(),i=__webpack_require__.c[s];if(i){var a={},c=i.hot._disposeHandlers;for(C=0;C<c.length;C++)c[C].call(null,a);for(__webpack_require__.hmrD[s]=a,i.hot.active=!1,delete __webpack_require__.c[s],delete l[s],C=0;C<i.children.length;C++){var u=__webpack_require__.c[i.children[C]];u&&((e=u.parents.indexOf(s))>=0&&u.parents.splice(e,1))}}}for(var m in l)if(__webpack_require__.o(l,m)&&(i=__webpack_require__.c[m]))for(v=l[m],C=0;C<v.length;C++)n=v[C],(e=i.children.indexOf(n))>=0&&i.children.splice(e,1)},apply:function(e){for(var n in c)__webpack_require__.o(c,n)&&(__webpack_require__.m[n]=c[n]);for(var t=0;t<r.length;t++)r[t](__webpack_require__);for(var o in l)if(__webpack_require__.o(l,o)){var i=__webpack_require__.c[o];if(i){v=l[o];for(var a=[],u=[],m=[],x=0;x<v.length;x++){var _=v[x],d=i.hot._acceptedDependencies[_],h=i.hot._acceptedErrorHandlers[_];if(d){if(-1!==a.indexOf(d))continue;a.push(d),u.push(h),m.push(_)}}for(var f=0;f<a.length;f++)try{a[f].call(null,v)}catch(n){if("function"==typeof u[f])try{u[f](n,{moduleId:o,dependencyId:m[f]})}catch(t){s.onErrored&&s.onErrored({type:"accept-error-handler-errored",moduleId:o,dependencyId:m[f],error:t,originalError:n}),s.ignoreErrored||(e(t),e(n))}else s.onErrored&&s.onErrored({type:"accept-errored",moduleId:o,dependencyId:m[f],error:n}),s.ignoreErrored||e(n)}}}for(var y=0;y<b.length;y++){var C=b[y],T=C.module;try{C.require(T)}catch(n){if("function"==typeof C.errorHandler)try{C.errorHandler(n,{moduleId:T,module:__webpack_require__.c[T]})}catch(t){s.onErrored&&s.onErrored({type:"self-accept-error-handler-errored",moduleId:T,error:t,originalError:n}),s.ignoreErrored||(e(t),e(n))}else s.onErrored&&s.onErrored({type:"self-accept-errored",moduleId:T,error:n}),s.ignoreErrored||e(n)}}return p}}}__webpack_require__.hmrI.require=function(e,o){n||(n={},r=[],t=[],o.push(i)),__webpack_require__.o(n,e)||(n[e]=__webpack_require__.m[e])},__webpack_require__.hmrC.require=function(a,l,p,c,u,m){u.push(i),e={},t=l,n=p.reduce((function(e,n){return e[n]=!1,e}),{}),r=[],a.forEach((function(n){__webpack_require__.o(o,n)&&void 0!==o[n]?(c.push(s(n,m)),e[n]=!0):e[n]=!1})),__webpack_require__.f&&(__webpack_require__.f.requireHmr=function(n,t){e&&__webpack_require__.o(e,n)&&!e[n]&&(t.push(s(n)),e[n]=!0)})},__webpack_require__.hmrM=function(){return Promise.resolve().then((function(){return require("./"+__webpack_require__.hmrF())})).catch((function(e){if("MODULE_NOT_FOUND"!==e.code)throw e}))}})();var __webpack_exports__=__webpack_require__("./src/index.ts")})();