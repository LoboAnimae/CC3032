import { AbstractParseTreeVisitor } from 'antlr4ts/tree/AbstractParseTreeVisitor';

import {
  CompositionComponent,
  ErrorComponent,
  QuadrupletComponent,
  QuadrupletElement,
  TableComponent,
  TypeComponent,
} from 'Components';
import { Stack } from 'Implementations/DataStructures/Stack';
import { MethodElement } from 'Implementations/DataStructures/TableElements';
import { BoolType, ClassType, IntType, IOType, ObjectType, StringType } from 'Implementations/Generics';

import {
  AddContext,
  AssignmentContext,
  AssignmentExprContext,
  BlockContext,
  ClassDefineContext,
  DivisionContext,
  EqualContext,
  FalseContext,
  FormalContext,
  IdContext,
  IfContext,
  IntContext,
  IsvoidContext,
  LessEqualContext,
  LessThanContext,
  LetInContext,
  MethodCallContext,
  MethodContext,
  MinusContext,
  MultiplyContext,
  NegativeContext,
  NewContext,
  OwnMethodCallContext,
  ParenthesesContext,
  PropertyContext,
  StringContext,
  TrueContext,
  WhileContext,
} from 'antlr/yaplParser';
import { Scope, ScopePosition } from 'Implementations/3_Semantic/Functions';
import {
  visitAdd,
  visitAssignment,
  visitAssignmentExpr,
  visitBlock,
  visitClassDefine,
  visitDivision,
  visitEqual,
  visitFalse,
  visitFormal,
  visitId,
  visitIf,
  visitInt,
  visitIsvoid,
  visitLessEqual,
  visitLessThan,
  visitLetIn,
  visitMethod,
  visitMethodCall,
  visitMinus,
  visitMultiply,
  visitNegative,
  visitNew,
  visitOwnMethodCall,
  visitParentheses,
  visitProperty,
  visitString,
  visitTrue,
  visitWhile,
} from 'Implementations/3_Semantic/tokens';
import { yaplVisitor } from '../../antlr/yaplVisitor';

export class YaplVisitor extends AbstractParseTreeVisitor<any> implements yaplVisitor<any> {
  /** Helps recognize the stack: Global, Class or Method*/
  public scopeStack: Stack<CompositionComponent>;
  /** Universal Symbols table. Unique values only. */
  public symbolsTable: TableComponent<TypeComponent>;
  /** Memory table. Allows for non-unique values. Similar to the symbols table. */
  public memoryTable: TableComponent<TypeComponent>;
  /**
   * @deprecated
   * Workaround to show that a main does exist
   */
  public mainExists: boolean = false;
  /**
   * @deprecated
   * Shows whether or not the main method exists. No code is generated if mainExists is always false.
   */
  public mainMethodExists: boolean = false;
  /** Holds the quadruplets generated by the code. */
  public quadrupleArr: QuadrupletElement[] = [];
  /** Holds the Main's main method's quadruplets */
  public quadrupleArrMain: QuadrupletElement[] = [];
  /** Shows whether we are inside the main or not */
  public inMain: boolean = false;
  /**
   * @deprecated
   * A rudomentary memory counter.
   * */
  private memoryCounter: number = 0;

  addQuadruple(newQuadruple: QuadrupletElement): void {
    if (this.inMain) {
      this.quadrupleArrMain.push(newQuadruple);
      return;
    }
    this.quadrupleArr.push(newQuadruple);
  }

  enterMainScope() {
    this.inMain = true;
  }
  exitMainScope() {
    this.inMain = false;
  }

  mainBranch?: ClassDefineContext;

  //#region Metadata

  constructor() {
    super();
    this.scopeStack = new Stack<TypeComponent>(); // Scopes are implemented as a stack.
    this.symbolsTable = new TableComponent<TypeComponent>(); // Symbols are universal
    this.memoryTable = new TableComponent<TypeComponent>();
    const objectType = new ObjectType();
    const intType = new IntType();
    const stringType = new StringType();
    const boolType = new BoolType();
    const ioType = new IOType();

    this.scopeStack.push(new ObjectType());
    this.symbolsTable.add(objectType, intType, stringType, boolType, ioType);
  }

  private _errorComponent = new ErrorComponent();
  private _quadrupletComponent = new QuadrupletComponent();
  errorComponent = () => this._errorComponent;
  quadrupleComponent = () => this._quadrupletComponent;
  registerMemory: (size: number) => number = (size: number) => {
    const starterPointer = this.memoryCounter;
    this.memoryCounter += size;
    return starterPointer;
  };

  addScope = (newScope: TypeComponent) => {
    this.scopeStack.push(newScope);
  };

  addSymbol = (newSymbol: TypeComponent) => {
    this.symbolsTable.add(newSymbol);
  };

  getMemory = () => this.memoryCounter;

  defaultResult(): any {
    return [];
  }

  aggregateResult(aggregate: any, nextResult: any) {
    if (Array.isArray(nextResult)) {
      return [...(aggregate ?? []), ...(nextResult ?? [])];
    }
    return [...aggregate, nextResult];
  }

  addError(ctx: any, ...errorMessage: string[]) {
    this.errorComponent().addError(ctx, ...errorMessage);
  }

  findTable(name: string | TypeComponent | any): ClassType | null {
    return this.symbolsTable.get(name.toString(), { inCurrentScope: true }) as ClassType;
  }

  returnToScope(scope: Scope): void {
    while (this.scopeStack.size() > scope) {
      this.scopeStack.pop();
    }
  }

  next = (ctx: any) => super.visitChildren(ctx);

  returnToGlobalScope() {
    this.returnToScope(Scope.Global);
  }

  // The second scope in the stack is always a class
  getCurrentScope<T = ClassType | MethodElement>(p_offset?: ScopePosition): T {
    return this.scopeStack.getItem(p_offset ?? this.scopeStack.size() - 1) as T;
  }

  //#endregion

  visitClassDefine = (ctx: ClassDefineContext) => {
    return visitClassDefine(this, ctx);
  };

  visitMethodCall = (ctx: MethodCallContext) => {
    return visitMethodCall(this, ctx);
  };

  visitLetIn = (ctx: LetInContext) => {
    return visitLetIn(this, ctx);
  };

  visitOwnMethodCall = (ctx: OwnMethodCallContext) => {
    return visitOwnMethodCall(this, ctx);
  };

  // The first if (the one on top of the stack) defines the type, the others follow it
  visitIf = (ctx: IfContext) => {
    return visitIf(this, ctx);
  };

  visitWhile = (ctx: WhileContext) => {
    return visitWhile(this, ctx);
  };

  visitBlock = (ctx: BlockContext) => {
    return visitBlock(this, ctx);
  };

  visitNew = (ctx: NewContext) => {
    return visitNew(this, ctx);
  };

  visitNegative = (ctx: NegativeContext) => {
    return visitNegative(this, ctx);
  };

  visitIsvoid = (ctx: IsvoidContext) => {
    return visitIsvoid(this, ctx);
  };

  visitMultiply = (ctx: MultiplyContext) => {
    return visitMultiply(this, ctx);
  };

  visitDivision = (ctx: DivisionContext) => {
    return visitDivision(this, ctx);
  };
  visitAdd = (ctx: AddContext) => {
    return visitAdd(this, ctx);
  };
  visitMinus = (ctx: MinusContext) => {
    return visitMinus(this, ctx);
  };

  // Less than return booleans.
  visitLessThan = (ctx: LessThanContext) => {
    return visitLessThan(this, ctx);
  };

  visitLessEqual = (ctx: LessEqualContext) => {
    return visitLessEqual(this, ctx);
  };
  visitEqual = (ctx: EqualContext) => {
    return visitEqual(this, ctx);
  };

  visitParentheses = (ctx: ParenthesesContext) => {
    return visitParentheses(this, ctx);
  };

  visitId = (ctx: IdContext) => {
    return visitId(this, ctx);
  };

  visitInt = (ctx: IntContext) => {
    return visitInt(this, ctx);
  };

  visitString = (ctx: StringContext) => {
    return visitString(this, ctx);
  };

  visitTrue = (ctx: TrueContext) => {
    return visitTrue(this, ctx);
  };

  visitFalse = (ctx: FalseContext) => {
    return visitFalse(this, ctx);
  };

  visitAssignment = (ctx: AssignmentContext) => {
    return visitAssignment(this, ctx);
  };

  visitAssignmentExpr = (ctx: AssignmentExprContext) => {
    return visitAssignmentExpr(this, ctx);
  };

  visitMethod = (ctx: MethodContext) => {
    return visitMethod(this, ctx);
  };

  visitProperty = (ctx: PropertyContext) => {
    return visitProperty(this, ctx);
  };

  visitFormal = (ctx: FormalContext) => {
    return visitFormal(this, ctx);
  };
}
