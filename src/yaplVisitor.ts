import { AbstractParseTreeVisitor } from 'antlr4ts/tree/AbstractParseTreeVisitor';
import {
  AddContext,
  AssignmentContext,
  BlockContext,
  ClassDefineContext,
  DivisionContext,
  EqualContext,
  FalseContext,
  FormalContext,
  IdContext,
  IfContext,
  IntContext,
  IsvoidContext,
  LessEqualContext,
  LessThanContext,
  MethodCallContext,
  MethodContext,
  MinusContext,
  MultiplyContext,
  NegativeContext,
  NewContext,
  OwnMethodCallContext,
  ParenthesesContext,
  PropertyContext,
  StringContext,
  TrueContext,
  WhileContext,
} from './antlr/yaplParser';
import { yaplVisitor } from './antlr/yaplVisitor';
import {
  CompositionComponent,
  QuadrupletComponent,
  QuadrupletElement,
  TableComponent,
  TypeComponent,
} from './Implementations/Components/index';
import ErrorComponent from './Implementations/DataStructures/Error';
import { MemoryVisitor } from './Implementations/DataStructures/Memory';
import { Stack } from './Implementations/DataStructures/Stack';
import { MethodElement, SymbolElement } from './Implementations/DataStructures/TableElements/index';
import { BasicStorage } from './Implementations/Errors/Errors';
import Bool from './Implementations/Generics/Boolean.type';
import { default as IntType } from './Implementations/Generics/Integer.type';
import { IOType } from './Implementations/Generics/IO.type';
import { ClassType, ObjectType } from './Implementations/Generics/Object.type';
import { StringType } from './Implementations/Generics/String.type';
import visitAdd from './Implementations/visitorFunctions/add';
import visitAssignment from './Implementations/visitorFunctions/assignment';
import visitBlock from './Implementations/visitorFunctions/block';
import visitClassDefine from './Implementations/visitorFunctions/classDefine';
import visitDivision from './Implementations/visitorFunctions/division';
import visitEqual from './Implementations/visitorFunctions/equal';
import visitFalse from './Implementations/visitorFunctions/false';
import visitFormal from './Implementations/visitorFunctions/formal';
import visitId from './Implementations/visitorFunctions/id';
import visitIf from './Implementations/visitorFunctions/if';
import visitInt from './Implementations/visitorFunctions/int';
import visitIsvoid from './Implementations/visitorFunctions/isVoid';
import visitLessEqual from './Implementations/visitorFunctions/lessEqual';
import visitLessThan from './Implementations/visitorFunctions/lessThan';
import {
  HelperFunctions,
  ParseTreeProperties,
  Scope,
  ScopePosition,
  YaplParserComponents,
} from './Implementations/visitorFunctions/meta';
import visitMethod from './Implementations/visitorFunctions/method';
import visitMethodCall from './Implementations/visitorFunctions/methodCall';
import visitMinus from './Implementations/visitorFunctions/minus';
import visitMultiply from './Implementations/visitorFunctions/multiply';
import visitNegative from './Implementations/visitorFunctions/negative';
import visitNew from './Implementations/visitorFunctions/new';
import visitOwnMethodCall from './Implementations/visitorFunctions/ownMethodCall';
import visitParentheses from './Implementations/visitorFunctions/parentheses';
import visitProperty from './Implementations/visitorFunctions/property';
import visitString from './Implementations/visitorFunctions/string';
import visitTrue from './Implementations/visitorFunctions/true';
import visitWhile from './Implementations/visitorFunctions/while';

export class YaplVisitor
  extends AbstractParseTreeVisitor<any>
  implements yaplVisitor<any>, HelperFunctions, ParseTreeProperties, YaplParserComponents
{
  /** Helps recognize the stack: Global, Class or Method*/
  public scopeStack: Stack<CompositionComponent>;
  /** Universal Symbols table. Unique values only. */
  public symbolsTable: TableComponent<TypeComponent>;
  /** Memory table. Allows for non-unique values. Similar to the symbols table. */
  public memoryTable: TableComponent<TypeComponent>;
  /**
   * @deprecated
   * Workaround to show that a main does exist
   */
  public mainExists: boolean = false;
  /**
   * @deprecated
   * Shows whether or not the main method exists. No code is generated if mainExists is always false.
   */
  public mainMethodExists: boolean = false;
  /** Holds the quadruplets generated by the code. */
  public quadrupleArr: QuadrupletElement[] = [];
  /** Holds the Main's main method's quadruplets */
  public quadrupleArrMain: QuadrupletElement[] = [];
  /** Shows whether we are inside the main or not */
  public inMain: boolean = false;
  /**
   * @deprecated
   * A rudomentary memory counter.
   * */
  private memoryCounter: number = 0;

  addQuadruple(newQuadruple: QuadrupletElement): void {
    if (this.inMain) {
      this.quadrupleArrMain.push(newQuadruple);
      return;
    }
    this.quadrupleArr.push(newQuadruple);
  }

  enterMainScope() {
    this.inMain = true;
  }
  exitMainScope() {
    this.inMain = false;
  }

  mainBranch: ClassDefineContext | null = null;

  //#region Metadata

  constructor() {
    super();
    this.scopeStack = new Stack<TypeComponent>(); // Scopes are implemented as a stack.
    this.symbolsTable = new TableComponent<TypeComponent>(); // Symbols are universal
    this.memoryTable = new TableComponent<TypeComponent>();
    const objectType = new ObjectType();
    const intType = new IntType();
    const stringType = new StringType();
    const boolType = new Bool();
    const ioType = new IOType();

    this.scopeStack.push(new ObjectType());
    this.symbolsTable.add(objectType, intType, stringType, boolType, ioType);
  }

  private _errorComponent = new ErrorComponent();
  private _quadrupletComponent = new QuadrupletComponent();
  errorComponent = () => this._errorComponent;
  quadrupleComponent = () => this._quadrupletComponent;
  registerMemory: (size: number) => number = (size: number) => {
    const starterPointer = this.memoryCounter;
    this.memoryCounter += size;
    return starterPointer;
  };

  addScope = (newScope: TypeComponent) => {
    this.scopeStack.push(newScope);
  };

  addSymbol = (newSymbol: TypeComponent) => {
    this.symbolsTable.add(newSymbol);
  };

  getMemory = () => this.memoryCounter;

  defaultResult(): any {
    return [];
  }

  aggregateResult(aggregate: any, nextResult: any) {
    if (Array.isArray(nextResult)) {
      return [...(aggregate ?? []), ...(nextResult ?? [])];
    }
    return [...aggregate, nextResult];
  }

  addError(ctx: any, ...errorMessage: string[]) {
    this.errorComponent().addError(ctx, ...errorMessage);
  }

  findTable(name: string | TypeComponent | any): ClassType | null {
    return this.symbolsTable.get(name.toString(), { inCurrentScope: true }) as ClassType;
  }

  returnToScope(scope: Scope): void {
    while (this.scopeStack.size() > scope) {
      this.scopeStack.pop();
    }
  }

  next = (ctx: any) => super.visitChildren(ctx);

  returnToGlobalScope() {
    this.returnToScope(Scope.Global);
  }

  // The second scope in the stack is always a class
  getCurrentScope<T = ClassType | MethodElement>(p_offset?: ScopePosition): T {
    return this.scopeStack.getItem(p_offset ?? this.scopeStack.size() - 1) as T;
  }

  //#endregion

  visitClassDefine = (ctx: ClassDefineContext) => {
    return visitClassDefine(this, ctx);
  };

  visitMethodCall = (ctx: MethodCallContext) => {
    return visitMethodCall(this, ctx);
  };

  visitOwnMethodCall = (ctx: OwnMethodCallContext) => {
    return visitOwnMethodCall(this, ctx);
  };

  // The first if (the one on top of the stack) defines the type, the others follow it
  visitIf = (ctx: IfContext) => {
    return visitIf(this, ctx);
  };

  visitWhile = (ctx: WhileContext) => {
    return visitWhile(this, ctx);
  };

  visitBlock = (ctx: BlockContext) => {
    return visitBlock(this, ctx);
  };

  visitNew = (ctx: NewContext) => {
    return visitNew(this, ctx);
  };

  visitNegative = (ctx: NegativeContext) => {
    return visitNegative(this, ctx);
  };

  visitIsvoid = (ctx: IsvoidContext) => {
    return visitIsvoid(this, ctx);
  };

  visitMultiply = (ctx: MultiplyContext) => {
    return visitMultiply(this, ctx);
  };

  visitDivision = (ctx: DivisionContext) => {
    return visitDivision(this, ctx);
  };
  visitAdd = (ctx: AddContext) => {
    return visitAdd(this, ctx);
  };
  visitMinus = (ctx: MinusContext) => {
    return visitMinus(this, ctx);
  };

  // Less than return booleans.
  visitLessThan = (ctx: LessThanContext) => {
    return visitLessThan(this, ctx);
  };

  visitLessEqual = (ctx: LessEqualContext) => {
    return visitLessEqual(this, ctx);
  };
  visitEqual = (ctx: EqualContext) => {
    return visitEqual(this, ctx);
  };

  visitParentheses = (ctx: ParenthesesContext) => {
    return visitParentheses(this, ctx);
  };

  visitId = (ctx: IdContext) => {
    return visitId(this, ctx);
  };

  visitInt = (ctx: IntContext) => {
    return visitInt(this, ctx);
  };

  visitString = (ctx: StringContext) => {
    return visitString(this, ctx);
  };

  visitTrue = (ctx: TrueContext) => {
    return visitTrue(this, ctx);
  };

  visitFalse = (ctx: FalseContext) => {
    return visitFalse(this, ctx);
  };

  visitAssignment = (ctx: AssignmentContext) => {
    return visitAssignment(this, ctx);
  };

  visitMethod = (ctx: MethodContext) => {
    return visitMethod(this, ctx);
  };

  visitProperty = (ctx: PropertyContext) => {
    return visitProperty(this, ctx);
  };

  visitFormal = (ctx: FormalContext) => {
    return visitFormal(this, ctx);
  };
}
